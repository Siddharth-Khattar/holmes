---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/schemas/__init__.py
  - backend/app/schemas/health.py
  - backend/app/schemas/common.py
  - packages/types/src/generated/api.ts
  - packages/types/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Pydantic schemas in backend/app/schemas/ define API types"
    - "Running 'make generate-types' produces TypeScript in packages/types"
    - "Generated TypeScript types are importable from @holmes/types"
    - "Type generation is idempotent (running twice produces same output)"
  artifacts:
    - path: "backend/app/schemas/__init__.py"
      provides: "Pydantic schema exports"
      contains: "HealthResponse"
    - path: "backend/app/schemas/health.py"
      provides: "Health endpoint schemas"
      contains: "class HealthResponse"
    - path: "packages/types/src/generated/api.ts"
      provides: "Generated TypeScript types"
      contains: "interface HealthResponse"
  key_links:
    - from: "backend/app/schemas/health.py"
      to: "packages/types/src/generated/api.ts"
      via: "pydantic2ts generation"
      pattern: "HealthResponse"
---

<objective>
Set up the Pydantic-to-TypeScript type generation pipeline.

Purpose: Establishes Python as the source of truth for API types, with automatic TypeScript generation for frontend type safety.
Output: Working type generation that converts Pydantic models to TypeScript interfaces.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for Phase 1 endpoints</name>
  <files>
    - backend/app/schemas/__init__.py
    - backend/app/schemas/health.py
    - backend/app/schemas/common.py
  </files>
  <action>
Create initial Pydantic schemas that will be the source of truth for API types:

1. backend/app/schemas/common.py:
- ErrorResponse model:
  - code: str
  - message: str
  - details: dict[str, Any] | None = None
  - recoverable: bool = True
  - suggested_action: str | None = None
- TimestampMixin for created_at, updated_at fields (as needed)

2. backend/app/schemas/health.py:
- HealthResponse model:
  - status: Literal["healthy", "unhealthy"]
  - database: str | None = None (connection status)
  - timestamp: datetime
- Use model_config with json_schema_extra for examples

3. backend/app/schemas/__init__.py:
- Export all schemas from submodules
- ABOUTME comment explaining this is the source of truth for API types
- Note that types are generated to packages/types via pydantic2ts
  </action>
  <verify>
- cd backend && uv run python -c "from app.schemas import HealthResponse, ErrorResponse"
- uv run python -c "from app.schemas.health import HealthResponse; print(HealthResponse.model_json_schema())"
  </verify>
  <done>
Pydantic schemas exist and are importable, ready for type generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure and test type generation pipeline</name>
  <files>
    - packages/types/src/generated/api.ts
    - packages/types/src/index.ts
    - packages/types/package.json
  </files>
  <action>
1. Update packages/types/package.json to properly export types:
- Add "types" field pointing to generated types
- Add "exports" for ESM/CJS compatibility
- Ensure "main" and "module" point correctly

2. Create packages/types/src/index.ts:
- Re-export everything from ./generated/api
- Add ABOUTME comment noting these are auto-generated from Python

3. Run type generation:
- Execute: cd backend && uv run pydantic2ts --module app.schemas --output ../packages/types/src/generated/api.ts
- If pydantic2ts has issues, fall back to: uv run datamodel-codegen --input-file-type jsonschema --output ../packages/types/src/generated/api.ts (with JSON schema export)

4. Verify generated types:
- Check that HealthResponse interface exists
- Check that ErrorResponse interface exists
- Ensure proper TypeScript syntax

5. Update Makefile generate-types target if command differs from initial setup
  </action>
  <verify>
- File packages/types/src/generated/api.ts exists and contains TypeScript interfaces
- grep "interface HealthResponse" packages/types/src/generated/api.ts returns match
- From frontend (when created): import { HealthResponse } from '@holmes/types' compiles
  </verify>
  <done>
Type generation pipeline works: make generate-types produces valid TypeScript from Pydantic schemas.
  </done>
</task>

</tasks>

<verification>
1. Pydantic schemas importable: `cd backend && uv run python -c "from app.schemas import *"`
2. Type generation succeeds: `make generate-types` runs without errors
3. TypeScript file exists: `cat packages/types/src/generated/api.ts` shows interfaces
4. Types are idempotent: Running `make generate-types` twice produces identical output
</verification>

<success_criteria>
- backend/app/schemas/ contains HealthResponse, ErrorResponse Pydantic models
- packages/types/src/generated/api.ts contains corresponding TypeScript interfaces
- make generate-types successfully regenerates types
- Generated types are committed to repo (not gitignored per CONTEXT.md decision)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
