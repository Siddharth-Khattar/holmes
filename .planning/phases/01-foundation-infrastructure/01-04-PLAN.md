---
phase: 01-foundation-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/main.py
  - backend/app/database.py
  - backend/app/storage.py
  - backend/app/api/__init__.py
  - backend/app/api/health.py
  - backend/app/api/sse.py
  - backend/app/models/__init__.py
  - backend/app/models/base.py
  - backend/alembic.ini
  - backend/alembic/env.py
  - backend/alembic/script.py.mako
  - backend/alembic/versions/.gitkeep
  - backend/Dockerfile
autonomous: true

must_haves:
  truths:
    - "Running 'uv run uvicorn app.main:app' starts the server"
    - "GET /health returns 200 with status: healthy"
    - "GET /health/db returns database connection status"
    - "GET /health/storage returns GCS bucket accessibility status"
    - "GET /sse/heartbeat streams SSE events"
    - "Alembic can generate and run migrations"
    - "GCS bucket accessible from backend"
  artifacts:
    - path: "backend/app/main.py"
      provides: "FastAPI application entry point"
      contains: "FastAPI"
    - path: "backend/app/database.py"
      provides: "Async SQLAlchemy engine"
      contains: "create_async_engine"
    - path: "backend/app/storage.py"
      provides: "GCS client for evidence storage"
      contains: "storage.Client"
    - path: "backend/app/api/health.py"
      provides: "Health check endpoints including storage"
      exports: ["router"]
    - path: "backend/app/api/sse.py"
      provides: "SSE heartbeat endpoint"
      contains: "EventSourceResponse"
    - path: "backend/Dockerfile"
      provides: "Production container image"
      contains: "uvicorn"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/api/health.py"
      via: "router include"
      pattern: "include_router"
    - from: "backend/app/api/health.py"
      to: "backend/app/database.py"
      via: "dependency injection"
      pattern: "get_db"
    - from: "backend/app/api/health.py"
      to: "backend/app/storage.py"
      via: "GCS client import"
      pattern: "check_bucket_accessible"
---

<objective>
Create the FastAPI backend skeleton with health endpoint, database connection, GCS storage client, SSE skeleton, and Docker configuration.

Purpose: Establishes a deployable backend service with the core infrastructure needed for all subsequent features.
Output: Running FastAPI server with health checks (including GCS), database connectivity, and SSE capability.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database layer, GCS client, and models base</name>
  <files>
    - backend/app/database.py
    - backend/app/storage.py
    - backend/app/models/__init__.py
    - backend/app/models/base.py
  </files>
  <action>
1. backend/app/database.py (from 01-RESEARCH.md Pattern 2):
- create_async_engine with settings.database_url
- Pool configuration for Cloud Run:
  - pool_size=5
  - max_overflow=10
  - pool_pre_ping=True
  - pool_recycle=1800
  - echo=settings.debug
- AsyncSessionLocal = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
- async def get_db() dependency that yields session

2. backend/app/storage.py:
- ABOUTME: GCS client initialization and helpers for evidence storage
- Import google.cloud.storage
- Create get_storage_client() function that returns storage.Client()
- Create get_bucket() function that returns client.bucket(settings.gcs_bucket)
- Create check_bucket_accessible() function that:
  - Gets the bucket via get_bucket()
  - Calls bucket.exists() to verify accessibility
  - Returns True if accessible, False otherwise
  - Handles exceptions gracefully (returns False on error with logged warning)

3. backend/app/models/base.py:
- Import DeclarativeBase from sqlalchemy.orm
- Create Base class extending DeclarativeBase
- Add ABOUTME comment

4. backend/app/models/__init__.py:
- Import and export Base
- This will later export all model classes
  </action>
  <verify>
- cd backend && uv run python -c "from app.database import engine, get_db"
- uv run python -c "from app.models import Base"
- uv run python -c "from app.storage import get_storage_client, check_bucket_accessible"
  </verify>
  <done>
Database layer is configured with async SQLAlchemy and connection pooling. GCS client is initialized with accessibility check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI app with health (including storage) and SSE endpoints</name>
  <files>
    - backend/app/main.py
    - backend/app/api/__init__.py
    - backend/app/api/health.py
    - backend/app/api/sse.py
  </files>
  <action>
1. backend/app/api/__init__.py:
- ABOUTME comment
- Empty for now (routers imported directly)

2. backend/app/api/health.py (from 01-RESEARCH.md):
- router = APIRouter()
- GET /health: Returns {"status": "healthy", "timestamp": datetime}
- GET /health/db:
  - Depends on get_db
  - Executes "SELECT 1"
  - Returns {"status": "healthy/unhealthy", "database": "connected/error", "timestamp": datetime}
  - Use HealthResponse schema from app.schemas
- GET /health/storage:
  - Imports check_bucket_accessible from app.storage
  - Imports settings from app.config for bucket name
  - Calls check_bucket_accessible()
  - Returns {"status": "healthy/unhealthy", "storage": "accessible/inaccessible", "bucket": settings.gcs_bucket, "timestamp": datetime}
  - This endpoint verifies GCS bucket is accessible from the backend (phase exit criteria)

3. backend/app/api/sse.py (from 01-RESEARCH.md Pattern 3):
- router = APIRouter()
- async def heartbeat_generator():
  - Infinite loop yielding {"event": "heartbeat", "data": "ping"}
  - await asyncio.sleep(15) between heartbeats
- GET /sse/heartbeat:
  - Returns EventSourceResponse with heartbeat_generator
  - Headers: X-Accel-Buffering: no, Cache-Control: no-cache, no-transform

4. backend/app/main.py (from 01-RESEARCH.md Pattern 4):
- app = FastAPI(title="Holmes API", version="0.1.0")
- CORSMiddleware with settings.cors_origins
- DO NOT add GZipMiddleware (breaks SSE)
- Include health.router with prefix="" and tags=["health"]
- Include sse.router with prefix="" and tags=["sse"]
- Add lifespan handler to verify database on startup (optional log)
  </action>
  <verify>
- Start server: cd backend && uv run uvicorn app.main:app --reload --port 8080
- curl http://localhost:8080/health returns {"status": "healthy", ...}
- curl http://localhost:8080/health/db returns database status (after docker compose up)
- curl http://localhost:8080/health/storage returns storage status (requires GCS credentials or running on GCP)
- curl -N http://localhost:8080/sse/heartbeat streams heartbeat events
  </verify>
  <done>
FastAPI application runs with health checks (including GCS storage accessibility) and SSE heartbeat endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure Alembic and Dockerfile</name>
  <files>
    - backend/alembic.ini
    - backend/alembic/env.py
    - backend/alembic/script.py.mako
    - backend/alembic/versions/.gitkeep
    - backend/Dockerfile
  </files>
  <action>
1. Initialize Alembic with async template:
- Run: cd backend && uv run alembic init -t async alembic
- This creates alembic.ini and alembic/ directory

2. Update backend/alembic/env.py (from 01-RESEARCH.md Pattern 5):
- Import Base from app.models
- Import settings from app.config
- Set sqlalchemy.url from settings.database_url
- Configure target_metadata = Base.metadata
- Ensure async migration runner is properly configured

3. Create backend/alembic/versions/.gitkeep to track empty directory

4. backend/Dockerfile (from 01-RESEARCH.md):
```dockerfile
FROM python:3.12-slim AS base

WORKDIR /app
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1

# Install uv
RUN pip install uv

# Copy dependency files
COPY pyproject.toml uv.lock ./

# Install dependencies (production only)
RUN uv sync --frozen --no-dev

# Copy application code
COPY app ./app
COPY alembic ./alembic
COPY alembic.ini ./

# Run with uvicorn
CMD ["uv", "run", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]
```
  </action>
  <verify>
- cd backend && uv run alembic --help shows alembic commands
- uv run alembic revision --autogenerate -m "initial" creates migration (requires DB running)
- docker build -t holmes-backend . succeeds in backend directory
  </verify>
  <done>
Alembic configured for async migrations and Dockerfile ready for production deployment.
  </done>
</task>

</tasks>

<verification>
1. Server starts: `cd backend && uv run uvicorn app.main:app --port 8080`
2. Health check: `curl http://localhost:8080/health` returns 200
3. DB health (with docker compose up): `curl http://localhost:8080/health/db` returns connected
4. Storage health (on GCP or with credentials): `curl http://localhost:8080/health/storage` returns accessible
5. SSE streaming: `curl -N http://localhost:8080/sse/heartbeat` shows heartbeat events
6. Alembic works: `cd backend && uv run alembic current` runs without error
7. Docker builds: `cd backend && docker build -t holmes-backend .` succeeds
</verification>

<success_criteria>
- FastAPI server starts and responds to requests
- /health returns {"status": "healthy"} with 200
- /health/db verifies database connection when PostgreSQL is running
- /health/storage verifies GCS bucket is accessible from backend (phase exit criteria: "GCS bucket accessible from backend")
- /sse/heartbeat streams events with proper headers
- Alembic initialized with async configuration
- Dockerfile builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`
</output>
