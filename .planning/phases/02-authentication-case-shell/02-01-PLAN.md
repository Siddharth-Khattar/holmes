---
phase: 02-authentication-case-shell
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/auth.py
  - backend/app/models/case.py
  - backend/app/models/__init__.py
  - backend/app/api/auth.py
  - backend/app/main.py
  - backend/alembic/versions/XXXXXX_add_auth_case_tables.py
  - backend/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "FastAPI can validate Better Auth JWTs from Authorization header"
    - "Database has user, session, account, verification, jwks tables"
    - "Database has cases table with user_id foreign key"
    - "Unauthenticated requests to protected endpoints return 401"
  artifacts:
    - path: "backend/app/models/auth.py"
      provides: "SQLAlchemy models for Better Auth tables (read-only)"
      contains: "class User"
    - path: "backend/app/models/case.py"
      provides: "Case model with status enum and user relationship"
      contains: "class Case"
    - path: "backend/app/api/auth.py"
      provides: "get_current_user dependency for JWT validation via JWKS"
      exports: ["get_current_user", "CurrentUser"]
    - path: "backend/alembic/versions"
      provides: "Migration for auth and case tables"
  key_links:
    - from: "backend/app/api/auth.py"
      to: "backend/app/models/auth.py"
      via: "Session and User model imports"
      pattern: "from app.models.auth import"
    - from: "backend/app/api/auth.py"
      to: "frontend JWKS endpoint"
      via: "PyJWKClient fetches /api/auth/jwks"
      pattern: "PyJWKClient"
---

<objective>
Set up backend authentication infrastructure for Better Auth JWT validation and case model.

Purpose: FastAPI needs to validate JWTs issued by Better Auth in Next.js. Uses stateless JWT verification via JWKS endpoint for cross-origin compatibility (frontend and backend on different Cloud Run URLs).
Output: Database models for auth tables (read-only), Case model, JWT validation dependency, and Alembic migration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-case-shell/02-CONTEXT.md
@.planning/phases/02-authentication-case-shell/02-RESEARCH.md
@backend/app/database.py
@backend/app/models/base.py
@backend/app/config.py
@backend/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth models and JWT validation dependency</name>
  <files>
    backend/app/models/auth.py
    backend/app/api/auth.py
    backend/app/models/__init__.py
    backend/pyproject.toml
  </files>
  <action>
1. Add PyJWT and cryptography to pyproject.toml dependencies:
   ```
   "PyJWT>=2.10.0",
   "cryptography>=43.0.0",
   ```

2. Create `backend/app/models/auth.py` with SQLAlchemy models matching Better Auth schema (READ-ONLY, these tables are managed by Better Auth):
   - User: id (TEXT PK), name, email (UNIQUE), email_verified, image, created_at, updated_at
   - Session: id (TEXT PK), user_id (FK), token (UNIQUE), expires_at, ip_address, user_agent, created_at, updated_at
   - Account: id (TEXT PK), user_id (FK), account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at
   - Verification: id (TEXT PK), identifier, value, expires_at, created_at, updated_at
   - Jwks: id (TEXT PK), public_key, private_key, created_at

   Notes:
   - Use `mapped_column(String)` for TEXT columns
   - All tables have `__tablename__` matching Better Auth defaults (lowercase: user, session, account, verification, jwks)
   - Mark with docstring: "Read-only models for Better Auth tables"

3. Create `backend/app/api/auth.py` with JWT validation via JWKS:
   ```python
   # ABOUTME: JWT authentication dependency for FastAPI endpoints.
   # ABOUTME: Validates Better Auth JWTs via JWKS endpoint for cross-origin auth.

   from typing import Annotated
   import jwt
   from jwt import PyJWKClient
   from fastapi import Depends, HTTPException, Request, status
   from sqlalchemy import select
   from sqlalchemy.ext.asyncio import AsyncSession

   from app.config import settings
   from app.database import get_db
   from app.models.auth import User

   # Cache JWKS client - fetches public keys from Better Auth
   _jwks_client: PyJWKClient | None = None

   def get_jwks_client() -> PyJWKClient:
       """Get or create cached JWKS client."""
       global _jwks_client
       if _jwks_client is None:
           _jwks_client = PyJWKClient(
               f"{settings.frontend_url}/api/auth/jwks",
               cache_keys=True,
           )
       return _jwks_client

   async def get_current_user(
       request: Request,
       db: Annotated[AsyncSession, Depends(get_db)],
   ) -> User:
       """Validate JWT from Authorization header and return current user."""
       auth_header = request.headers.get("Authorization")

       if not auth_header or not auth_header.startswith("Bearer "):
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail="Missing or invalid authorization header",
               headers={"WWW-Authenticate": "Bearer"},
           )

       token = auth_header.split(" ", 1)[1]

       try:
           jwks_client = get_jwks_client()
           signing_key = jwks_client.get_signing_key_from_jwt(token)
           payload = jwt.decode(
               token,
               signing_key.key,
               algorithms=["EdDSA", "ES256", "RS256"],  # Better Auth supports multiple
               audience=settings.frontend_url,
               issuer=settings.frontend_url,
           )
       except jwt.exceptions.InvalidTokenError as e:
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail=f"Invalid token: {e}",
               headers={"WWW-Authenticate": "Bearer"},
           )

       user_id = payload.get("sub")
       if not user_id:
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail="Token missing subject claim",
           )

       # Get user from database
       result = await db.execute(select(User).where(User.id == user_id))
       user = result.scalar_one_or_none()

       if not user:
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail="User not found",
           )

       return user

   # Type alias for dependency injection
   CurrentUser = Annotated[User, Depends(get_current_user)]
   ```

4. Update `backend/app/models/__init__.py` to export all models:
   ```python
   from app.models.auth import User, Session, Account, Verification, Jwks
   __all__ = ["Base", "User", "Session", "Account", "Verification", "Jwks"]
   ```
  </action>
  <verify>
    cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && uv sync && python -c "from app.models import User, Session; from app.api.auth import get_current_user, CurrentUser; print('Models and auth imported successfully')"
  </verify>
  <done>Auth models and JWT validation dependency exist and import without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Case model and database migration</name>
  <files>
    backend/app/models/case.py
    backend/app/models/__init__.py
    backend/alembic/versions/XXXXXX_add_auth_case_tables.py
  </files>
  <action>
1. Create `backend/app/models/case.py`:
   - CaseStatus enum: DRAFT, PROCESSING, READY, ERROR (using Python enum.Enum and SQLAlchemy Enum type)
   - CaseType enum: FRAUD, CORPORATE, CIVIL, CRIMINAL, OTHER
   - Case model:
     - id: UUID (gen_random_uuid default)
     - user_id: String (FK to "user".id, NOT NULL, ON DELETE CASCADE)
     - name: String(100) NOT NULL
     - description: Text (optional)
     - type: CaseType (default OTHER)
     - status: CaseStatus (default DRAFT)
     - file_count: Integer (default 0)
     - created_at: DateTime with timezone (default now)
     - updated_at: DateTime with timezone (default now, onupdate=now)
     - deleted_at: DateTime with timezone (nullable, for soft delete)

   Add relationship to User: `user = relationship("User", back_populates=None)` (no backref since User is read-only)

   Add indexes:
   - idx_cases_user_id on user_id
   - Partial index on deleted_at WHERE deleted_at IS NULL (for active cases query)

2. Update `backend/app/models/__init__.py` to include Case:
   ```python
   from app.models.case import Case, CaseStatus, CaseType
   __all__ = [..., "Case", "CaseStatus", "CaseType"]
   ```

3. Generate Alembic migration:
   ```bash
   cd backend && alembic revision --autogenerate -m "add auth and case tables"
   ```

   Review the generated migration and ensure:
   - Auth tables (user, session, account, verification, jwks) are created
   - cases table is created with proper foreign key to user
   - Enum types are created (case_status, case_type)
   - Indexes are included

   Note: DO NOT apply the migration yet. Better Auth will manage auth tables; we need to coordinate with frontend setup. The migration is for schema documentation and for cases table only in practice.
  </action>
  <verify>
    cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "from app.models import Case, CaseStatus, CaseType; print(f'Case model ready with status: {list(CaseStatus)}')"
  </verify>
  <done>Case model created with status/type enums, migration generated (not applied)</done>
</task>

<task type="auto">
  <name>Task 3: Register auth router and add settings</name>
  <files>
    backend/app/main.py
    backend/app/config.py
  </files>
  <action>
1. Update `backend/app/config.py` to add frontend URL setting:
   ```python
   frontend_url: str = "http://localhost:3000"  # For JWKS endpoint
   ```

2. Create a simple test endpoint in `backend/app/api/auth.py` to verify auth works:
   ```python
   from fastapi import APIRouter

   router = APIRouter(prefix="/api/auth", tags=["auth"])

   @router.get("/me")
   async def get_me(current_user: CurrentUser) -> dict:
       """Return current authenticated user info."""
       return {
           "id": current_user.id,
           "name": current_user.name,
           "email": current_user.email,
           "image": current_user.image,
       }
   ```

3. Update `backend/app/main.py` to include auth router:
   ```python
   from app.api import auth
   app.include_router(auth.router, tags=["auth"])
   ```
  </action>
  <verify>
    cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && ruff check app/ && python -c "from app.main import app; print('App configured with auth router')"
  </verify>
  <done>Auth router registered, /api/auth/me endpoint ready to test authenticated requests</done>
</task>

</tasks>

<verification>
1. All imports work: `python -c "from app.models import User, Session, Case; from app.api.auth import CurrentUser"`
2. Ruff passes: `ruff check app/`
3. Migration file exists in alembic/versions/
4. FastAPI app includes auth router
5. JWT validation uses PyJWKClient pointing to frontend JWKS endpoint
</verification>

<success_criteria>
- SQLAlchemy models exist for User, Session, Account, Verification, Jwks (read-only)
- Case model exists with proper enums and user foreign key
- get_current_user dependency validates JWTs from Authorization header via JWKS
- PyJWKClient configured to fetch keys from {frontend_url}/api/auth/jwks
- Alembic migration generated (not applied - frontend needs to init Better Auth first)
- /api/auth/me endpoint exists for testing auth
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-case-shell/02-01-SUMMARY.md`
</output>
