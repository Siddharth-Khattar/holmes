---
phase: 02-authentication-case-shell
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/auth.py
  - backend/app/models/case.py
  - backend/app/models/__init__.py
  - backend/app/api/auth.py
  - backend/app/main.py
  - backend/alembic/versions/XXXXXX_add_cases_table.py
  - backend/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "FastAPI can validate Better Auth JWTs from Authorization header"
    - "Backend can query User table created by Better Auth"
    - "Cases table exists with user_id foreign key to user table"
    - "Unauthenticated requests to protected endpoints return 401"
  artifacts:
    - path: "backend/app/models/auth.py"
      provides: "SQLAlchemy models for Better Auth tables (read-only)"
      contains: "class User"
    - path: "backend/app/models/case.py"
      provides: "Case model with status enum and user relationship"
      contains: "class Case"
    - path: "backend/app/api/auth.py"
      provides: "get_current_user dependency for JWT validation via JWKS"
      exports: ["get_current_user", "CurrentUser"]
    - path: "backend/alembic/versions"
      provides: "Migration for cases table only"
  key_links:
    - from: "backend/app/api/auth.py"
      to: "backend/app/models/auth.py"
      via: "Session and User model imports"
      pattern: "from app.models.auth import"
    - from: "backend/app/api/auth.py"
      to: "frontend JWKS endpoint"
      via: "PyJWKClient fetches /api/auth/jwks"
      pattern: "PyJWKClient"
---

<objective>
Set up backend authentication infrastructure for Better Auth JWT validation and case model.

Purpose: FastAPI needs to validate JWTs issued by Better Auth in Next.js. Uses stateless JWT verification via JWKS endpoint for cross-origin compatibility (frontend and backend on different Cloud Run URLs).
Output: Database models for auth tables (read-only), Case model, JWT validation dependency, and Alembic migration for cases table only.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-case-shell/02-CONTEXT.md
@.planning/phases/02-authentication-case-shell/02-RESEARCH.md
@backend/app/database.py
@backend/app/models/base.py
@backend/app/config.py
@backend/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth models and JWT validation dependency</name>
  <files>
    backend/app/models/auth.py
    backend/app/api/auth.py
    backend/app/models/__init__.py
    backend/pyproject.toml
  </files>
  <action>
1. Add PyJWT and cryptography to pyproject.toml dependencies:
   ```
   "PyJWT>=2.10.0",
   "cryptography>=43.0.0",
   ```

2. Create `backend/app/models/auth.py` with SQLAlchemy models matching Better Auth schema (READ-ONLY, these tables are managed by Better Auth):
   - User: id (TEXT PK), name, email (UNIQUE), email_verified, image, created_at, updated_at
   - Session: id (TEXT PK), user_id (FK), token (UNIQUE), expires_at, ip_address, user_agent, created_at, updated_at
   - Account: id (TEXT PK), user_id (FK), account_id, provider_id, access_token, refresh_token, access_token_expires_at, refresh_token_expires_at, scope, id_token, password, created_at, updated_at
   - Verification: id (TEXT PK), identifier, value, expires_at, created_at, updated_at
   - Jwks: id (TEXT PK), public_key, private_key, created_at

   Notes:
   - Use `mapped_column(String)` for TEXT columns
   - All tables have `__tablename__` matching Better Auth defaults (lowercase: user, session, account, verification, jwks)
   - Mark with docstring: "Read-only models for Better Auth tables - DO NOT create migrations for these"
   - IMPORTANT: Set `__table_args__ = {'extend_existing': True}` to avoid conflicts if Better Auth already created tables

3. Create `backend/app/api/auth.py` with JWT validation via JWKS:
   ```python
   # ABOUTME: JWT authentication dependency for FastAPI endpoints.
   # ABOUTME: Validates Better Auth JWTs via JWKS endpoint for cross-origin auth.

   from typing import Annotated
   import jwt
   from jwt import PyJWKClient
   from fastapi import Depends, HTTPException, Request, status
   from sqlalchemy import select
   from sqlalchemy.ext.asyncio import AsyncSession

   from app.config import settings
   from app.database import get_db
   from app.models.auth import User

   # Cache JWKS client - fetches public keys from Better Auth
   _jwks_client: PyJWKClient | None = None

   def get_jwks_client() -> PyJWKClient:
       """Get or create cached JWKS client."""
       global _jwks_client
       if _jwks_client is None:
           _jwks_client = PyJWKClient(
               f"{settings.frontend_url}/api/auth/jwks",
               cache_keys=True,
           )
       return _jwks_client

   async def get_current_user(
       request: Request,
       db: Annotated[AsyncSession, Depends(get_db)],
   ) -> User:
       """Validate JWT from Authorization header and return current user."""
       auth_header = request.headers.get("Authorization")

       if not auth_header or not auth_header.startswith("Bearer "):
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail="Missing or invalid authorization header",
               headers={"WWW-Authenticate": "Bearer"},
           )

       token = auth_header.split(" ", 1)[1]

       try:
           jwks_client = get_jwks_client()
           signing_key = jwks_client.get_signing_key_from_jwt(token)
           payload = jwt.decode(
               token,
               signing_key.key,
               algorithms=["EdDSA", "ES256", "RS256"],  # Better Auth supports multiple
               audience=settings.frontend_url,
               issuer=settings.frontend_url,
           )
       except jwt.exceptions.InvalidTokenError as e:
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail=f"Invalid token: {e}",
               headers={"WWW-Authenticate": "Bearer"},
           )

       user_id = payload.get("sub")
       if not user_id:
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail="Token missing subject claim",
           )

       # Get user from database
       result = await db.execute(select(User).where(User.id == user_id))
       user = result.scalar_one_or_none()

       if not user:
           raise HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail="User not found",
           )

       return user

   # Type alias for dependency injection
   CurrentUser = Annotated[User, Depends(get_current_user)]
   ```

4. Update `backend/app/models/__init__.py` to export all models:
   ```python
   from app.models.auth import User, Session, Account, Verification, Jwks
   __all__ = ["Base", "User", "Session", "Account", "Verification", "Jwks"]
   ```
  </action>
  <verify>
    cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && uv sync && python -c "from app.models import User, Session; from app.api.auth import get_current_user, CurrentUser; print('Models and auth imported successfully')"
  </verify>
  <done>Auth models and JWT validation dependency exist and import without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Case model and database migration (cases table ONLY)</name>
  <files>
    backend/app/models/case.py
    backend/app/models/__init__.py
    backend/alembic/versions/XXXXXX_add_cases_table.py
  </files>
  <action>
IMPORTANT: Better Auth automatically creates its own tables (user, session, account, verification, jwks) when the frontend starts. The Alembic migration must ONLY create the `cases` table. DO NOT include auth tables in the migration.

1. Create `backend/app/models/case.py`:
   - CaseStatus enum: DRAFT, PROCESSING, READY, ERROR (using Python enum.Enum and SQLAlchemy Enum type)
   - CaseType enum: FRAUD, CORPORATE, CIVIL, CRIMINAL, OTHER
   - Case model:
     - id: UUID (gen_random_uuid default)
     - user_id: String (FK to "user".id, NOT NULL, ON DELETE CASCADE)
     - name: String(100) NOT NULL
     - description: Text (optional)
     - type: CaseType (default OTHER)
     - status: CaseStatus (default DRAFT)
     - file_count: Integer (default 0)
     - created_at: DateTime with timezone (default now)
     - updated_at: DateTime with timezone (default now, onupdate=now)
     - deleted_at: DateTime with timezone (nullable, for soft delete)

   Add relationship to User: `user = relationship("User", back_populates=None)` (no backref since User is read-only)

   Add indexes:
   - idx_cases_user_id on user_id
   - Partial index on deleted_at WHERE deleted_at IS NULL (for active cases query)

2. Update `backend/app/models/__init__.py` to include Case:
   ```python
   from app.models.case import Case, CaseStatus, CaseType
   __all__ = [..., "Case", "CaseStatus", "CaseType"]
   ```

3. Create a MANUAL Alembic migration (do NOT use autogenerate to avoid including auth tables):
   ```bash
   cd backend && alembic revision -m "add cases table"
   ```

   Then edit the generated migration file to create ONLY the cases table:

   ```python
   """add cases table

   Revision ID: <generated>
   Revises: <previous or None>
   Create Date: <generated>
   """
   from typing import Sequence, Union
   from alembic import op
   import sqlalchemy as sa
   from sqlalchemy.dialects import postgresql

   # revision identifiers, used by Alembic.
   revision: str = '<generated>'
   down_revision: Union[str, None] = None
   branch_labels: Union[str, Sequence[str], None] = None
   depends_on: Union[str, Sequence[str], None] = None


   def upgrade() -> None:
       # Create enum types
       case_status = postgresql.ENUM('DRAFT', 'PROCESSING', 'READY', 'ERROR', name='casestatus', create_type=False)
       case_type = postgresql.ENUM('FRAUD', 'CORPORATE', 'CIVIL', 'CRIMINAL', 'OTHER', name='casetype', create_type=False)

       # Create enums if they don't exist
       case_status.create(op.get_bind(), checkfirst=True)
       case_type.create(op.get_bind(), checkfirst=True)

       # Create cases table
       # NOTE: This assumes Better Auth has already created the 'user' table.
       # Run frontend first to initialize Better Auth tables before running this migration.
       op.create_table(
           'cases',
           sa.Column('id', postgresql.UUID(as_uuid=True), server_default=sa.text('gen_random_uuid()'), nullable=False),
           sa.Column('user_id', sa.String(), nullable=False),
           sa.Column('name', sa.String(100), nullable=False),
           sa.Column('description', sa.Text(), nullable=True),
           sa.Column('type', case_type, server_default='OTHER', nullable=False),
           sa.Column('status', case_status, server_default='DRAFT', nullable=False),
           sa.Column('file_count', sa.Integer(), server_default='0', nullable=False),
           sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
           sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
           sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True),
           sa.PrimaryKeyConstraint('id'),
           sa.ForeignKeyConstraint(['user_id'], ['user.id'], ondelete='CASCADE'),
       )

       # Create indexes
       op.create_index('idx_cases_user_id', 'cases', ['user_id'])
       op.create_index('idx_cases_active', 'cases', ['deleted_at'], postgresql_where=sa.text('deleted_at IS NULL'))


   def downgrade() -> None:
       op.drop_index('idx_cases_active', table_name='cases')
       op.drop_index('idx_cases_user_id', table_name='cases')
       op.drop_table('cases')

       # Drop enum types
       op.execute('DROP TYPE IF EXISTS casestatus')
       op.execute('DROP TYPE IF EXISTS casetype')
   ```

   CRITICAL: Do NOT use `alembic revision --autogenerate` as it will try to include auth tables. Use manual migration.
  </action>
  <verify>
    cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "from app.models import Case, CaseStatus, CaseType; print(f'Case model ready with status: {list(CaseStatus)}')"
    # Also verify migration only creates cases table:
    # grep -L "user\|session\|account\|verification\|jwks" alembic/versions/*_add_cases_table.py || echo "Auth tables found - remove them!"
  </verify>
  <done>Case model created with status/type enums, migration generated for cases table ONLY (auth tables managed by Better Auth)</done>
</task>

<task type="auto">
  <name>Task 3: Register auth router and add settings</name>
  <files>
    backend/app/main.py
    backend/app/config.py
  </files>
  <action>
1. Update `backend/app/config.py` to add frontend URL setting:
   ```python
   frontend_url: str = "http://localhost:3000"  # For JWKS endpoint
   ```

2. Create a simple test endpoint in `backend/app/api/auth.py` to verify auth works:
   ```python
   from fastapi import APIRouter

   router = APIRouter(prefix="/api/auth", tags=["auth"])

   @router.get("/me")
   async def get_me(current_user: CurrentUser) -> dict:
       """Return current authenticated user info."""
       return {
           "id": current_user.id,
           "name": current_user.name,
           "email": current_user.email,
           "image": current_user.image,
       }
   ```

3. Update `backend/app/main.py` to include auth router:
   ```python
   from app.api import auth
   app.include_router(auth.router, tags=["auth"])
   ```
  </action>
  <verify>
    cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && ruff check app/ && python -c "from app.main import app; print('App configured with auth router')"
  </verify>
  <done>Auth router registered, /api/auth/me endpoint ready to test authenticated requests</done>
</task>

</tasks>

<verification>
1. All imports work: `python -c "from app.models import User, Session, Case; from app.api.auth import CurrentUser"`
2. Ruff passes: `ruff check app/`
3. Migration file exists in alembic/versions/ and ONLY creates cases table (not auth tables)
4. FastAPI app includes auth router
5. JWT validation uses PyJWKClient pointing to frontend JWKS endpoint
</verification>

<success_criteria>
- SQLAlchemy models exist for User, Session, Account, Verification, Jwks (read-only, no migrations)
- Case model exists with proper enums and user foreign key
- get_current_user dependency validates JWTs from Authorization header via JWKS
- PyJWKClient configured to fetch keys from {frontend_url}/api/auth/jwks
- Alembic migration creates cases table ONLY (Better Auth manages its own tables)
- /api/auth/me endpoint exists for testing auth
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-case-shell/02-01-SUMMARY.md`
</output>
