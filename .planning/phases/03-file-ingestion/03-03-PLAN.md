---
phase: 03-file-ingestion
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - backend/app/api/files.py
  - backend/app/api/sse.py
  - frontend/src/components/library/CaseLibrary.tsx
  - frontend/src/lib/api/files.ts
  - frontend/src/hooks/useFileUpload.ts
autonomous: true

must_haves:
  truths:
    - "User can list files in a case via GET /api/cases/{case_id}/files"
    - "User can download files via signed URL from GET /api/cases/{case_id}/files/{file_id}/download"
    - "User can delete files via DELETE /api/cases/{case_id}/files/{file_id}"
    - "SSE endpoint streams file status updates"
    - "Frontend CaseLibrary fetches real files instead of mock data"
    - "Frontend handlers call real API endpoints"
  artifacts:
    - path: "backend/app/api/files.py"
      provides: "List, download, delete endpoints"
      contains: "async def list_files"
    - path: "backend/app/api/sse.py"
      provides: "File status SSE endpoint"
      contains: "file_status_generator"
    - path: "frontend/src/lib/api/files.ts"
      provides: "API client for file operations"
      contains: "export async function uploadFile"
    - path: "frontend/src/components/library/CaseLibrary.tsx"
      provides: "Connected library using real API"
      contains: "useFileUpload"
  key_links:
    - from: "frontend/src/components/library/CaseLibrary.tsx"
      to: "frontend/src/lib/api/files.ts"
      via: "API client import"
      pattern: "from.*lib/api/files"
    - from: "frontend/src/lib/api/files.ts"
      to: "/api/cases/{case_id}/files"
      via: "fetch calls"
      pattern: "fetch.*api/cases"
---

<objective>
Complete file management APIs and integrate frontend with backend.

Purpose: Deliver the full file management experience - users can upload, list, download, and delete files with real-time status updates. Connect the existing CaseLibrary.tsx UI to the backend APIs.

Output: Complete file CRUD APIs, SSE for status updates, frontend integrated with real backend calls.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-file-ingestion/03-CONTEXT.md
@.planning/phases/03-file-ingestion/03-RESEARCH.md
@.planning/phases/03-file-ingestion/03-01-SUMMARY.md
@.planning/phases/03-file-ingestion/03-02-SUMMARY.md
@frontend/src/components/library/CaseLibrary.tsx
@backend/app/api/sse.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add list, download, delete endpoints to files router</name>
  <files>backend/app/api/files.py</files>
  <action>
Extend `backend/app/api/files.py` with remaining CRUD endpoints:

1. **Helper function get_user_file(db, case_id, file_id, user_id)**:
   - Join CaseFile with Case
   - Ensure case.user_id matches and case.deleted_at is None
   - Return CaseFile or None

2. **GET /api/cases/{case_id}/files** - List files:
   ```python
   @router.get("", response_model=FileListResponse)
   async def list_files(
       case_id: UUID,
       current_user: CurrentUser,
       db: AsyncSession,
       page: int = Query(1, ge=1),
       per_page: int = Query(20, ge=1, le=100),
       status: FileStatus | None = Query(None),
       category: FileCategory | None = Query(None),
   ):
   ```
   - Validate case ownership
   - Query CaseFiles with optional status/category filters
   - Order by created_at desc
   - Return paginated response

3. **GET /api/cases/{case_id}/files/{file_id}/download** - Get signed URL:
   ```python
   @router.get("/{file_id}/download", response_model=DownloadUrlResponse)
   async def get_download_url(case_id: UUID, file_id: UUID, current_user, db):
   ```
   - Validate file ownership via get_user_file
   - Get bucket, generate V4 signed URL with 24h expiration
   - Set response_disposition for original filename
   - Return {download_url, expires_in: 86400}

4. **DELETE /api/cases/{case_id}/files/{file_id}** - Hard delete:
   ```python
   @router.delete("/{file_id}", status_code=204)
   async def delete_file(case_id: UUID, file_id: UUID, current_user, db):
   ```
   - Validate file ownership
   - Delete from GCS using delete_from_gcs service
   - Delete database record
   - Decrement case.file_count
   - Return 204 No Content

Error handling:
- 404 if case or file not found
- Log GCS errors but proceed with DB delete if GCS fails (orphan cleanup can happen later)
  </action>
  <verify>
```bash
cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend
source .venv/bin/activate

# Check all endpoints exist
python -c "
from app.api.files import router
paths = [r.path for r in router.routes]
print('Registered paths:', paths)
assert '' in paths, 'List endpoint missing'
assert '/{file_id}/download' in paths, 'Download endpoint missing'
assert '/{file_id}' in paths, 'Delete endpoint missing'
print('All endpoints present')
"

# Lint
ruff check app/api/files.py
```
  </verify>
  <done>List, download, delete endpoints exist in files router with proper error handling</done>
</task>

<task type="auto">
  <name>Task 2: Add file status SSE endpoint</name>
  <files>backend/app/api/sse.py</files>
  <action>
Extend `backend/app/api/sse.py` with file status streaming:

1. **Add in-memory pubsub** (simple dict-based for single instance):
   ```python
   from collections import defaultdict
   import json

   # Case ID -> list of subscriber queues
   _file_subscribers: dict[str, list[asyncio.Queue]] = defaultdict(list)
   ```

2. **Add publish function**:
   ```python
   async def publish_file_event(case_id: str, event_type: str, data: dict):
       """Publish file event to all subscribers for a case."""
       event = {"event": event_type, "data": json.dumps(data)}
       for queue in _file_subscribers.get(case_id, []):
           await queue.put(event)
   ```

3. **Add SSE endpoint**:
   ```python
   @router.get("/sse/cases/{case_id}/files")
   async def file_status_stream(case_id: str):
       """SSE endpoint for file status updates."""
       async def event_generator():
           queue = asyncio.Queue()
           _file_subscribers[case_id].append(queue)
           try:
               while True:
                   # Check for events or send heartbeat
                   try:
                       event = await asyncio.wait_for(queue.get(), timeout=15.0)
                       yield event
                   except asyncio.TimeoutError:
                       yield {"event": "heartbeat", "data": "ping"}
           finally:
               _file_subscribers[case_id].remove(queue)

       return EventSourceResponse(
           event_generator(),
           headers={"X-Accel-Buffering": "no", "Cache-Control": "no-cache"},
       )
   ```

4. **Update upload endpoint** in files.py to publish event after successful upload:
   ```python
   from app.api.sse import publish_file_event

   # After db.commit() in upload_file:
   await publish_file_event(str(case_id), "file-uploaded", {
       "file_id": str(case_file.id),
       "filename": case_file.original_filename,
       "status": case_file.status.value,
       "duplicate_of": str(duplicate.id) if duplicate else None,
   })
   ```

5. **Update delete endpoint** to publish event:
   ```python
   await publish_file_event(str(case_id), "file-deleted", {
       "file_id": str(file_id),
   })
   ```

Event types: file-uploaded, file-status, file-deleted, file-error
  </action>
  <verify>
```bash
cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend
source .venv/bin/activate

# Check SSE endpoint exists
python -c "
from app.api.sse import router, publish_file_event
print('SSE functions importable')
"

# Lint
ruff check app/api/sse.py
```
  </verify>
  <done>SSE endpoint exists at /sse/cases/{case_id}/files, publish_file_event function available</done>
</task>

<task type="auto">
  <name>Task 3: Create frontend API client and integrate CaseLibrary</name>
  <files>frontend/src/lib/api/files.ts, frontend/src/hooks/useFileUpload.ts, frontend/src/components/library/CaseLibrary.tsx</files>
  <action>
**Create frontend/src/lib/api/files.ts** - API client:

```typescript
// ABOUTME: API client for file operations - upload, list, download, delete.
// ABOUTME: Handles multipart upload and signed URL retrieval.

import { authClient } from "@/lib/auth-client";

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

export interface FileResponse {
  id: string;
  case_id: string;
  name: string;
  original_filename: string;
  mime_type: string;
  size_bytes: number;
  category: "DOCUMENT" | "IMAGE" | "VIDEO" | "AUDIO";
  status: "UPLOADING" | "UPLOADED" | "QUEUED" | "PROCESSING" | "ANALYZED" | "ERROR";
  content_hash: string;
  description: string | null;
  error_message: string | null;
  created_at: string;
  updated_at: string;
  duplicate_of: string | null;
}

export interface FileListResponse {
  files: FileResponse[];
  total: number;
  page: number;
  per_page: number;
}

async function getAuthHeaders(): Promise<HeadersInit> {
  const session = await authClient.getSession();
  if (!session?.data?.session?.token) {
    throw new Error("Not authenticated");
  }
  return {
    Authorization: `Bearer ${session.data.session.token}`,
  };
}

export async function listFiles(caseId: string, page = 1, perPage = 50): Promise<FileListResponse> {
  const headers = await getAuthHeaders();
  const res = await fetch(
    `${API_URL}/api/cases/${caseId}/files?page=${page}&per_page=${perPage}`,
    { headers }
  );
  if (!res.ok) throw new Error("Failed to list files");
  return res.json();
}

export async function uploadFile(
  caseId: string,
  file: File,
  description?: string
): Promise<FileResponse> {
  const headers = await getAuthHeaders();
  const formData = new FormData();
  formData.append("file", file);
  if (description) formData.append("description", description);

  const res = await fetch(`${API_URL}/api/cases/${caseId}/files`, {
    method: "POST",
    headers,  // Note: Don't set Content-Type, let browser set it with boundary
    body: formData,
  });
  if (!res.ok) {
    const error = await res.json().catch(() => ({ detail: "Upload failed" }));
    throw new Error(error.detail || "Upload failed");
  }
  return res.json();
}

export async function getDownloadUrl(caseId: string, fileId: string): Promise<string> {
  const headers = await getAuthHeaders();
  const res = await fetch(`${API_URL}/api/cases/${caseId}/files/${fileId}/download`, { headers });
  if (!res.ok) throw new Error("Failed to get download URL");
  const data = await res.json();
  return data.download_url;
}

export async function deleteFile(caseId: string, fileId: string): Promise<void> {
  const headers = await getAuthHeaders();
  const res = await fetch(`${API_URL}/api/cases/${caseId}/files/${fileId}`, {
    method: "DELETE",
    headers,
  });
  if (!res.ok) throw new Error("Failed to delete file");
}
```

**Create frontend/src/hooks/useFileUpload.ts** - Upload hook:

```typescript
// ABOUTME: React hook for file upload with status tracking.
// ABOUTME: Handles sequential uploads and integrates with CaseLibrary.

import { useState, useCallback } from "react";
import { uploadFile, FileResponse } from "@/lib/api/files";

interface UploadState {
  isUploading: boolean;
  currentFile: string | null;
  error: string | null;
}

export function useFileUpload(caseId: string) {
  const [state, setState] = useState<UploadState>({
    isUploading: false,
    currentFile: null,
    error: null,
  });

  const upload = useCallback(async (files: File[]): Promise<FileResponse[]> => {
    const results: FileResponse[] = [];

    for (const file of files) {
      setState({ isUploading: true, currentFile: file.name, error: null });
      try {
        const result = await uploadFile(caseId, file);
        results.push(result);
      } catch (err) {
        setState(s => ({ ...s, error: err instanceof Error ? err.message : "Upload failed" }));
        // Continue with next file per CONTEXT.md (sequential, show error after all retries)
      }
    }

    setState({ isUploading: false, currentFile: null, error: null });
    return results;
  }, [caseId]);

  return { ...state, upload };
}
```

**Update frontend/src/components/library/CaseLibrary.tsx**:

1. Import API functions and hook:
   ```typescript
   import { listFiles, getDownloadUrl, deleteFile, FileResponse } from "@/lib/api/files";
   import { useFileUpload } from "@/hooks/useFileUpload";
   ```

2. Replace mock data with real data fetching:
   - Add `useEffect` to fetch files on mount: `listFiles(caseId).then(res => setFiles(mapToLibraryFiles(res.files)))`
   - Add mapping function to convert backend FileResponse to frontend LibraryFile format

3. Implement handlers:
   ```typescript
   const { isUploading, currentFile, error, upload } = useFileUpload(caseId);

   const handleDrop = useCallback(async (e: React.DragEvent) => {
     e.preventDefault();
     setIsDragging(false);
     const droppedFiles = Array.from(e.dataTransfer.files);
     if (droppedFiles.length > 0) {
       await upload(droppedFiles);
       // Refresh file list
       const res = await listFiles(caseId);
       setFiles(mapToLibraryFiles(res.files));
     }
   }, [caseId, upload]);

   const handleDownloadFile = useCallback(async (file: LibraryFile) => {
     const url = await getDownloadUrl(caseId, file.id);
     window.open(url, "_blank");
   }, [caseId]);

   const handleDeleteFile = useCallback(async (file: LibraryFile) => {
     if (confirm(`Delete ${file.name}?`)) {
       await deleteFile(caseId, file.id);
       setFiles(prev => prev.filter(f => f.id !== file.id));
     }
   }, [caseId]);
   ```

4. Add loading and error states to UI

5. Map backend status to frontend status:
   ```typescript
   function mapStatus(backendStatus: string): FileStatus {
     switch (backendStatus) {
       case "UPLOADING": case "QUEUED": case "PROCESSING": return "processing";
       case "UPLOADED": case "ANALYZED": return "ready";
       case "ERROR": return "error";
       default: return "ready";
     }
   }
   ```
  </action>
  <verify>
```bash
cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend

# Type check
bun run typecheck 2>&1 | head -30

# Check files exist
ls -la src/lib/api/files.ts src/hooks/useFileUpload.ts

# Check CaseLibrary imports
grep -n "from.*lib/api/files" src/components/library/CaseLibrary.tsx
```
  </verify>
  <done>Frontend API client created, useFileUpload hook implemented, CaseLibrary connected to real APIs</done>
</task>

</tasks>

<verification>
```bash
# Backend verification
cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend
source .venv/bin/activate
ruff check app/api/files.py app/api/sse.py
python -m py_compile app/api/files.py
python -m py_compile app/api/sse.py

# Frontend verification
cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend
bun run typecheck
bun run lint
```
</verification>

<success_criteria>
- GET /api/cases/{case_id}/files returns paginated file list
- GET /api/cases/{case_id}/files/{file_id}/download returns signed URL with 24h expiry
- DELETE /api/cases/{case_id}/files/{file_id} removes file from GCS and database
- SSE endpoint at /sse/cases/{case_id}/files streams file events
- Frontend CaseLibrary.tsx fetches real files on mount
- handleDrop calls uploadFile API and refreshes list
- handleDownloadFile opens signed URL in new tab
- handleDeleteFile calls delete API and removes from local state
- All files pass type checking and linting
</success_criteria>

<output>
After completion, create `.planning/phases/03-file-ingestion/03-03-SUMMARY.md`
</output>
