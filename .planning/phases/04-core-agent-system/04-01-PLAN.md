---
phase: 04-core-agent-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/pyproject.toml
  - backend/app/config.py
  - backend/app/services/adk_service.py
  - backend/app/agents/__init__.py
  - backend/app/agents/base.py
  - backend/app/agents/factory.py
autonomous: true

must_haves:
  truths:
    - "ADK Runner can be instantiated with PostgreSQL session service"
    - "GcsArtifactService connects to existing artifacts bucket"
    - "Agent factory creates fresh agent instances without single-parent violations"
  artifacts:
    - path: "backend/app/services/adk_service.py"
      provides: "ADK Runner initialization and services"
      exports: ["get_runner", "get_session_service", "get_artifact_service"]
    - path: "backend/app/agents/factory.py"
      provides: "Agent factory pattern for fresh instances"
      exports: ["AgentFactory"]
    - path: "backend/app/agents/base.py"
      provides: "Base agent configurations and callback setup"
      exports: ["create_agent_callbacks", "THINKING_CONFIG"]
  key_links:
    - from: "backend/app/services/adk_service.py"
      to: "backend/app/config.py"
      via: "Settings for database URL and GCS bucket"
      pattern: "get_settings\\(\\)"
    - from: "backend/app/agents/factory.py"
      to: "backend/app/agents/base.py"
      via: "Base configurations imported"
      pattern: "from app\\.agents\\.base import"
---

<objective>
Set up Google ADK infrastructure with PostgreSQL session service and GCS artifact storage.

Purpose: Establish the foundational agent infrastructure that all subsequent agents will use. This includes the ADK Runner, session persistence, artifact storage, and the factory pattern for creating fresh agent instances.

Output: Working ADK service layer with session/artifact services and agent factory ready for Triage/Orchestrator implementation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-agent-system/04-CONTEXT.md
@.planning/phases/04-core-agent-system/04-RESEARCH.md

# Existing patterns to follow
@backend/app/config.py
@backend/app/database.py
@backend/app/services/file_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ADK dependencies and configuration</name>
  <files>
    - backend/pyproject.toml
    - backend/app/config.py
  </files>
  <action>
Add google-adk>=1.22.0 to pyproject.toml dependencies. Note: asyncpg is already present.

Update config.py to add new settings fields:
- `google_api_key: str | None = None` - API key for Gemini (env: GOOGLE_API_KEY) - **NOTE: ADK uses GOOGLE_API_KEY, not GEMINI_API_KEY**
- `use_vertex_ai: bool = False` - Whether to use Vertex AI backend (env: GOOGLE_GENAI_USE_VERTEXAI)
- `google_cloud_location: str = "europe-west3"` - GCP region (env: GOOGLE_CLOUD_LOCATION)
- `adk_artifacts_bucket: str | None = None` - GCS bucket for ADK artifacts (env: ADK_ARTIFACTS_BUCKET), can default to `gcs_bucket` if not set
- `adk_app_name: str = "holmes"` - Application name for ADK session namespacing
- `gemini_flash_model: str = "gemini-3-flash-preview"` - Flash model ID (env: GEMINI_FLASH_MODEL) - configurable for model updates
- `gemini_pro_model: str = "gemini-3-pro-preview"` - Pro model ID (env: GEMINI_PRO_MODEL) - configurable for model updates
- `file_api_threshold: int = 100_000_000` - File size (bytes) above which to use File API instead of inline (env: FILE_API_THRESHOLD)

Use existing Settings pattern with pydantic-settings. Follow the same optional field pattern as database_url for runtime flexibility during tooling imports.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && uv pip install -e .` to verify dependencies install correctly.
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.config import get_settings; s = get_settings(); print(f'adk_app_name={s.adk_app_name}, location={s.google_cloud_location}')"` to verify config loads.
  </verify>
  <done>google-adk installed and accessible. Config fields for ADK present and loadable.</done>
</task>

<task type="auto">
  <name>Task 2: Create ADK service layer with session and artifact services</name>
  <files>
    - backend/app/services/adk_service.py
    - backend/app/services/__init__.py
  </files>
  <action>
Create backend/app/services/adk_service.py with:

1. **DatabaseSessionService initialization**:
   - Use `postgresql+asyncpg://` URL from settings.database_url
   - Create lazily on first access (similar to database.py pattern)
   - Note: Per RESEARCH.md, migrations need sync driver - add comment about running `adk migrate session --db-url="postgresql+psycopg2://..."` separately

2. **GcsArtifactService initialization**:
   - Use settings.adk_artifacts_bucket (fallback to settings.gcs_bucket)
   - Bucket must exist (ADK doesn't create it)

3. **Runner factory function** `create_stage_runner(agent)`:
   - Creates Runner with session_service, artifact_service
   - Sets app_name from settings
   - Used per pipeline stage (each stage gets its own Runner invocation)

4. **Stage session factory** `get_or_create_stage_session(user_id, case_id, workflow_id, stage)`:
   - Creates deterministic session ID: SHA-256 of `{case_id}:{workflow_id}:{stage}`
   - Idempotent: returns existing session if already created
   - Each pipeline stage (triage, orchestrator, domain, synthesis) gets a FRESH session
   - This prevents multimodal file content from bloating downstream contexts

5. **Service getters**:
   - `get_session_service()` - returns singleton DatabaseSessionService
   - `get_artifact_service()` - returns singleton GcsArtifactService

6. **File preparation utility** `prepare_file_for_agent(file, gcs_bucket)`:
   - Tiered approach: inline (â‰¤100MB) vs File API (>100MB)
   - File API: upload to Gemini, get URI reference (48hr retention)
   - Returns `types.Part` for either approach
   - Also: `build_agent_content(files, gcs_bucket, prompt)` helper

Add 2-line ABOUTME comment at top. Follow existing service patterns from file_service.py.

Update backend/app/services/__init__.py to export the new module.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.services.adk_service import get_session_service, get_artifact_service; print('ADK services importable')"` to verify imports work (will fail at runtime without env vars, but import should succeed).
  </verify>
  <done>ADK service layer created with session service, artifact service, and runner factory. Services are lazily initialized.</done>
</task>

<task type="auto">
  <name>Task 3: Create agent base configurations and factory pattern</name>
  <files>
    - backend/app/agents/__init__.py
    - backend/app/agents/base.py
    - backend/app/agents/factory.py
  </files>
  <action>
Create backend/app/agents/ directory structure.

**backend/app/agents/base.py**:
1. Import and create BuiltInPlanner factory for thinking config (ADK best practice):
   ```python
   from google.adk.planners import BuiltInPlanner
   from google.genai.types import ThinkingConfig
   from app.config import get_settings

   def create_thinking_planner(level: str = "high") -> BuiltInPlanner:
       """Create a BuiltInPlanner with Gemini 3 thinking configuration.

       Valid levels for Gemini 3:
       - "minimal": Minimizes latency
       - "low": Simple tasks
       - "medium": Balanced (Flash only)
       - "high": Maximum reasoning (DEFAULT - user requested HIGH for all)
       """
       return BuiltInPlanner(
           thinking_config=ThinkingConfig(
               thinking_level=level,
               include_thoughts=True,
           )
       )
   ```

2. Define model constants from settings (configurable via env vars):
   ```python
   settings = get_settings()
   MODEL_FLASH = settings.gemini_flash_model  # default: "gemini-3-flash-preview"
   MODEL_PRO = settings.gemini_pro_model      # default: "gemini-3-pro-preview"
   ```

3. (DEPRECATED - keep for backwards compat) Legacy thinking config dicts:
   ```python
   # Note: Prefer create_thinking_planner() instead
   THINKING_CONFIG_HIGH = {"thinking_level": "high", "include_thoughts": True}
   ```

4. Create callback factory function `create_agent_callbacks(case_id: str, publish_fn: Callable)`:
   - Returns dict with all 6 callback types (before_agent, after_agent, before_model, after_model, before_tool, after_tool)
   - Each callback publishes appropriate SSE event via publish_fn
   - Use asyncio.create_task for non-blocking event publishing
   - Callback signatures per RESEARCH.md appendix

**backend/app/agents/factory.py**:
1. Create AgentFactory class with static methods:
   - `create_triage_agent(case_id: str, file_ids: list[str]) -> LlmAgent`
   - `create_orchestrator_agent(case_id: str, triage_result: dict) -> LlmAgent`

2. Each factory method:
   - Creates fresh LlmAgent instance (avoids single-parent violation)
   - Uses appropriate model from settings (Flash for Triage, Pro for Orchestrator)
   - Uses `create_thinking_planner("high")` for ALL agents (user requested HIGH)
   - Sets unique output_key for state passing
   - Placeholder system prompts (will be expanded in later plans)

Note: Both Triage and Orchestrator use thinking_level="high" per user request, regardless of model.

**backend/app/agents/__init__.py**:
- Export AgentFactory, create_thinking_planner, MODEL_FLASH, MODEL_PRO, callback factory

Add 2-line ABOUTME comments to each file.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents import AgentFactory; print('AgentFactory importable')"` to verify structure.
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents.base import create_thinking_planner, MODEL_FLASH; print(f'Flash model: {MODEL_FLASH}')"` to verify base configs.
  </verify>
  <done>Agent infrastructure in place with factory pattern, base configurations, and callback utilities. Ready for Triage and Orchestrator implementation.</done>
</task>

</tasks>

<verification>
1. All new files have ABOUTME comments
2. `uv pip install -e .` succeeds in backend directory
3. All new modules are importable without runtime errors
4. Config loads with new ADK-related fields
5. Type hints are complete (no `any` types)
6. Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && ruff check app/` passes
</verification>

<success_criteria>
- google-adk dependency added and installable
- ADK configuration fields present in Settings
- DatabaseSessionService and GcsArtifactService can be instantiated (with proper env vars)
- AgentFactory creates fresh agent instances
- Callback factory ready for SSE integration
- create_thinking_planner returns BuiltInPlanner with "high" level
- Model IDs configurable via GEMINI_FLASH_MODEL and GEMINI_PRO_MODEL env vars
- All code follows existing backend patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-agent-system/04-01-SUMMARY.md`
</output>
