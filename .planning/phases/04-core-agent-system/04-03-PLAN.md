---
phase: 04-core-agent-system
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/app/agents/triage.py
  - backend/app/agents/prompts/__init__.py
  - backend/app/agents/prompts/triage.py
  - backend/app/agents/factory.py
autonomous: true

must_haves:
  truths:
    - "Triage Agent processes files and outputs domain scores"
    - "Triage extracts entities (names, organizations, dates, locations, legal terms)"
    - "Triage produces short and detailed summaries per file"
    - "Triage assesses complexity tier (low/medium/high)"
    - "Triage suggests file groupings for related documents"
  artifacts:
    - path: "backend/app/agents/triage.py"
      provides: "Triage Agent implementation"
      exports: ["TriageAgent", "run_triage"]
    - path: "backend/app/agents/prompts/triage.py"
      provides: "Triage system prompt"
      exports: ["TRIAGE_SYSTEM_PROMPT"]
  key_links:
    - from: "backend/app/agents/triage.py"
      to: "backend/app/agents/factory.py"
      via: "Factory creates Triage instances"
      pattern: "create_triage_agent"
    - from: "backend/app/agents/triage.py"
      to: "backend/app/schemas/agent.py"
      via: "Uses TriageOutput schema"
      pattern: "TriageOutput|TriageFileResult"
---

<objective>
Implement the Triage Agent that analyzes uploaded files and produces domain scores, entities, summaries, and complexity assessments.

Purpose: Triage is the first agent in the pipeline. It classifies files by domain relevance, extracts quick entities, and provides metadata that the Orchestrator uses for intelligent routing.

Output: Working Triage Agent that can process files via Gemini Flash and output structured triage results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-agent-system/04-CONTEXT.md
@.planning/phases/04-core-agent-system/04-RESEARCH.md
@.planning/phases/04-core-agent-system/04-01-SUMMARY.md

# Schema definitions (may not exist yet if running in parallel)
@backend/app/schemas/agent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Triage system prompt</name>
  <files>
    - backend/app/agents/prompts/__init__.py
    - backend/app/agents/prompts/triage.py
  </files>
  <action>
Create backend/app/agents/prompts/ directory.

Create backend/app/agents/prompts/triage.py with TRIAGE_SYSTEM_PROMPT:

The prompt should instruct the agent to:
1. **Analyze each file** provided in the input
2. **Score domain relevance** (0-100) for: financial, legal, strategy, evidence
   - Include brief reasoning for each score
3. **Extract entities quickly**: names, organizations, dates, locations, amounts, legal terms
   - Don't be exhaustive - focus on key entities useful for routing
4. **Generate summaries**:
   - Short: 1-2 sentences for list views
   - Detailed: Full paragraph for Orchestrator context
5. **Assess complexity** tier (low/medium/high):
   - Low: Simple, single-topic document
   - Medium: Multi-faceted but straightforward
   - High: Complex, cross-domain, or requires deep analysis
6. **Suggest file groupings** if multiple files relate to same transaction/event/entity
7. **Handle corrupted/unreadable content**:
   - Extract what's possible
   - Mark confidence as low
   - Note corruption in output

Output format should match TriageOutput schema structure (JSON).

Include example output format in the prompt to guide structured responses.

Per CONTEXT.md: "Contradiction/gap detection: Leave to Synthesis Agent - Triage stays simple"

Create backend/app/agents/prompts/__init__.py to export TRIAGE_SYSTEM_PROMPT.

Add 2-line ABOUTME comments.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents.prompts import TRIAGE_SYSTEM_PROMPT; print(f'Prompt length: {len(TRIAGE_SYSTEM_PROMPT)} chars')"` to verify prompt is loadable and substantive.
  </verify>
  <done>Triage system prompt created with clear instructions for domain scoring, entity extraction, summaries, complexity, and groupings.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Triage Agent and execution function</name>
  <files>
    - backend/app/agents/triage.py
    - backend/app/agents/factory.py
  </files>
  <action>
Create backend/app/agents/triage.py with:

1. **TriageAgent class** (wrapper around ADK LlmAgent):
   ```python
   class TriageAgent:
       """Triage Agent for initial file classification and entity extraction."""

       def __init__(self, case_id: str, file_ids: list[str], callbacks: dict | None = None):
           self.case_id = case_id
           self.file_ids = file_ids
           self._agent = self._create_agent(callbacks)

       def _create_agent(self, callbacks: dict | None) -> LlmAgent:
           # Use factory pattern internally
           ...
   ```

2. **run_triage async function**:
   ```python
   async def run_triage(
       case_id: str,
       workflow_id: str,
       user_id: str,
       files: list[CaseFile],  # From database
       db_session: AsyncSession,
       publish_event: Callable | None = None,
   ) -> TriageOutput:
       """
       Run triage analysis on a batch of files.

       Creates a FRESH ADK session for the triage stage (stage-isolated).
       This ensures file content doesn't bloat downstream agents' contexts.

       Args:
           case_id: UUID of the case
           workflow_id: UUID of the analysis workflow
           user_id: UUID of the authenticated user
           files: List of CaseFile records to analyze
           db_session: Database session for execution logging
           publish_event: Optional callback for SSE events

       Returns:
           TriageOutput with file results and groupings
       """
   ```

3. **Key implementation details**:
   - Use `settings.gemini_flash_model` (MODEL_FLASH) for speed per CONTEXT.md
   - Use `create_thinking_planner("high")` - user requested HIGH for ALL agents
   - Note: Thought signatures for function calls are auto-handled by ADK
   - Build multimodal content from files (download + base64 encode)
   - Create execution record before running
   - Update execution record with results/errors after
   - Parse LLM output into TriageOutput schema
   - Handle partial results for corrupted files

4. **File content preparation** (tiered: inline ≤100MB, File API >100MB):
   ```python
   from app.services.adk_service import prepare_file_for_agent, build_agent_content

   # Uses the tiered file preparation from adk_service:
   # - ≤100MB: Download from GCS, encode as inline_data (base64)
   # - >100MB: Upload to Gemini File API, get URI reference (48hr retention, free)
   # - File API supports up to 2GB per file
   #
   # Both approaches work with Google AI Studio (API key auth)
   # File API URIs are reusable across multiple pipeline stages

   async def _prepare_triage_content(
       files: list[CaseFile],
       gcs_bucket: str,
   ) -> types.Content:
       """Build multimodal content for Triage Agent.

       Uses tiered file handling:
       - Small files (≤100MB): inline base64
       - Large files (>100MB): File API upload → URI reference
       """
       return await build_agent_content(
           files=files,
           gcs_bucket=gcs_bucket,
           prompt="Analyze the following documents:",
       )
   ```

   **media_resolution for Triage:** Use `"medium"` for speed — Triage is classification,
   not forensic analysis. Domain agents later use `"high"` for detail.

5. **Output parsing**:
   - Try to parse JSON from model response
   - Validate against TriageOutput schema
   - Handle malformed responses gracefully

Update backend/app/agents/factory.py:
- Update `create_triage_agent` to use the real prompt
- Use `settings.gemini_flash_model` instead of hardcoded model ID
- Use `planner=create_thinking_planner("high")` for thinking config
- Add `output_key="triage_result"` for state passing pattern

Add 2-line ABOUTME comment.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents.triage import TriageAgent, run_triage; print('Triage agent importable')"` to verify imports.
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && ruff check app/agents/triage.py` to verify code quality.
  </verify>
  <done>Triage Agent implemented with multimodal file processing, structured output parsing, and execution logging integration.</done>
</task>

<task type="auto">
  <name>Task 3: Add Triage Agent exports and integration</name>
  <files>
    - backend/app/agents/__init__.py
  </files>
  <action>
Update backend/app/agents/__init__.py to export:
- `TriageAgent`
- `run_triage`
- `TRIAGE_SYSTEM_PROMPT` (from prompts)

Ensure all exports are properly typed with `__all__` list.

Verify the agent module provides a clean public API:
```python
from app.agents import (
    AgentFactory,
    TriageAgent,
    run_triage,
    TRIAGE_SYSTEM_PROMPT,
    # Base configs
    create_thinking_planner,  # Factory for BuiltInPlanner with ThinkingConfig
    MODEL_FLASH,
    MODEL_PRO,
    create_agent_callbacks,
)
```
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents import TriageAgent, run_triage, TRIAGE_SYSTEM_PROMPT; print('All Triage exports available')"` to verify exports.
  </verify>
  <done>Triage Agent fully integrated into agents module with clean public API.</done>
</task>

</tasks>

<verification>
1. All new files have ABOUTME comments
2. Triage prompt covers all CONTEXT.md requirements
3. run_triage function handles file batch processing
4. Multimodal content correctly prepared from CaseFile records
5. Output parsing validates against TriageOutput schema
6. Execution logging integration ready
7. `ruff check app/agents/` passes
</verification>

<success_criteria>
- Triage Agent can be instantiated via factory
- System prompt guides model to produce correct output structure
- run_triage processes files and returns TriageOutput
- Domain scores, entities, summaries, complexity, groupings all captured
- Corrupted file handling implemented
- Code integrates with execution logging (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-agent-system/04-03-SUMMARY.md`
</output>
