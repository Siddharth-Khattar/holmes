---
phase: 04-core-agent-system
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/app/agents/triage.py
  - backend/app/agents/prompts/__init__.py
  - backend/app/agents/prompts/triage.py
  - backend/app/agents/factory.py
autonomous: true

must_haves:
  truths:
    - "Triage Agent processes files and outputs domain scores"
    - "Triage extracts entities (names, organizations, dates, locations, legal terms)"
    - "Triage produces short and detailed summaries per file"
    - "Triage assesses complexity tier (low/medium/high)"
    - "Triage suggests file groupings for related documents"
  artifacts:
    - path: "backend/app/agents/triage.py"
      provides: "Triage Agent implementation"
      exports: ["TriageAgent", "run_triage"]
    - path: "backend/app/agents/prompts/triage.py"
      provides: "Triage system prompt"
      exports: ["TRIAGE_SYSTEM_PROMPT"]
  key_links:
    - from: "backend/app/agents/triage.py"
      to: "backend/app/agents/factory.py"
      via: "Factory creates Triage instances"
      pattern: "create_triage_agent"
    - from: "backend/app/agents/triage.py"
      to: "backend/app/schemas/agent.py"
      via: "Uses TriageOutput schema"
      pattern: "TriageOutput|TriageFileResult"
---

<objective>
Implement the Triage Agent that analyzes uploaded files and produces domain scores, entities, summaries, and complexity assessments.

Purpose: Triage is the first agent in the pipeline. It classifies files by domain relevance, extracts quick entities, and provides metadata that the Orchestrator uses for intelligent routing.

Output: Working Triage Agent that can process files via Gemini Flash and output structured triage results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-agent-system/04-CONTEXT.md
@.planning/phases/04-core-agent-system/04-RESEARCH.md
@.planning/phases/04-core-agent-system/04-01-SUMMARY.md

# Schema definitions (may not exist yet if running in parallel)
@backend/app/schemas/agent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Triage system prompt</name>
  <files>
    - backend/app/agents/prompts/__init__.py
    - backend/app/agents/prompts/triage.py
  </files>
  <action>
Create backend/app/agents/prompts/ directory.

Create backend/app/agents/prompts/triage.py with TRIAGE_SYSTEM_PROMPT:

The prompt should instruct the agent to:
1. **Analyze each file** provided in the input
2. **Score domain relevance** (0-100) for: financial, legal, strategy, evidence
   - Include brief reasoning for each score
3. **Extract entities quickly**: names, organizations, dates, locations, amounts, legal terms
   - Don't be exhaustive - focus on key entities useful for routing
4. **Generate summaries**:
   - Short: 1-2 sentences for list views
   - Detailed: Full paragraph for Orchestrator context
5. **Assess complexity** tier (low/medium/high):
   - Low: Simple, single-topic document
   - Medium: Multi-faceted but straightforward
   - High: Complex, cross-domain, or requires deep analysis
6. **Suggest file groupings** if multiple files relate to same transaction/event/entity
7. **Handle corrupted/unreadable content**:
   - Extract what's possible
   - Mark confidence as low
   - Note corruption in output

Output format should match TriageOutput schema structure (JSON).

Include example output format in the prompt to guide structured responses.

Per CONTEXT.md: "Contradiction/gap detection: Leave to Synthesis Agent - Triage stays simple"

Create backend/app/agents/prompts/__init__.py to export TRIAGE_SYSTEM_PROMPT.

Add 2-line ABOUTME comments.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents.prompts import TRIAGE_SYSTEM_PROMPT; print(f'Prompt length: {len(TRIAGE_SYSTEM_PROMPT)} chars')"` to verify prompt is loadable and substantive.
  </verify>
  <done>Triage system prompt created with clear instructions for domain scoring, entity extraction, summaries, complexity, and groupings.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Triage Agent and execution function</name>
  <files>
    - backend/app/agents/triage.py
    - backend/app/agents/factory.py
  </files>
  <action>
Create backend/app/agents/triage.py with:

1. **TriageAgent class** (wrapper around ADK LlmAgent):
   ```python
   class TriageAgent:
       """Triage Agent for initial file classification and entity extraction."""

       def __init__(self, case_id: str, file_ids: list[str], callbacks: dict | None = None):
           self.case_id = case_id
           self.file_ids = file_ids
           self._agent = self._create_agent(callbacks)

       def _create_agent(self, callbacks: dict | None) -> LlmAgent:
           # Use factory pattern internally
           ...
   ```

2. **run_triage async function**:
   ```python
   async def run_triage(
       case_id: str,
       files: list[CaseFile],  # From database
       session: AsyncSession,
       publish_event: Callable | None = None,
   ) -> TriageOutput:
       """
       Run triage analysis on a batch of files.

       Args:
           case_id: UUID of the case
           files: List of CaseFile records to analyze
           session: Database session for execution logging
           publish_event: Optional callback for SSE events

       Returns:
           TriageOutput with file results and groupings
       """
   ```

3. **Key implementation details**:
   - Use `MODEL_FLASH` for speed per CONTEXT.md
   - Use `THINKING_CONFIG_LOW` per REQUIREMENTS.md
   - Build multimodal content from files (use GCS URIs)
   - Create execution record before running
   - Update execution record with results/errors after
   - Parse LLM output into TriageOutput schema
   - Handle partial results for corrupted files

4. **File content preparation**:
   ```python
   def _prepare_file_content(files: list[CaseFile]) -> list[types.Part]:
       """Convert CaseFile records to Gemini Parts for multimodal input."""
       parts = []
       for f in files:
           # Use GCS URI directly (Gemini supports gs:// URIs)
           parts.append(types.Part(text=f"File: {f.original_filename} (ID: {f.id})"))
           parts.append(types.Part(
               file_data=types.FileData(
                   file_uri=f"gs://{settings.gcs_bucket}/{f.storage_path}",
                   mime_type=f.mime_type
               )
           ))
       return parts
   ```

5. **Output parsing**:
   - Try to parse JSON from model response
   - Validate against TriageOutput schema
   - Handle malformed responses gracefully

Update backend/app/agents/factory.py:
- Update `create_triage_agent` to use the real prompt
- Add `output_key="triage_result"`

Add 2-line ABOUTME comment.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents.triage import TriageAgent, run_triage; print('Triage agent importable')"` to verify imports.
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && ruff check app/agents/triage.py` to verify code quality.
  </verify>
  <done>Triage Agent implemented with multimodal file processing, structured output parsing, and execution logging integration.</done>
</task>

<task type="auto">
  <name>Task 3: Add Triage Agent exports and integration</name>
  <files>
    - backend/app/agents/__init__.py
  </files>
  <action>
Update backend/app/agents/__init__.py to export:
- `TriageAgent`
- `run_triage`
- `TRIAGE_SYSTEM_PROMPT` (from prompts)

Ensure all exports are properly typed with `__all__` list.

Verify the agent module provides a clean public API:
```python
from app.agents import (
    AgentFactory,
    TriageAgent,
    run_triage,
    TRIAGE_SYSTEM_PROMPT,
    # Base configs
    THINKING_CONFIG_LOW,
    THINKING_CONFIG_HIGH,
    MODEL_FLASH,
    MODEL_PRO,
    create_agent_callbacks,
)
```
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents import TriageAgent, run_triage, TRIAGE_SYSTEM_PROMPT; print('All Triage exports available')"` to verify exports.
  </verify>
  <done>Triage Agent fully integrated into agents module with clean public API.</done>
</task>

</tasks>

<verification>
1. All new files have ABOUTME comments
2. Triage prompt covers all CONTEXT.md requirements
3. run_triage function handles file batch processing
4. Multimodal content correctly prepared from CaseFile records
5. Output parsing validates against TriageOutput schema
6. Execution logging integration ready
7. `ruff check app/agents/` passes
</verification>

<success_criteria>
- Triage Agent can be instantiated via factory
- System prompt guides model to produce correct output structure
- run_triage processes files and returns TriageOutput
- Domain scores, entities, summaries, complexity, groupings all captured
- Corrupted file handling implemented
- Code integrates with execution logging (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-agent-system/04-03-SUMMARY.md`
</output>
