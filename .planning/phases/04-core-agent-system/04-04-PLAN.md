---
phase: 04-core-agent-system
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - backend/app/agents/orchestrator.py
  - backend/app/agents/prompts/orchestrator.py
  - backend/app/agents/factory.py
  - backend/app/schemas/agent.py
autonomous: true

must_haves:
  truths:
    - "Orchestrator receives triage output and makes routing decisions"
    - "Orchestrator routing log captures detailed reasoning"
    - "Orchestrator can trigger Research/Discovery when gaps detected (stub)"
    - "Routing decisions determine which domain agents to invoke"
  artifacts:
    - path: "backend/app/agents/orchestrator.py"
      provides: "Orchestrator Agent implementation"
      exports: ["OrchestratorAgent", "run_orchestrator"]
    - path: "backend/app/agents/prompts/orchestrator.py"
      provides: "Orchestrator system prompt with routing guardrails"
      exports: ["ORCHESTRATOR_SYSTEM_PROMPT"]
    - path: "backend/app/schemas/agent.py"
      provides: "OrchestratorOutput schema"
      exports: ["OrchestratorOutput", "RoutingDecision", "ResearchTrigger"]
  key_links:
    - from: "backend/app/agents/orchestrator.py"
      to: "backend/app/agents/triage.py"
      via: "Consumes TriageOutput"
      pattern: "TriageOutput|triage_result"
    - from: "backend/app/agents/orchestrator.py"
      to: "backend/app/schemas/agent.py"
      via: "Uses OrchestratorOutput schema"
      pattern: "OrchestratorOutput|RoutingDecision"
---

<objective>
Implement the Orchestrator Agent skeleton that receives triage results and determines routing to domain agents.

Purpose: Orchestrator is the intelligent coordinator. It analyzes triage output, makes routing decisions with detailed reasoning, and prepares for domain agent invocation. This plan creates the skeleton with routing stubs for Research/Discovery agents.

Output: Working Orchestrator Agent that produces routing decisions based on triage data, with placeholders for future domain agent orchestration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-agent-system/04-CONTEXT.md
@.planning/phases/04-core-agent-system/04-RESEARCH.md
@.planning/phases/04-core-agent-system/04-01-SUMMARY.md
@.planning/phases/04-core-agent-system/04-02-SUMMARY.md
@.planning/phases/04-core-agent-system/04-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Orchestrator output schemas</name>
  <files>
    - backend/app/schemas/agent.py
  </files>
  <action>
Add to backend/app/schemas/agent.py:

1. **RoutingDecision** - Per CONTEXT.md "detailed reasoning stored and displayed":
   ```python
   class RoutingDecision(BaseModel):
       file_id: str
       file_name: str
       target_agents: list[Literal["financial", "legal", "strategy", "evidence"]]
       reasoning: str  # Detailed explanation of why these agents
       priority: Literal["high", "medium", "low"] = "medium"
       domain_scores: dict[str, float]  # From triage, for reference
   ```

2. **FileGroup** - For batching related files:
   ```python
   class FileGroupForProcessing(BaseModel):
       group_id: str
       file_ids: list[str]
       target_agents: list[str]
       shared_context: str  # Why these files are grouped
   ```

3. **ResearchTrigger** - Per CONTEXT.md "autonomous research when gaps detected":
   ```python
   class ResearchTrigger(BaseModel):
       should_trigger: bool
       reason: str | None = None
       research_queries: list[str] = []  # Suggested research directions
       priority: Literal["high", "medium", "low"] = "medium"
   ```

4. **OrchestratorOutput** - Complete orchestrator response:
   ```python
   class OrchestratorOutput(BaseModel):
       routing_decisions: list[RoutingDecision]
       file_groups: list[FileGroupForProcessing]
       parallel_agents: list[str]  # Agents that can run in parallel
       sequential_agents: list[str]  # Agents that must run sequentially
       research_trigger: ResearchTrigger
       overall_complexity: Literal["low", "medium", "high"]
       routing_summary: str  # Human-readable summary of routing plan
       warnings: list[str] = []  # Any concerns or edge cases noted
   ```

Update __init__.py exports.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.schemas.agent import OrchestratorOutput, RoutingDecision, ResearchTrigger; print('Orchestrator schemas importable')"` to verify imports.
  </verify>
  <done>Orchestrator output schemas added with routing decisions, file groupings, and research triggers.</done>
</task>

<task type="auto">
  <name>Task 2: Create Orchestrator system prompt with routing guardrails</name>
  <files>
    - backend/app/agents/prompts/orchestrator.py
    - backend/app/agents/prompts/__init__.py
  </files>
  <action>
Create backend/app/agents/prompts/orchestrator.py with ORCHESTRATOR_SYSTEM_PROMPT:

The prompt should include per CONTEXT.md decisions:

1. **Role definition**:
   - Intelligent coordinator that routes files to domain agents
   - Uses thinking_level="high" for complex reasoning

2. **Routing logic** per CONTEXT.md "Dynamic threshold":
   - No fixed threshold - decide based on case complexity and file types
   - Consider: domain score magnitude, cross-domain relevance, file relationships
   - Justify every routing decision with clear reasoning

3. **Guardrails** per CONTEXT.md "tight guardrails":
   - MUST have well-justified reason for each agent invocation
   - MUST NOT spawn agents unnecessarily
   - Prefer parallel execution for independent domains
   - Use sequential only for genuine dependencies (e.g., financial fraud needs legal context)

4. **File grouping** per CONTEXT.md "Pass groups to agents":
   - Group related files for context
   - Explain why files belong together

5. **Research trigger** per CONTEXT.md "Autonomous research":
   - Trigger research when: low confidence on key domains, critical gaps detected
   - Provide specific research queries
   - This is for future implementation - just output the trigger decision

6. **Output format**:
   - Must produce valid JSON matching OrchestratorOutput schema
   - Include example in prompt

7. **Edge cases**:
   - Single file: Still analyze thoroughly
   - Ambiguous domain: Route to multiple agents, let them determine relevance
   - Corrupted files: Note in warnings, route based on what triage extracted

Update backend/app/agents/prompts/__init__.py to export ORCHESTRATOR_SYSTEM_PROMPT.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents.prompts import ORCHESTRATOR_SYSTEM_PROMPT; print(f'Orchestrator prompt: {len(ORCHESTRATOR_SYSTEM_PROMPT)} chars')"` to verify prompt is substantive.
  </verify>
  <done>Orchestrator system prompt created with routing guardrails, dynamic thresholds, and research trigger logic.</done>
</task>

<task type="auto">
  <name>Task 3: Implement Orchestrator Agent and execution function</name>
  <files>
    - backend/app/agents/orchestrator.py
    - backend/app/agents/factory.py
    - backend/app/agents/__init__.py
  </files>
  <action>
Create backend/app/agents/orchestrator.py with:

1. **OrchestratorAgent class**:
   ```python
   class OrchestratorAgent:
       """Orchestrator Agent for intelligent routing based on triage results."""

       def __init__(
           self,
           case_id: str,
           triage_output: TriageOutput,
           callbacks: dict | None = None
       ):
           self.case_id = case_id
           self.triage_output = triage_output
           self._agent = self._create_agent(callbacks)
   ```

2. **run_orchestrator async function**:
   ```python
   async def run_orchestrator(
       case_id: str,
       workflow_id: str,
       triage_output: TriageOutput,
       session: AsyncSession,
       publish_event: Callable | None = None,
   ) -> OrchestratorOutput:
       """
       Run orchestrator to determine domain agent routing.

       Args:
           case_id: UUID of the case
           workflow_id: UUID of the analysis workflow
           triage_output: Results from triage analysis
           session: Database session for execution logging
           publish_event: Optional callback for SSE events

       Returns:
           OrchestratorOutput with routing decisions and research triggers
       """
   ```

3. **Key implementation details**:
   - Use `MODEL_PRO` for complex reasoning per CONTEXT.md
   - Use `THINKING_CONFIG_HIGH` per REQUIREMENTS.md
   - Create execution record before running (link to triage execution as parent)
   - Build input context from triage output (domain scores, entities, summaries)
   - Parse LLM output into OrchestratorOutput schema
   - Log routing decisions to execution record
   - Handle research trigger (just capture the decision, no actual execution yet)

4. **Input preparation**:
   ```python
   def _prepare_orchestrator_input(triage_output: TriageOutput) -> str:
       """Format triage output as context for orchestrator."""
       # Convert to structured text the model can reason about
       ...
   ```

5. **Stub for domain agent invocation** (actual invocation in Phase 6):
   ```python
   async def _invoke_domain_agents_stub(
       routing: OrchestratorOutput
   ) -> None:
       """Placeholder for domain agent invocation. Implemented in Phase 6."""
       # Log what would be invoked
       logger.info(
           "Domain agent invocation stub: parallel=%s, sequential=%s",
           routing.parallel_agents,
           routing.sequential_agents
       )
   ```

Update backend/app/agents/factory.py:
- Update `create_orchestrator_agent` to use real prompt
- Add `output_key="orchestrator_result"`

Update backend/app/agents/__init__.py to export:
- `OrchestratorAgent`
- `run_orchestrator`
- `ORCHESTRATOR_SYSTEM_PROMPT`

Add 2-line ABOUTME comment.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && python -c "from app.agents import OrchestratorAgent, run_orchestrator; print('Orchestrator importable')"` to verify imports.
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && ruff check app/agents/orchestrator.py` to verify code quality.
  </verify>
  <done>Orchestrator Agent implemented with routing logic, research triggers, and stubs for domain agent invocation.</done>
</task>

</tasks>

<verification>
1. All new files have ABOUTME comments
2. Orchestrator prompt includes routing guardrails
3. run_orchestrator produces OrchestratorOutput
4. Routing decisions include detailed reasoning
5. Research trigger logic captured
6. Execution logging integration complete
7. `ruff check app/` passes
</verification>

<success_criteria>
- Orchestrator consumes TriageOutput correctly
- Routing decisions made with detailed reasoning
- File groupings determined for batch processing
- Research trigger decision captured (stub for Phase 9)
- Parallel vs sequential agent determination works
- Domain agent invocation stub logs intended actions
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-agent-system/04-04-SUMMARY.md`
</output>
