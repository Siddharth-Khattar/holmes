---
phase: 04.1-agent-decision-tree-revamp
plan: 03
type: execute
wave: 2
depends_on: ["04.1-01", "04.1-02"]
files_modified:
  - frontend/src/components/CommandCenter/AgentFlowCanvas.tsx
  - frontend/src/components/CommandCenter/CommandCenter.tsx
  - frontend/src/components/CommandCenter/index.ts
autonomous: false

must_haves:
  truths:
    - "Agent tree renders with dagre hierarchical layout (top-to-bottom)"
    - "Nodes animate into existence progressively as SSE events arrive"
    - "Smoothstep edges animate along chosen path with teal glow"
    - "Clicking any node opens the spring-animated sidebar"
    - "Canvas has dark background with dot grid pattern"
    - "Viewport auto-fits all nodes and stays zoomed to show full tree"
    - "Pan/zoom works, nodes are not draggable"
    - "All existing SSE events and agent state management still functional"
    - "Unchosen domain agents appear muted after orchestrator completes"
  artifacts:
    - path: "frontend/src/components/CommandCenter/AgentFlowCanvas.tsx"
      provides: "ReactFlow canvas with dagre layout, edge styling, auto-fit"
      min_lines: 100
    - path: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      provides: "Main container with ReactFlowProvider, progressive tree build, sidebar integration"
      min_lines: 150
    - path: "frontend/src/components/CommandCenter/index.ts"
      provides: "Updated barrel exports"
  key_links:
    - from: "frontend/src/components/CommandCenter/AgentFlowCanvas.tsx"
      to: "frontend/src/components/CommandCenter/DecisionNode.tsx"
      via: "nodeTypes registration"
      pattern: "nodeTypes.*decision.*DecisionNode"
    - from: "frontend/src/components/CommandCenter/AgentFlowCanvas.tsx"
      to: "@dagrejs/dagre"
      via: "dagre layout computation"
      pattern: "dagre\\.layout"
    - from: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      to: "@xyflow/react"
      via: "ReactFlowProvider wrapping"
      pattern: "ReactFlowProvider"
    - from: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      to: "frontend/src/components/CommandCenter/NodeDetailsSidebar.tsx"
      via: "sidebar integration with selected node state"
      pattern: "NodeDetailsSidebar"
    - from: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      to: "frontend/src/hooks/useCommandCenterSSE.ts"
      via: "SSE events driving progressive tree build"
      pattern: "useCommandCenterSSE"
---

<objective>
Rewrite AgentFlowCanvas.tsx as a ReactFlow + dagre canvas, update CommandCenter.tsx with ReactFlowProvider wrapping and progressive tree build from SSE events, integrate NodeDetailsSidebar, and update barrel exports.

Purpose: This is the integration plan that brings together the DecisionNode (Plan 01) and NodeDetailsSidebar (Plan 02) into a working decision tree visualization. It replaces the D3-based canvas with ReactFlow, implements dagre auto-layout, edge styling, progressive tree building from SSE events, and the complete user interaction flow.

Output: Fully functional Command Center with ReactFlow decision tree, dagre layout, animated edges, progressive SSE-driven node appearance, sidebar integration, and visual verification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-CONTEXT.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-RESEARCH.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-01-SUMMARY.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-02-SUMMARY.md
@DOCS/UI/agent-decision-tree-guide.md
@frontend/src/types/command-center.ts
@frontend/src/hooks/useCommandCenterSSE.ts
@frontend/src/components/CommandCenter/AgentFlowCanvas.tsx
@frontend/src/components/CommandCenter/CommandCenter.tsx
@frontend/src/components/CommandCenter/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite AgentFlowCanvas with ReactFlow + dagre</name>
  <files>
    frontend/src/components/CommandCenter/AgentFlowCanvas.tsx
  </files>
  <action>
  **COMPLETE REWRITE** of `AgentFlowCanvas.tsx`. Replace the entire D3-based SVG canvas with a ReactFlow + dagre implementation.

  **Imports:**
  ```typescript
  import { ReactFlow, Background, ConnectionLineType, useReactFlow, type Node, type Edge } from '@xyflow/react';
  import '@xyflow/react/dist/style.css';
  import dagre from '@dagrejs/dagre';
  ```

  **Props interface (keep compatible with CommandCenter):**
  ```typescript
  interface AgentFlowCanvasProps {
    nodes: Node[];       // Pre-computed by CommandCenter
    edges: Edge[];       // Pre-computed by CommandCenter
    onNodeClick: (nodeId: string) => void;
    selectedNodeId: string | null;
  }
  ```

  NOTE: The props interface CHANGES from the current one. The current canvas receives `agentStates`, `connections`, `onAgentClick`, `selectedAgent`. The new canvas receives pre-computed ReactFlow `Node[]` and `Edge[]` from CommandCenter.tsx (which handles the data transformation). This is cleaner separation -- canvas is pure rendering, CommandCenter handles data.

  **nodeTypes constant (OUTSIDE the component):**
  ```typescript
  import { DecisionNode } from './DecisionNode';
  const nodeTypes = { decision: DecisionNode } as const;
  ```
  This MUST be outside the component body to avoid infinite re-renders (RESEARCH pitfall #1).

  **Component body:**

  1. Use `useReactFlow()` to access the instance for fitView.

  2. **Auto-fit viewport** when nodes change:
     ```typescript
     useEffect(() => {
       if (nodes.length > 0) {
         const timer = setTimeout(() => {
           reactFlowInstance.fitView({
             duration: 1500,
             padding: 0.2,
             minZoom: 0.1,
             maxZoom: 1,
           });
         }, 100); // Small delay to let nodes render
         return () => clearTimeout(timer);
       }
     }, [nodes.length, reactFlowInstance]);
     ```
     Per CONTEXT.md: "Viewport: stay zoomed to fit all". Re-fit when nodes.length changes (progressive build adds nodes). Do NOT auto-pan when individual agents activate -- only when new nodes appear.

  3. **ReactFlow configuration:**
     ```tsx
     <ReactFlow
       nodes={nodes}
       edges={edges}
       nodeTypes={nodeTypes}
       connectionLineType={ConnectionLineType.SmoothStep}
       nodesDraggable={false}
       nodesConnectable={false}
       elementsSelectable={false}
       panOnDrag={true}
       zoomOnScroll={true}
       minZoom={0.1}
       maxZoom={2}
       onNodeClick={(_, node) => onNodeClick(node.id)}
       fitView
       proOptions={{ hideAttribution: true }}
     >
       <Background
         gap={20}
         size={2}
         color="rgba(138, 138, 130, 0.15)"
       />
     </ReactFlow>
     ```

  4. **Canvas container styling:**
     - Full width/height: `w-full h-full`
     - Background color: `var(--color-jet)` (#111111) per CONTEXT.md decision
     - The ReactFlow `<Background>` component provides the dot grid

  5. **Remove ALL D3 imports** (d3-selection, d3-zoom). Remove all D3 zoom/pan logic, SVG rendering, manual path calculation, manual drag handling. The entire D3 approach is replaced by ReactFlow.

  6. **Remove the manual zoom control buttons** (ZoomIn, ZoomOut, RotateCcw, Maximize2). ReactFlow has its own controls, and the canvas spec in CONTEXT.md does not require custom zoom buttons.

  **Dagre layout helper function** (can be in the same file or a separate utility, use judgment):

  Export a `getLayoutedElements` function:
  ```typescript
  export function getLayoutedElements(
    nodes: Node[],
    edges: Edge[],
  ): { nodes: Node[]; edges: Edge[] } {
    const g = new dagre.graphlib.Graph().setDefaultEdgeLabel(() => ({}));

    g.setGraph({
      rankdir: 'TB',
      ranksep: 120,
      nodesep: 150,
    });

    nodes.forEach((node) => {
      g.setNode(node.id, { width: NODE_WIDTH, height: NODE_HEIGHT });
    });

    edges.forEach((edge) => {
      g.setEdge(edge.source, edge.target);
    });

    dagre.layout(g);

    const layoutedNodes = nodes.map((node) => {
      const dagreNode = g.node(node.id);
      return {
        ...node,
        position: {
          x: dagreNode.x - NODE_WIDTH / 2,
          y: dagreNode.y - NODE_HEIGHT / 2,
        },
      };
    });

    return { nodes: layoutedNodes, edges };
  }
  ```

  Import `NODE_WIDTH`, `NODE_HEIGHT` from `command-center-config.ts`.

  **IMPORTANT per RESEARCH pitfall #6:** Create a new dagre Graph instance each time OR clear previous nodes before recomputing. Do NOT reuse a module-level graph instance across calls.

  **Anti-patterns to avoid:**
  - Do NOT define `nodeTypes` inside the component
  - Do NOT use `useNodesState`/`useEdgesState` (we derive from data, not user-editable)
  - Do NOT import any D3 libraries
  - Do NOT animate width/height on nodes
  </action>
  <verify>
  - `AgentFlowCanvas.tsx` imports from `@xyflow/react` and `@dagrejs/dagre`
  - No D3 imports remain in the file
  - `nodeTypes` defined outside component body
  - `getLayoutedElements` function uses dagre for TB layout
  - ReactFlow configured with `nodesDraggable={false}`, `fitView`, `SmoothStep`
  - `cd frontend && bun run build` passes
  </verify>
  <done>
  AgentFlowCanvas completely rewritten from D3 SVG to ReactFlow + dagre. Auto-layout, smoothstep edges, auto-fit viewport, dot grid background, and no-drag/pan-zoom configuration all working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CommandCenter.tsx with ReactFlowProvider and progressive tree build</name>
  <files>
    frontend/src/components/CommandCenter/CommandCenter.tsx
    frontend/src/components/CommandCenter/index.ts
  </files>
  <action>
  **REWRITE `CommandCenter.tsx`** to integrate all new components.

  **Key changes:**

  1. **ReactFlowProvider wrapping:**
     Wrap the inner content in `ReactFlowProvider` at the CommandCenter level (NOT the page level):
     ```tsx
     import { ReactFlowProvider } from '@xyflow/react';

     export function CommandCenter({ caseId, className }: CommandCenterProps) {
       return (
         <ReactFlowProvider>
           <CommandCenterInner caseId={caseId} className={className} />
         </ReactFlowProvider>
       );
     }
     ```
     The inner component uses `useReactFlow()` internally via the canvas.

  2. **Add `command-center-scope` class** to the outermost container div so that the scoped CSS variables from globals.css are available to all child components.

  3. **Data transformation pipeline (agentStates -> ReactFlow nodes/edges):**

     Use `useMemo` to derive ReactFlow `Node[]` and `Edge[]` from `agentStates` and `connections`:

     ```typescript
     const { nodes, edges } = useMemo(() => {
       // Build nodes from agentStates
       const rfNodes: Node[] = [];
       const rfEdges: Edge[] = [];

       agentStates.forEach((state, type) => {
         const isChosen = state.status === 'processing' || state.status === 'complete'
           || (state.status === 'idle' && state.lastResult !== undefined);

         // Progressive tree build: only show nodes that have been spawned
         // Triage always visible (root). Others visible once SSE fires agent-started.
         // After orchestrator completes, show ALL domain agents (muted unchosen ones)
         const shouldShow = determineNodeVisibility(type, agentStates);
         if (!shouldShow) return;

         rfNodes.push({
           id: type,
           type: 'decision',
           position: { x: 0, y: 0 }, // dagre will set
           data: {
             agentType: type,
             agentState: state,
             isChosen,
             isSelected: selectedAgent === type,
             onNodeClick: (agentType: AgentType) => setSelectedAgent(agentType),
           },
         });
       });

       // Build edges from connections (only for visible nodes)
       connections.forEach((conn) => {
         const sourceVisible = rfNodes.some(n => n.id === conn.source);
         const targetVisible = rfNodes.some(n => n.id === conn.target);
         if (!sourceVisible || !targetVisible) return;

         const sourceState = agentStates.get(conn.source);
         const targetState = agentStates.get(conn.target);
         const isChosen = /* source is active/complete AND target is active/complete */ ...;
         const isProcessing = targetState?.status === 'processing';

         rfEdges.push({
           id: `edge-${conn.source}-${conn.target}`,
           source: conn.source,
           target: conn.target,
           type: 'smoothstep',
           animated: isChosen || isProcessing,
           style: isChosen || isProcessing
             ? {
                 stroke: 'hsl(var(--cc-accent))',
                 strokeWidth: 3,
                 filter: 'drop-shadow(0 0 6px hsl(var(--cc-accent) / 0.6))',
               }
             : {
                 stroke: 'hsl(0 0% 50% / 0.3)',
                 strokeWidth: 1,
               },
         });
       });

       // Apply dagre layout
       return getLayoutedElements(rfNodes, rfEdges);
     }, [agentStates, connections, selectedAgent]);
     ```

  4. **Progressive tree build logic (`determineNodeVisibility`):**

     Per CONTEXT.md: "Progressive tree build: Tree starts with only the triage node. As SSE events fire, new nodes animate into existence."

     ```typescript
     function determineNodeVisibility(
       type: AgentType,
       states: Map<AgentType, AgentState>,
     ): boolean {
       // Triage is always visible (root node)
       if (type === 'triage') return true;

       const state = states.get(type);
       if (!state) return false;

       // If this agent has ever been active, show it
       if (state.status !== 'idle') return true;
       if (state.lastResult !== undefined) return true;
       if (state.processingHistory.length > 0) return true;

       // Orchestrator: visible once triage completes
       if (type === 'orchestrator') {
         const triageState = states.get('triage');
         return triageState?.status === 'complete' ||
                triageState?.lastResult !== undefined ||
                triageState?.status === 'idle' && triageState?.processingHistory.length > 0;
       }

       // Domain agents + KG: visible once orchestrator completes
       // (shows all domain agents, chosen ones highlighted, unchosen muted)
       const orchState = states.get('orchestrator');
       if (orchState?.status === 'complete' || orchState?.lastResult !== undefined ||
           (orchState?.status === 'idle' && orchState?.processingHistory.length > 0)) {
         return true;
       }

       return false;
     }
     ```

  5. **Replace the sidebar integration:**
     Remove the old `AgentDetailsPanel` usage. Use `NodeDetailsSidebar` instead:
     ```tsx
     <NodeDetailsSidebar
       isOpen={selectedAgent !== null}
       agentType={selectedAgent}
       agentState={selectedAgent ? agentStates.get(selectedAgent) ?? null : null}
       onClose={() => setSelectedAgent(null)}
     />
     ```
     The sidebar is rendered within the command-center-scope container, positioned absolutely.

  6. **Canvas layout:**
     Remove the old flexbox split between canvas and panel. The canvas takes full width. The sidebar overlays on top (absolute positioning).
     ```tsx
     <div className="flex-1 relative overflow-hidden min-h-0">
       <AgentFlowCanvas
         nodes={nodes}
         edges={edges}
         onNodeClick={(nodeId) => setSelectedAgent(nodeId as AgentType)}
         selectedNodeId={selectedAgent}
       />
       <NodeDetailsSidebar
         isOpen={selectedAgent !== null}
         agentType={selectedAgent}
         agentState={selectedAgent ? agentStates.get(selectedAgent) ?? null : null}
         onClose={() => setSelectedAgent(null)}
       />
     </div>
     ```

  7. **SSE event handlers:**
     Keep ALL existing SSE event handlers (handleAgentStarted, handleAgentComplete, handleAgentError, handleProcessingComplete). The SSE hook integration is preserved exactly. The only change is that agent state updates now trigger the `useMemo` to recompute ReactFlow nodes/edges, which renders the progressive tree.

  8. **Header and footer:**
     Keep the existing header (title, connection status indicator) and footer (processing status, last summary). These are unchanged.

  9. **Handle node click from ReactFlow:**
     When a node is clicked in the canvas, `onNodeClick` fires with the node ID (which is the AgentType string). Set `selectedAgent` to that type, which opens the sidebar.

  **Update `index.ts` barrel exports:**
  - Remove `AgentNode` export (replaced by DecisionNode)
  - Remove `AgentDetailsPanel` export (replaced by NodeDetailsSidebar)
  - Add `DecisionNode` export
  - Add `NodeDetailsSidebar` export
  - Keep `CommandCenter` and `AgentFlowCanvas` exports

  ```typescript
  export { CommandCenter } from "./CommandCenter";
  export { AgentFlowCanvas } from "./AgentFlowCanvas";
  export { DecisionNode } from "./DecisionNode";
  export { NodeDetailsSidebar } from "./NodeDetailsSidebar";
  ```

  **Files that are now DEAD CODE (but do NOT delete in this plan):**
  - `AgentNode.tsx` -- the old SVG node, no longer imported. Leave it in the directory; user can clean up later.
  - `AgentDetailsPanel.tsx` -- the old inline panel, no longer imported. Leave it.

  **Anti-patterns to avoid:**
  - Do NOT store ReactFlow nodes/edges as separate state. Derive them via `useMemo` from agentStates.
  - Do NOT modify `useCommandCenterSSE.ts` or `command-center.ts` types.
  - Do NOT add ReactFlowProvider at the page level.
  - Do NOT use `any` types.
  </action>
  <verify>
  - `CommandCenter.tsx` wraps content in `ReactFlowProvider`
  - `CommandCenter.tsx` has `command-center-scope` class on outer div
  - `CommandCenter.tsx` derives ReactFlow nodes/edges via `useMemo` + `getLayoutedElements`
  - Progressive tree build: triage always visible, others appear based on SSE state
  - Edge styling: chosen edges have teal glow, unchosen edges are muted
  - `NodeDetailsSidebar` integrated with absolute positioning
  - SSE hook still connected and functioning
  - `index.ts` exports updated (DecisionNode + NodeDetailsSidebar)
  - `cd frontend && bun run build` passes with NO TypeScript errors
  - `cd frontend && bun run lint` passes (or only has pre-existing warnings)
  </verify>
  <done>
  CommandCenter fully integrated with ReactFlowProvider, dagre layout, progressive tree build from SSE events, animated edge styling, NodeDetailsSidebar, and preserved SSE integration. Old D3 canvas replaced.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete Agent Decision Tree revamp:
  1. ReactFlow + dagre hierarchical layout replacing D3 SVG canvas
  2. DecisionNode with motion animations (entrance, floating, hover, pulsing border)
  3. Smoothstep edges with teal glow on chosen path
  4. Spring-animated NodeDetailsSidebar with color-coded sections
  5. Progressive tree build from SSE events
  6. Portal tooltip on node hover
  7. Dark canvas with dot grid background
  8. Auto-fit viewport
  </what-built>
  <how-to-verify>
  1. Start the frontend dev server: `cd frontend && bun run dev`
  2. Navigate to a case's Command Center page (e.g., `/cases/[id]/command-center`)
  3. **Visual checks:**
     - Canvas should have dark background (#111111) with subtle dot grid
     - Triage node should be visible at the top (initial state)
     - Nodes should have rounded corners, ~300px wide
     - If in demo mode (no SSE), all nodes should appear (check the mock data fallback)
  4. **Interaction checks:**
     - Hover any node: should scale up slightly (1.05x), lift -8px, tooltip appears above saying "Click for more details"
     - Click any node: sidebar should slide in from the right with spring animation
     - Click the X or click elsewhere: sidebar should slide out
     - Pan the canvas by click-dragging on empty space
     - Zoom with scroll wheel
     - Nodes should NOT be draggable
  5. **Sidebar checks:**
     - Sidebar shows agent name, description, status badge, model
     - Sections are collapsible (click to expand/collapse)
     - Close button works
  6. **Edge checks:**
     - Edges should be smoothstep (right-angle rounded corners), not straight lines
     - If any agents are active/complete, their edges should be teal with glow
     - Inactive edges should be muted gray
  7. **No regressions:**
     - Connection status indicator (Connected/Reconnecting/Demo Mode) still visible in header
     - Footer shows processing status or "Idle"
  </how-to-verify>
  <resume-signal>Type "approved" or describe any visual issues to fix</resume-signal>
</task>

</tasks>

<verification>
- Complete decision tree renders with dagre hierarchical layout
- Nodes animate in progressively based on SSE state
- Smoothstep edges with teal glow on active path
- Sidebar opens/closes with spring animation
- Canvas pan/zoom works, nodes not draggable
- Auto-fit viewport on node count change
- All existing SSE integration preserved
- `bun run build` passes
- No TypeScript errors
</verification>

<success_criteria>
- D3 canvas fully replaced by ReactFlow + dagre
- DecisionNode animations match reference guide spec
- Edge styling: teal glow on chosen path, muted gray on unchosen
- Sidebar: spring animation, color-coded sections, agent-type-specific content
- Progressive tree build: starts with triage, expands as SSE events arrive
- Unchosen domain agents appear muted after orchestrator completes
- No regressions to SSE event handling or connection status display
- User visually verifies the decision tree looks correct
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-agent-decision-tree-revamp/04.1-03-SUMMARY.md`
</output>
