---
phase: 04.1-agent-decision-tree-revamp
plan: 03
type: execute
wave: 2
depends_on: ["04.1-01", "04.1-02"]
files_modified:
  - frontend/src/components/CommandCenter/AgentFlowCanvas.tsx
  - frontend/src/components/CommandCenter/FileGroupNode.tsx
  - frontend/src/components/CommandCenter/CommandCenter.tsx
  - frontend/src/components/CommandCenter/index.ts
autonomous: false

must_haves:
  truths:
    - "Agent tree renders with dagre hierarchical layout (top-to-bottom)"
    - "Nodes animate into existence progressively as SSE events arrive"
    - "Smoothstep edges animate along chosen path with teal glow"
    - "Clicking any node opens the spring-animated sidebar"
    - "Canvas has dark background with dot grid pattern"
    - "Viewport auto-fits all nodes and stays zoomed to show full tree"
    - "Pan/zoom works, nodes are not draggable"
    - "All existing SSE events and agent state management still functional"
    - "Unchosen domain agents appear muted after orchestrator completes"
    - "File group intermediate nodes render between orchestrator and domain agents"
  artifacts:
    - path: "frontend/src/components/CommandCenter/AgentFlowCanvas.tsx"
      provides: "ReactFlow canvas with dagre layout, edge styling, auto-fit"
      min_lines: 100
    - path: "frontend/src/components/CommandCenter/FileGroupNode.tsx"
      provides: "Custom ReactFlow node for file group intermediate layer"
      min_lines: 40
    - path: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      provides: "Main container with ReactFlowProvider, progressive tree build, sidebar integration"
      min_lines: 150
    - path: "frontend/src/components/CommandCenter/index.ts"
      provides: "Updated barrel exports"
  key_links:
    - from: "frontend/src/components/CommandCenter/AgentFlowCanvas.tsx"
      to: "frontend/src/components/CommandCenter/DecisionNode.tsx"
      via: "nodeTypes registration"
      pattern: "nodeTypes.*decision.*DecisionNode"
    - from: "frontend/src/components/CommandCenter/AgentFlowCanvas.tsx"
      to: "frontend/src/components/CommandCenter/FileGroupNode.tsx"
      via: "nodeTypes registration for file group nodes"
      pattern: "nodeTypes.*fileGroup.*FileGroupNode"
    - from: "frontend/src/components/CommandCenter/AgentFlowCanvas.tsx"
      to: "@dagrejs/dagre"
      via: "dagre layout computation"
      pattern: "dagre\\.layout"
    - from: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      to: "@xyflow/react"
      via: "ReactFlowProvider wrapping"
      pattern: "ReactFlowProvider"
    - from: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      to: "frontend/src/components/CommandCenter/NodeDetailsSidebar.tsx"
      via: "sidebar integration with selected node state"
      pattern: "NodeDetailsSidebar"
    - from: "frontend/src/components/CommandCenter/CommandCenter.tsx"
      to: "frontend/src/hooks/useCommandCenterSSE.ts"
      via: "SSE events driving progressive tree build"
      pattern: "useCommandCenterSSE"
---

<objective>
Rewrite AgentFlowCanvas.tsx as a ReactFlow + dagre canvas, create FileGroupNode for intermediate file group layer, update CommandCenter.tsx with ReactFlowProvider wrapping and progressive tree build from SSE events (including file group nodes from orchestrator output), integrate NodeDetailsSidebar, and update barrel exports.

Purpose: This is the integration plan that brings together the DecisionNode (Plan 01), FileGroupNode (this plan), and NodeDetailsSidebar (Plan 02) into a working decision tree visualization. It replaces the D3-based canvas with ReactFlow, implements dagre auto-layout, edge styling, progressive tree building from SSE events, file group intermediate nodes, and the complete user interaction flow.

Output: Fully functional Command Center with ReactFlow decision tree, dagre layout, animated edges, progressive SSE-driven node appearance, file group intermediate nodes, sidebar integration, and visual verification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-CONTEXT.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-RESEARCH.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-01-SUMMARY.md
@.planning/phases/04.1-agent-decision-tree-revamp/04.1-02-SUMMARY.md
@DOCS/UI/agent-decision-tree-guide.md
@frontend/src/types/command-center.ts
@frontend/src/hooks/useCommandCenterSSE.ts
@frontend/src/components/CommandCenter/AgentFlowCanvas.tsx
@frontend/src/components/CommandCenter/CommandCenter.tsx
@frontend/src/components/CommandCenter/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite AgentFlowCanvas with ReactFlow + dagre and create FileGroupNode</name>
  <files>
    frontend/src/components/CommandCenter/AgentFlowCanvas.tsx
    frontend/src/components/CommandCenter/FileGroupNode.tsx
  </files>
  <action>
  **Part A: Create `FileGroupNode.tsx`.**

  This is a custom ReactFlow node for file group intermediate nodes that render between the orchestrator and domain agents. Per CONTEXT.md decision #3: "Orchestrator's `file_groups` output renders as intermediate nodes between orchestrator and domain agents."

  The backend `OrchestratorOutput` schema (`backend/app/schemas/agent.py`) has:
  ```python
  class FileGroupForProcessing(BaseModel):
      group_id: str
      file_ids: list[str]
      target_agents: list[str]
      shared_context: str
  ```

  This data is available on the frontend via `agentState.lastResult` for the orchestrator agent, specifically in `agentState.lastResult?.metadata?.file_groups` or `agentState.lastResult?.outputs`.

  **FileGroupNode data interface:**
  ```typescript
  interface FileGroupNodeData {
    groupId: string;
    groupName: string;        // Derived from shared_context or group_id
    fileCount: number;        // file_ids.length
    sharedContext: string;    // The shared_context string
    targetAgents: string[];   // Target agent types
    isActive: boolean;        // Whether any target agent is processing/complete
    onNodeClick: (groupId: string) => void;
  }
  ```

  **Visual design (per CONTEXT.md: "Node face shows group name + file count"):**
  - Slightly smaller than DecisionNode: `w-[240px] h-[80px]` (use constants `FILE_GROUP_NODE_WIDTH = 240`, `FILE_GROUP_NODE_HEIGHT = 80` -- export these from config or define in the file)
  - Rounded corners (`rounded-lg`)
  - ReactFlow `<Handle>` top (target) and bottom (source)
  - Face content: group name (bold, `text-sm`), file count badge (e.g., "3 files"), small tag showing target agents
  - **Active style:** Subtle teal border, slightly lifted background. Less prominent than DecisionNode chosen style.
  - **Inactive style:** Same muted charcoal as unchosen DecisionNodes
  - Use `motion/react` for entrance animation (`scale: 0.9 -> 1, opacity: 0 -> 1`)
  - No floating animation (reserved for agent nodes)

  **Part B: COMPLETE REWRITE of `AgentFlowCanvas.tsx`.**

  Replace the entire D3-based SVG canvas with a ReactFlow + dagre implementation.

  **Imports:**
  ```typescript
  import { ReactFlow, Background, ConnectionLineType, useReactFlow, type Node, type Edge } from '@xyflow/react';
  import '@xyflow/react/dist/style.css';
  import dagre from '@dagrejs/dagre';
  ```

  **Props interface (keep compatible with CommandCenter):**
  ```typescript
  interface AgentFlowCanvasProps {
    nodes: Node[];       // Pre-computed by CommandCenter
    edges: Edge[];       // Pre-computed by CommandCenter
    onNodeClick: (nodeId: string) => void;
    selectedNodeId: string | null;
  }
  ```

  NOTE: The props interface CHANGES from the current one. The current canvas receives `agentStates`, `connections`, `onAgentClick`, `selectedAgent`. The new canvas receives pre-computed ReactFlow `Node[]` and `Edge[]` from CommandCenter.tsx (which handles the data transformation). This is cleaner separation -- canvas is pure rendering, CommandCenter handles data.

  **nodeTypes constant (OUTSIDE the component):**
  ```typescript
  import { DecisionNode } from './DecisionNode';
  import { FileGroupNode } from './FileGroupNode';
  const nodeTypes = { decision: DecisionNode, fileGroup: FileGroupNode } as const;
  ```
  This MUST be outside the component body to avoid infinite re-renders (RESEARCH pitfall #1).

  **Component body:**

  1. Use `useReactFlow()` to access the instance for fitView.

  2. **Auto-fit viewport** when nodes change:
     ```typescript
     useEffect(() => {
       if (nodes.length > 0) {
         const timer = setTimeout(() => {
           reactFlowInstance.fitView({
             duration: 1500,
             padding: 0.2,
             minZoom: 0.1,
             maxZoom: 1,
           });
         }, 100); // Small delay to let nodes render
         return () => clearTimeout(timer);
       }
     }, [nodes.length, reactFlowInstance]);
     ```
     Per CONTEXT.md: "Viewport: stay zoomed to fit all". Re-fit when nodes.length changes (progressive build adds nodes). Do NOT auto-pan when individual agents activate -- only when new nodes appear.

  3. **ReactFlow configuration:**
     ```tsx
     <ReactFlow
       nodes={nodes}
       edges={edges}
       nodeTypes={nodeTypes}
       connectionLineType={ConnectionLineType.SmoothStep}
       nodesDraggable={false}
       nodesConnectable={false}
       elementsSelectable={false}
       panOnDrag={true}
       zoomOnScroll={true}
       minZoom={0.1}
       maxZoom={2}
       onNodeClick={(_, node) => onNodeClick(node.id)}
       fitView
       proOptions={{ hideAttribution: true }}
     >
       <Background
         gap={20}
         size={2}
         color="rgba(138, 138, 130, 0.15)"
       />
     </ReactFlow>
     ```

  4. **Canvas container styling:**
     - Full width/height: `w-full h-full`
     - Background color: `var(--color-jet)` (#111111) per CONTEXT.md decision
     - The ReactFlow `<Background>` component provides the dot grid

  5. **Remove ALL D3 imports** (d3-selection, d3-zoom). Remove all D3 zoom/pan logic, SVG rendering, manual path calculation, manual drag handling. The entire D3 approach is replaced by ReactFlow.

  6. **Remove the manual zoom control buttons** (ZoomIn, ZoomOut, RotateCcw, Maximize2). ReactFlow has its own controls, and the canvas spec in CONTEXT.md does not require custom zoom buttons.

  **Dagre layout helper function** (can be in the same file or a separate utility, use judgment):

  Export a `getLayoutedElements` function:
  ```typescript
  export function getLayoutedElements(
    nodes: Node[],
    edges: Edge[],
  ): { nodes: Node[]; edges: Edge[] } {
    const g = new dagre.graphlib.Graph().setDefaultEdgeLabel(() => ({}));

    g.setGraph({
      rankdir: 'TB',
      ranksep: 120,
      nodesep: 150,
    });

    nodes.forEach((node) => {
      // Use different dimensions for file group nodes vs decision nodes
      const isFileGroup = node.type === 'fileGroup';
      const width = isFileGroup ? FILE_GROUP_NODE_WIDTH : NODE_WIDTH;
      const height = isFileGroup ? FILE_GROUP_NODE_HEIGHT : NODE_HEIGHT;
      g.setNode(node.id, { width, height });
    });

    edges.forEach((edge) => {
      g.setEdge(edge.source, edge.target);
    });

    dagre.layout(g);

    const layoutedNodes = nodes.map((node) => {
      const dagreNode = g.node(node.id);
      const isFileGroup = node.type === 'fileGroup';
      const width = isFileGroup ? FILE_GROUP_NODE_WIDTH : NODE_WIDTH;
      const height = isFileGroup ? FILE_GROUP_NODE_HEIGHT : NODE_HEIGHT;
      return {
        ...node,
        position: {
          x: dagreNode.x - width / 2,
          y: dagreNode.y - height / 2,
        },
      };
    });

    return { nodes: layoutedNodes, edges };
  }
  ```

  Import `NODE_WIDTH`, `NODE_HEIGHT` from `command-center-config.ts`. Use `FILE_GROUP_NODE_WIDTH = 240` and `FILE_GROUP_NODE_HEIGHT = 80` (define alongside node dimension constants in config or locally).

  **IMPORTANT per RESEARCH pitfall #6:** Create a new dagre Graph instance each time OR clear previous nodes before recomputing. Do NOT reuse a module-level graph instance across calls.

  **Anti-patterns to avoid:**
  - Do NOT define `nodeTypes` inside the component
  - Do NOT use `useNodesState`/`useEdgesState` (we derive from data, not user-editable)
  - Do NOT import any D3 libraries
  - Do NOT animate width/height on nodes
  </action>
  <verify>
  - `FileGroupNode.tsx` exists with 40+ lines and proper data interface
  - `FileGroupNode.tsx` uses `motion/react` for entrance animation
  - `AgentFlowCanvas.tsx` imports from `@xyflow/react` and `@dagrejs/dagre`
  - No D3 imports remain in AgentFlowCanvas
  - `nodeTypes` defined outside component body, includes both `decision` and `fileGroup`
  - `getLayoutedElements` function handles both node types with different dimensions
  - ReactFlow configured with `nodesDraggable={false}`, `fitView`, `SmoothStep`
  - `cd frontend && bun run build` passes
  </verify>
  <done>
  AgentFlowCanvas completely rewritten from D3 SVG to ReactFlow + dagre. FileGroupNode created for intermediate file group layer. Auto-layout handles both node types, smoothstep edges, auto-fit viewport, dot grid background, and no-drag/pan-zoom configuration all working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CommandCenter.tsx with ReactFlowProvider, file group nodes, and progressive tree build</name>
  <files>
    frontend/src/components/CommandCenter/CommandCenter.tsx
    frontend/src/components/CommandCenter/index.ts
  </files>
  <action>
  **REWRITE `CommandCenter.tsx`** to integrate all new components.

  **Key changes:**

  1. **ReactFlowProvider wrapping:**
     Wrap the inner content in `ReactFlowProvider` at the CommandCenter level (NOT the page level):
     ```tsx
     import { ReactFlowProvider } from '@xyflow/react';

     export function CommandCenter({ caseId, className }: CommandCenterProps) {
       return (
         <ReactFlowProvider>
           <CommandCenterInner caseId={caseId} className={className} />
         </ReactFlowProvider>
       );
     }
     ```
     The inner component uses `useReactFlow()` internally via the canvas.

  2. **Add `command-center-scope` class** to the outermost container div so that the scoped CSS variables from globals.css are available to all child components.

  3. **Data transformation pipeline (agentStates -> ReactFlow nodes/edges):**

     Use `useMemo` to derive ReactFlow `Node[]` and `Edge[]` from `agentStates` and `connections`:

     ```typescript
     const { nodes, edges } = useMemo(() => {
       const rfNodes: Node[] = [];
       const rfEdges: Edge[] = [];

       agentStates.forEach((state, type) => {
         const isChosen = state.status === 'processing' || state.status === 'complete'
           || (state.status === 'idle' && state.lastResult !== undefined);

         // Progressive tree build: only show nodes that have been spawned
         const shouldShow = determineNodeVisibility(type, agentStates);
         if (!shouldShow) return;

         rfNodes.push({
           id: type,
           type: 'decision',
           position: { x: 0, y: 0 }, // dagre will set
           data: {
             agentType: type,
             agentState: state,
             isChosen,
             isSelected: selectedAgent === type,
             onNodeClick: (agentType: AgentType) => setSelectedAgent(agentType),
           },
         });
       });

       // --- FILE GROUP NODES ---
       // Extract file groups from orchestrator's lastResult
       const orchState = agentStates.get('orchestrator');
       if (orchState?.lastResult) {
         // File groups may be in metadata.file_groups or in outputs
         const fileGroups = extractFileGroups(orchState.lastResult);

         fileGroups.forEach((group) => {
           const isActive = group.targetAgents.some((agentId) => {
             const agentState = agentStates.get(agentId as AgentType);
             return agentState?.status === 'processing' || agentState?.status === 'complete';
           });

           rfNodes.push({
             id: `file-group-${group.groupId}`,
             type: 'fileGroup',
             position: { x: 0, y: 0 }, // dagre will set
             data: {
               groupId: group.groupId,
               groupName: group.groupName,
               fileCount: group.fileCount,
               sharedContext: group.sharedContext,
               targetAgents: group.targetAgents,
               isActive,
               onNodeClick: (groupId: string) => setSelectedAgent(null), // or handle file group click
             },
           },
           });
         });
       }

       // --- EDGES ---
       // Build edges from connections (only for visible nodes)
       // When file group nodes exist, route edges through them:
       //   orchestrator -> file-group-X -> target-agent
       // When no file groups, use direct connections:
       //   orchestrator -> target-agent
       const fileGroupNodes = rfNodes.filter(n => n.type === 'fileGroup');

       connections.forEach((conn) => {
         const sourceVisible = rfNodes.some(n => n.id === conn.source);
         const targetVisible = rfNodes.some(n => n.id === conn.target);
         if (!sourceVisible || !targetVisible) return;

         const sourceState = agentStates.get(conn.source as AgentType);
         const targetState = agentStates.get(conn.target as AgentType);

         // Determine if edge is on the chosen/active path
         const sourceIsActive = sourceState?.status === 'processing' || sourceState?.status === 'complete'
           || (sourceState?.status === 'idle' && sourceState?.lastResult !== undefined);
         const targetIsActive = targetState?.status === 'processing' || targetState?.status === 'complete'
           || (targetState?.status === 'idle' && targetState?.lastResult !== undefined);
         const isChosen = sourceIsActive && targetIsActive;
         const isProcessing = targetState?.status === 'processing';

         // Check if file group nodes should intercept this edge
         // (orchestrator -> domain agent edges become orchestrator -> file-group -> domain agent)
         if (conn.source === 'orchestrator' && fileGroupNodes.length > 0) {
           // Find file groups that target this agent
           const matchingGroups = fileGroupNodes.filter(fgNode => {
             const fgData = fgNode.data as { targetAgents: string[] };
             return fgData.targetAgents.includes(conn.target);
           });

           if (matchingGroups.length > 0) {
             // Route through file group nodes instead of direct connection
             matchingGroups.forEach((fgNode) => {
               // Edge: orchestrator -> file group
               if (!rfEdges.some(e => e.source === conn.source && e.target === fgNode.id)) {
                 rfEdges.push(buildEdge(conn.source, fgNode.id, sourceIsActive, false));
               }
               // Edge: file group -> target agent
               rfEdges.push(buildEdge(fgNode.id, conn.target, isChosen, isProcessing));
             });
             return; // Skip the direct edge
           }
         }

         // Direct edge (no file group interception)
         rfEdges.push(buildEdge(conn.source, conn.target, isChosen, isProcessing));
       });

       // Apply dagre layout
       return getLayoutedElements(rfNodes, rfEdges);
     }, [agentStates, connections, selectedAgent]);
     ```

  **Helper: `buildEdge` function:**
  ```typescript
  function buildEdge(
    sourceId: string,
    targetId: string,
    isChosen: boolean,
    isProcessing: boolean,
  ): Edge {
    return {
      id: `edge-${sourceId}-${targetId}`,
      source: sourceId,
      target: targetId,
      type: 'smoothstep',
      animated: isChosen || isProcessing,
      style: isChosen || isProcessing
        ? {
            stroke: 'hsl(var(--cc-accent))',
            strokeWidth: 3,
            filter: 'drop-shadow(0 0 6px hsl(var(--cc-accent) / 0.6))',
          }
        : {
            stroke: 'hsl(0 0% 50% / 0.3)',
            strokeWidth: 1,
          },
    };
  }
  ```

  **Helper: `extractFileGroups` function:**
  ```typescript
  interface FileGroupData {
    groupId: string;
    groupName: string;
    fileCount: number;
    sharedContext: string;
    targetAgents: string[];
  }

  function extractFileGroups(result: AgentResult): FileGroupData[] {
    // Try metadata.file_groups first (backend OrchestratorOutput.file_groups)
    const rawGroups = (result.metadata?.file_groups as Array<{
      group_id: string;
      file_ids: string[];
      target_agents: string[];
      shared_context: string;
    }>) ?? [];

    return rawGroups.map((g) => ({
      groupId: g.group_id,
      groupName: g.shared_context.slice(0, 40) || g.group_id, // Use shared_context as name, truncated
      fileCount: g.file_ids.length,
      sharedContext: g.shared_context,
      targetAgents: g.target_agents,
    }));
  }
  ```

  4. **Progressive tree build logic (`determineNodeVisibility`):**

     Per CONTEXT.md: "Progressive tree build: Tree starts with only the triage node. As SSE events fire, new nodes animate into existence."

     ```typescript
     function determineNodeVisibility(
       type: AgentType,
       states: Map<AgentType, AgentState>,
     ): boolean {
       // Triage is always visible (root node)
       if (type === 'triage') return true;

       const state = states.get(type);
       if (!state) return false;

       // If this agent has ever been active, show it
       if (state.status !== 'idle') return true;
       if (state.lastResult !== undefined) return true;
       if (state.processingHistory.length > 0) return true;

       // Orchestrator: visible once triage completes
       if (type === 'orchestrator') {
         const triageState = states.get('triage');
         return triageState?.status === 'complete' ||
                triageState?.lastResult !== undefined ||
                (triageState?.status === 'idle' && triageState?.processingHistory.length > 0);
       }

       // Domain agents + KG: visible once orchestrator completes
       // (shows all domain agents, chosen ones highlighted, unchosen muted)
       const orchState = states.get('orchestrator');
       if (orchState?.status === 'complete' || orchState?.lastResult !== undefined ||
           (orchState?.status === 'idle' && orchState?.processingHistory.length > 0)) {
         return true;
       }

       return false;
     }
     ```

  5. **Replace the sidebar integration:**
     Remove the old `AgentDetailsPanel` usage. Use `NodeDetailsSidebar` instead:
     ```tsx
     <NodeDetailsSidebar
       isOpen={selectedAgent !== null}
       agentType={selectedAgent}
       agentState={selectedAgent ? agentStates.get(selectedAgent) ?? null : null}
       onClose={() => setSelectedAgent(null)}
     />
     ```
     The sidebar is rendered within the command-center-scope container, positioned absolutely.

  6. **Canvas layout:**
     Remove the old flexbox split between canvas and panel. The canvas takes full width. The sidebar overlays on top (absolute positioning).
     ```tsx
     <div className="flex-1 relative overflow-hidden min-h-0">
       <AgentFlowCanvas
         nodes={nodes}
         edges={edges}
         onNodeClick={(nodeId) => setSelectedAgent(nodeId as AgentType)}
         selectedNodeId={selectedAgent}
       />
       <NodeDetailsSidebar
         isOpen={selectedAgent !== null}
         agentType={selectedAgent}
         agentState={selectedAgent ? agentStates.get(selectedAgent) ?? null : null}
         onClose={() => setSelectedAgent(null)}
       />
     </div>
     ```

  7. **SSE event handlers:**
     Keep ALL existing SSE event handlers (handleAgentStarted, handleAgentComplete, handleAgentError, handleProcessingComplete). The SSE hook integration is preserved exactly. The only change is that agent state updates now trigger the `useMemo` to recompute ReactFlow nodes/edges, which renders the progressive tree.

  8. **Header and footer:**
     Keep the existing header (title, connection status indicator) and footer (processing status, last summary). These are unchanged.

  9. **Handle node click from ReactFlow:**
     When a node is clicked in the canvas, `onNodeClick` fires with the node ID (which is the AgentType string for agent nodes, or `file-group-{id}` for file group nodes). For agent nodes, set `selectedAgent` to that type, which opens the sidebar. For file group nodes, either ignore or open a minimal info display.

  **Update `index.ts` barrel exports:**
  - Remove `AgentNode` export (replaced by DecisionNode)
  - Remove `AgentDetailsPanel` export (replaced by NodeDetailsSidebar)
  - Add `DecisionNode` export
  - Add `FileGroupNode` export
  - Add `NodeDetailsSidebar` export
  - Keep `CommandCenter` and `AgentFlowCanvas` exports

  ```typescript
  export { CommandCenter } from "./CommandCenter";
  export { AgentFlowCanvas } from "./AgentFlowCanvas";
  export { DecisionNode } from "./DecisionNode";
  export { FileGroupNode } from "./FileGroupNode";
  export { NodeDetailsSidebar } from "./NodeDetailsSidebar";
  ```

  **Files that are now DEAD CODE (but do NOT delete in this plan):**
  - `AgentNode.tsx` -- the old SVG node, no longer imported. Leave it in the directory; user can clean up later.
  - `AgentDetailsPanel.tsx` -- the old inline panel, no longer imported. Leave it.

  **Anti-patterns to avoid:**
  - Do NOT store ReactFlow nodes/edges as separate state. Derive them via `useMemo` from agentStates.
  - Do NOT modify `useCommandCenterSSE.ts` or `command-center.ts` types.
  - Do NOT add ReactFlowProvider at the page level.
  - Do NOT use `any` types.
  </action>
  <verify>
  - `CommandCenter.tsx` wraps content in `ReactFlowProvider`
  - `CommandCenter.tsx` has `command-center-scope` class on outer div
  - `CommandCenter.tsx` derives ReactFlow nodes/edges via `useMemo` + `getLayoutedElements`
  - `CommandCenter.tsx` has `extractFileGroups` function that reads orchestrator's `lastResult.metadata.file_groups`
  - File group nodes are created when orchestrator has file_groups data
  - Edges route through file group nodes when they exist (orchestrator -> file-group -> domain-agent)
  - Progressive tree build: triage always visible, others appear based on SSE state
  - Edge `isChosen` uses concrete boolean: `sourceIsActive && targetIsActive` (not a comment placeholder)
  - Edge styling: chosen edges have teal glow, unchosen edges are muted
  - `NodeDetailsSidebar` integrated with absolute positioning
  - SSE hook still connected and functioning
  - `index.ts` exports updated (DecisionNode + FileGroupNode + NodeDetailsSidebar)
  - `cd frontend && bun run build` passes with NO TypeScript errors
  - `cd frontend && bun run lint` passes (or only has pre-existing warnings)
  </verify>
  <done>
  CommandCenter fully integrated with ReactFlowProvider, dagre layout, progressive tree build from SSE events, file group intermediate nodes from orchestrator output, animated edge styling with concrete isChosen logic, NodeDetailsSidebar, and preserved SSE integration. Old D3 canvas replaced.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete Agent Decision Tree revamp:
  1. ReactFlow + dagre hierarchical layout replacing D3 SVG canvas
  2. DecisionNode with motion animations (entrance, floating, hover, pulsing border)
  3. FileGroupNode intermediate nodes between orchestrator and domain agents
  4. Smoothstep edges with teal glow on chosen path
  5. Spring-animated NodeDetailsSidebar with color-coded sections
  6. Progressive tree build from SSE events
  7. Portal tooltip on node hover
  8. Dark canvas with dot grid background
  9. Auto-fit viewport
  </what-built>
  <how-to-verify>
  1. Start the frontend dev server: `cd frontend && bun run dev`
  2. Navigate to a case's Command Center page (e.g., `/cases/[id]/command-center`)
  3. **Visual checks:**
     - Canvas should have dark background (#111111) with subtle dot grid
     - Triage node should be visible at the top (initial state)
     - Nodes should have rounded corners, ~300px wide
     - If in demo mode (no SSE), all nodes should appear (check the mock data fallback)
     - If orchestrator has file_groups data, intermediate file group nodes should appear between orchestrator and domain agents
  4. **Interaction checks:**
     - Hover any node: should scale up slightly (1.05x), lift -8px, tooltip appears above saying "Click for more details"
     - Click any node: sidebar should slide in from the right with spring animation
     - Click the X or click elsewhere: sidebar should slide out
     - Pan the canvas by click-dragging on empty space
     - Zoom with scroll wheel
     - Nodes should NOT be draggable
  5. **Sidebar checks:**
     - Sidebar shows agent name, description, status badge, model
     - Sections are collapsible (click to expand/collapse)
     - Close button works
  6. **Edge checks:**
     - Edges should be smoothstep (right-angle rounded corners), not straight lines
     - If any agents are active/complete, their edges should be teal with glow
     - Inactive edges should be muted gray
  7. **No regressions:**
     - Connection status indicator (Connected/Reconnecting/Demo Mode) still visible in header
     - Footer shows processing status or "Idle"
  </how-to-verify>
  <resume-signal>Type "approved" or describe any visual issues to fix</resume-signal>
</task>

</tasks>

<verification>
- Complete decision tree renders with dagre hierarchical layout
- Nodes animate in progressively based on SSE state
- File group intermediate nodes appear when orchestrator has file_groups data
- Smoothstep edges with teal glow on active path
- Edges route through file group nodes when present
- Sidebar opens/closes with spring animation
- Canvas pan/zoom works, nodes not draggable
- Auto-fit viewport on node count change
- All existing SSE integration preserved
- `bun run build` passes
- No TypeScript errors
</verification>

<success_criteria>
- D3 canvas fully replaced by ReactFlow + dagre
- DecisionNode animations match reference guide spec
- FileGroupNode renders between orchestrator and domain agents showing group name + file count
- Edge styling: teal glow on chosen path, muted gray on unchosen
- Edges route through file group nodes when orchestrator provides file_groups data
- Sidebar: spring animation, color-coded sections, agent-type-specific content
- Progressive tree build: starts with triage, expands as SSE events arrive
- Unchosen domain agents appear muted after orchestrator completes
- No regressions to SSE event handling or connection status display
- User visually verifies the decision tree looks correct
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-agent-decision-tree-revamp/04.1-03-SUMMARY.md`
</output>
