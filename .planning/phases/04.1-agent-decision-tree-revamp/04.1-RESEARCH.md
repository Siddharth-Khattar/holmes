# Phase 4.1: Agent Decision Tree Revamp - Research

**Researched:** 2026-02-03
**Domain:** React Flow graph visualization, dagre layout, motion animations, SSE-driven state
**Confidence:** HIGH

## Summary

This phase replaces the current D3-based SVG canvas (`AgentFlowCanvas.tsx`) with a `@xyflow/react` + `@dagrejs/dagre` powered decision tree. The existing implementation uses raw D3 zoom/pan on an SVG with manually positioned rectangular nodes rendered as `<g>` elements. The new implementation uses React Flow's declarative component model with custom `DecisionNode` components, automatic dagre layout, smoothstep edges, portal tooltips, and a spring-animated sidebar.

The codebase already has `motion` v12.29.0 installed (imported as `motion/react`), `lucide-react`, and Tailwind CSS v4 with a custom Holmes design system. The new libraries needed are `@xyflow/react` (v12.10.0) and `@dagrejs/dagre` (v2.0.3, ships own TS types â€” no `@types/dagre` needed). The existing D3 dependencies (`d3-selection`, `d3-zoom`, etc.) can be removed from the Command Center components but may still be used elsewhere in the codebase.

The key architectural change is moving from imperative D3 SVG rendering to React Flow's declarative model. The existing types (`command-center.ts`), SSE hook (`useCommandCenterSSE.ts`), validation (`command-center-validation.ts`), and mock data (`mock-command-center-data.ts`) are preserved. The Command Center component needs to wrap its content in `ReactFlowProvider` and transform the existing `AgentState` / `AgentConnection` data into React Flow `Node[]` and `Edge[]` arrays.

**Primary recommendation:** Install `@xyflow/react` and `@dagrejs/dagre` (v2.0.3 ships own types). Rewrite `AgentFlowCanvas.tsx` as the main React Flow container, `AgentNode.tsx` as a custom `DecisionNode`, and `AgentDetailsPanel.tsx` as a spring-animated sidebar. Add scoped teal CSS variables in `globals.css`. Wrap in `ReactFlowProvider` at the `CommandCenter.tsx` level.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `@xyflow/react` | 12.10.0 | Node-based graph rendering (nodes, edges, pan, zoom, fit) | Official React Flow v12; the de-facto standard for node-based UIs in React |
| `@dagrejs/dagre` | 2.0.3 | Automatic hierarchical (TB) graph layout | Actively maintained fork of dagre; official React Flow docs use it for tree layouts; v2 ships own TS types |
| `motion` | 12.29.0 (already installed) | Node entrance, floating, hover, pulse, sidebar spring animations | Already in codebase as `motion/react`; the guide specifies framer-motion patterns |
| `lucide-react` | 0.563.0 (already installed) | Icons for UI elements (close, expand, warning, spinner) | Already in codebase |
| `tailwindcss` | v4 (already installed) | Utility-first styling | Already in codebase with Holmes design system |

### Not Needed
| Library | Reason |
|---------|--------|
| `@types/dagre` | `@dagrejs/dagre` v2.0.3 ships its own TypeScript definitions (`dagre.d.ts`). No separate types package needed. |
| `@radix-ui/react-collapsible` | Guide lists as optional; existing codebase already implements collapsible sections with manual state (see `AgentDetailsPanel.tsx`). Use the same pattern. |
| `dagre` (original, v0.8.5) | Unmaintained for 6+ years. Use `@dagrejs/dagre` instead. |
| `reactflow` (old package name) | Renamed to `@xyflow/react` in v12. Use the new package. |

### D3 Dependencies Status
The existing codebase has `d3-selection`, `d3-zoom`, `d3-drag`, `d3-force`, `d3-transition` installed. After this phase, the Command Center components will no longer use any D3 packages. However, other parts of the codebase (e.g., Knowledge Graph) may still use them -- do NOT remove from `package.json`.

**Installation:**
```bash
cd frontend && bun add @xyflow/react @dagrejs/dagre
```

## Architecture Patterns

### Current File Structure (to be rewritten)
```
frontend/src/components/CommandCenter/
  index.ts              # Barrel exports (update exports)
  CommandCenter.tsx      # Main container -- add ReactFlowProvider wrapping
  AgentFlowCanvas.tsx    # D3 SVG canvas -- REWRITE as ReactFlow container
  AgentNode.tsx          # SVG <g> node -- REWRITE as DecisionNode
  AgentDetailsPanel.tsx  # Sidebar panel -- REWRITE with spring animation

frontend/src/lib/
  command-center-config.ts  # Agent configs -- UPDATE (remove positions, add teal vars)

frontend/src/types/
  command-center.ts         # Types -- PRESERVE (no changes)

frontend/src/hooks/
  useCommandCenterSSE.ts    # SSE hook -- PRESERVE (no changes)

frontend/src/lib/
  command-center-validation.ts  # Validation -- PRESERVE
  mock-command-center-data.ts   # Mock data -- PRESERVE
```

### Pattern 1: ReactFlowProvider Wrapping
**What:** React Flow requires `ReactFlowProvider` as ancestor of any component using `useReactFlow()`.
**When to use:** Always when using React Flow hooks outside the `<ReactFlow>` component.
**Implementation:**
```tsx
// In CommandCenter.tsx (or the page-level component)
import { ReactFlowProvider } from '@xyflow/react';

export function CommandCenter({ caseId }: CommandCenterProps) {
  return (
    <ReactFlowProvider>
      <CommandCenterInner caseId={caseId} />
    </ReactFlowProvider>
  );
}
```
The `ReactFlowProvider` should wrap at the `CommandCenter.tsx` level, NOT at the page level. This keeps the provider scoped. The existing page components (`command-center/page.tsx`, `command-center-demo/page.tsx`) need NO changes.

### Pattern 2: Data Transformation Pipeline (AgentState -> ReactFlow Nodes/Edges)
**What:** Transform the existing `Map<AgentType, AgentState>` and `AgentConnection[]` into React Flow `Node[]` and `Edge[]`.
**When to use:** In the main canvas component, recomputed via `useMemo` when agent states change.
**Key insight:** The existing data model (`AgentType`, `AgentState`, `AgentConnection`) is the source of truth. The React Flow nodes/edges are a derived view. Do NOT duplicate state -- derive it.

```tsx
const { nodes, edges } = useMemo(() => {
  // 1. Build dagre graph
  // 2. Add nodes from agentStates map
  // 3. Add edges from connections array
  // 4. Run dagre.layout()
  // 5. Map to React Flow Node[] and Edge[] with computed positions
  return getLayoutedElements(agentStates, connections);
}, [agentStates, connections]);
```

### Pattern 3: Dagre Layout Function
**What:** Compute node positions using dagre's directed graph layout.
**Configuration from guide + context decisions:**
```tsx
import dagre from '@dagrejs/dagre';

const dagreGraph = new dagre.graphlib.Graph().setDefaultEdgeLabel(() => ({}));

const NODE_WIDTH = 300;
const NODE_HEIGHT = 100;

function getLayoutedElements(nodes: Node[], edges: Edge[]): { nodes: Node[]; edges: Edge[] } {
  dagreGraph.setGraph({
    rankdir: 'TB',    // top-to-bottom
    ranksep: 120,     // vertical spacing between ranks
    nodesep: 150,     // horizontal spacing between nodes
  });

  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: NODE_WIDTH, height: NODE_HEIGHT });
  });

  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  dagre.layout(dagreGraph);

  const layoutedNodes = nodes.map((node) => {
    const dagreNode = dagreGraph.node(node.id);
    // dagre gives center coordinates; React Flow uses top-left
    return {
      ...node,
      position: {
        x: dagreNode.x - NODE_WIDTH / 2,
        y: dagreNode.y - NODE_HEIGHT / 2,
      },
    };
  });

  return { nodes: layoutedNodes, edges };
}
```

### Pattern 4: Custom Node Registration
**What:** Register DecisionNode as a custom node type.
**Implementation:**
```tsx
import { type NodeTypes } from '@xyflow/react';
import { DecisionNode } from './DecisionNode';

// MUST be defined outside component or memoized to avoid infinite re-renders
const nodeTypes: NodeTypes = { decision: DecisionNode };

// In ReactFlow component:
<ReactFlow
  nodes={nodes}
  edges={edges}
  nodeTypes={nodeTypes}
  connectionLineType={ConnectionLineType.SmoothStep}
  nodesDraggable={false}
  panOnDrag={true}
  zoomOnScroll={true}
  minZoom={0.1}
  maxZoom={2}
  fitView
>
  <Background gap={20} size={2} color="hsl(180 60% 45% / 0.15)" />
</ReactFlow>
```

### Pattern 5: Portal Tooltip for Custom Nodes
**What:** Tooltip rendered via `ReactDOM.createPortal` to escape React Flow's transform context.
**Why needed:** React Flow applies CSS transforms to the viewport. Tooltips inside nodes would be scaled/panned with the canvas. Portaling to `document.body` avoids this.
**Implementation:**
```tsx
import { createPortal } from 'react-dom';

// Inside DecisionNode component:
const [tooltipPos, setTooltipPos] = useState<{ x: number; y: number } | null>(null);
const nodeRef = useRef<HTMLDivElement>(null);

const handleMouseEnter = () => {
  if (nodeRef.current) {
    const rect = nodeRef.current.getBoundingClientRect();
    setTooltipPos({
      x: rect.left + rect.width / 2,
      y: rect.top - 50,
    });
  }
};

// Render tooltip via portal:
{tooltipPos && createPortal(
  <div
    style={{
      position: 'fixed',
      left: tooltipPos.x,
      top: tooltipPos.y,
      transform: 'translateX(-50%)',
      pointerEvents: 'none',
      zIndex: 1000,
    }}
  >
    Click for more details
  </div>,
  document.body
)}
```

### Pattern 6: Motion Import Convention
**What:** The codebase uses `motion/react` as the canonical import for the motion library.
**Important:** Do NOT import from `framer-motion` -- use `motion/react` consistently.
```tsx
import { motion, AnimatePresence } from 'motion/react';
```
One file (`TimelineCore.tsx`) imports from `framer-motion` but that is legacy. All new code should use `motion/react`.

### Pattern 7: Scoped CSS Variables for Command Center Teal Accent
**What:** Add Command Center-specific color variables that do not affect the rest of the Holmes design system.
**Where:** In `globals.css`, using a scoped selector.
```css
/* Command Center scoped accent -- does not affect global Holmes palette */
.command-center-scope {
  --cc-accent: 180 60% 45%;           /* teal/cyan */
  --cc-accent-glow: 180 60% 45%;
  --cc-financial-tint: 140 40% 20%;   /* subtle green */
  --cc-legal-tint: 220 40% 25%;       /* subtle blue */
  --cc-strategy-tint: 30 40% 22%;     /* subtle warm */
  --cc-evidence-tint: 50 35% 22%;     /* subtle amber */
  --cc-kg-tint: 270 30% 22%;          /* subtle purple */
}
```
The `CommandCenter.tsx` wrapper div gets `className="command-center-scope"`, then all child components reference `var(--cc-accent)` etc.

### Anti-Patterns to Avoid
- **Defining `nodeTypes` inside the component body:** Causes infinite re-renders. Define outside or use `useMemo` with empty deps.
- **Using `dagre` (unmaintained v0.8.5):** Use `@dagrejs/dagre` v2.0.3 instead.
- **Importing from `framer-motion`:** Use `motion/react` per codebase convention.
- **Duplicating state:** Agent states are managed in `CommandCenter.tsx` via SSE. React Flow nodes/edges should be derived via `useMemo`, not stored as separate state.
- **Adding ReactFlowProvider at page level:** Keep it scoped to `CommandCenter.tsx`.
- **Using `useNodesState` / `useEdgesState` for this use case:** These hooks are for user-editable graphs. Since our nodes are not draggable and edges are computed from data, use regular `useMemo` derivation and pass nodes/edges directly to `<ReactFlow>`.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Graph layout algorithm | Custom node positioning math | `@dagrejs/dagre` with TB rankdir | Handles arbitrary tree widths, prevents overlaps, respects rank separation |
| Pan/zoom canvas | D3 zoom behavior (current impl) | `@xyflow/react` built-in pan/zoom | Handles touch, wheel, pinch; provides fitView; manages viewport state |
| Edge routing | Custom SVG path calculation | React Flow `smoothstep` edge type | Handles routing around nodes, animated dashes, styling |
| Node connection handles | Manual position calculation | React Flow `<Handle>` component | Properly positioned, supports multiple handle types |
| Viewport fitting | Manual bounding box calculation | `reactFlowInstance.fitView()` | Handles padding, duration animation, zoom clamping |
| Collapsible sections | Custom component | Reuse existing pattern from `AgentDetailsPanel.tsx` | Already works, consistent with codebase |

## Common Pitfalls

### Pitfall 1: nodeTypes Redefined on Every Render
**What goes wrong:** React Flow enters infinite re-render loop.
**Why it happens:** `nodeTypes={{ decision: DecisionNode }}` creates a new object on every render, causing React Flow to re-register node types, which triggers re-render.
**How to avoid:** Define `nodeTypes` as a module-level constant or use `useMemo(() => ({ decision: DecisionNode }), [])`.
**Warning signs:** Browser tab freezes, "Maximum update depth exceeded" error.

### Pitfall 2: React Flow CSS Not Imported
**What goes wrong:** Nodes render but have no default styling; edges are invisible; minimap is broken.
**Why it happens:** `@xyflow/react` requires its stylesheet to be imported explicitly.
**How to avoid:** Add `import '@xyflow/react/dist/style.css'` in the canvas component or in `globals.css`.
**Warning signs:** Graph appears but looks completely broken/unstyled.

### Pitfall 3: Custom Nodes Losing Dimensions for Dagre
**What goes wrong:** Dagre computes layout with wrong dimensions, nodes overlap or have huge gaps.
**Why it happens:** Custom nodes may have dynamic sizes that differ from the hardcoded `NODE_WIDTH` / `NODE_HEIGHT` passed to dagre.
**How to avoid:** Fix node dimensions via CSS (`w-[300px] h-[100px]`) to match the dagre constants. The guide specifies 300x100 -- enforce it.
**Warning signs:** Nodes overlapping or layout looks compressed/stretched.

### Pitfall 4: SSE Events Arriving Before Component Mounts
**What goes wrong:** Agent state updates are lost, tree shows stale data.
**Why it happens:** SSE connection starts before React Flow is ready.
**How to avoid:** The existing SSE hook already handles this correctly (events update state, React re-renders with new nodes). Just ensure the data transformation pipeline is reactive.
**Warning signs:** Missing nodes after SSE events fire.

### Pitfall 5: Portal Tooltip Positioning After Zoom/Pan
**What goes wrong:** Tooltip appears at wrong position after user zooms or pans.
**Why it happens:** `getBoundingClientRect()` returns screen coordinates, but if called before React Flow updates the DOM, it may be stale.
**How to avoid:** Compute tooltip position on `onMouseEnter` every time (not cached). The `getBoundingClientRect()` of the node DOM element automatically accounts for zoom/pan since React Flow uses CSS transforms.
**Warning signs:** Tooltip drifts from node when zoomed in/out.

### Pitfall 6: Dagre Graph Instance Reuse
**What goes wrong:** Layout computation produces wrong results on subsequent calls.
**Why it happens:** Dagre's `Graph` instance retains previous nodes/edges from prior layout calls.
**How to avoid:** Create a new dagre graph OR clear all nodes/edges before each layout computation. The safest approach is to clear with `dagreGraph.nodes().forEach(n => dagreGraph.removeNode(n))` before adding new nodes.
**Warning signs:** Ghost nodes from previous renders affecting layout.

### Pitfall 7: Motion Animations Inside React Flow Nodes
**What goes wrong:** `motion.div` entrance animations cause layout jumps as nodes animate from `scale: 0.9 -> 1`.
**Why it happens:** React Flow caches node dimensions. Animation changes node visual size during animation.
**How to avoid:** Use `transform` animations only (`scale`, `opacity`, `y`). Avoid animating `width`/`height`. The node container div should have fixed dimensions; the inner `motion.div` animates within those fixed bounds.
**Warning signs:** Layout recalculates mid-animation, nodes jump around.

## Code Examples

### Complete ReactFlow Canvas Setup
```tsx
// Source: @xyflow/react official docs + dagre example
import {
  ReactFlow,
  Background,
  ConnectionLineType,
  type Node,
  type Edge,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodeTypes = { decision: DecisionNode };

function AgentFlowCanvas({ nodes, edges, onNodeClick, selectedNodeId }) {
  const reactFlowInstance = useReactFlow();

  // Auto-fit viewport when nodes change
  useEffect(() => {
    if (nodes.length > 0) {
      setTimeout(() => {
        reactFlowInstance.fitView({
          duration: 1500,
          padding: 0.2,
          minZoom: 0.1,
          maxZoom: 1,
        });
      }, 100); // Small delay to let nodes render
    }
  }, [nodes.length]);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      nodeTypes={nodeTypes}
      connectionLineType={ConnectionLineType.SmoothStep}
      nodesDraggable={false}
      panOnDrag={true}
      zoomOnScroll={true}
      minZoom={0.1}
      maxZoom={2}
      onNodeClick={(_, node) => onNodeClick(node)}
      fitView
    >
      <Background
        gap={20}
        size={2}
        color="rgba(138, 138, 130, 0.15)"
      />
    </ReactFlow>
  );
}
```

### Edge Styling Based on Chosen/Processing State
```tsx
// Source: Reference guide + CONTEXT decisions
function buildEdge(
  sourceId: string,
  targetId: string,
  isChosen: boolean,
  isProcessing: boolean,
): Edge {
  return {
    id: `edge-${sourceId}-${targetId}`,
    source: sourceId,
    target: targetId,
    type: 'smoothstep',
    animated: isChosen || isProcessing,
    style: isChosen
      ? {
          stroke: 'hsl(var(--cc-accent))',
          strokeWidth: 3,
          filter: 'drop-shadow(0 0 6px hsl(var(--cc-accent) / 0.6))',
        }
      : {
          stroke: 'hsl(0 0% 50% / 0.3)',
          strokeWidth: 1,
        },
  };
}
```

### Spring-Animated Sidebar (NodeDetailsSidebar)
```tsx
// Source: Reference guide + motion/react pattern from codebase
import { motion, AnimatePresence } from 'motion/react';

function NodeDetailsSidebar({ isOpen, nodeData, onClose }) {
  return (
    <AnimatePresence>
      {isOpen && nodeData && (
        <motion.div
          key="sidebar"
          initial={{ x: '100%' }}
          animate={{ x: 0 }}
          exit={{ x: '100%' }}
          transition={{ type: 'spring', damping: 20, stiffness: 300 }}
          className="fixed right-0 top-0 h-full w-96 z-50"
          style={{ backgroundColor: 'var(--color-jet)' }}
        >
          {/* Sidebar content */}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

### DecisionNode Animation Patterns
```tsx
// Source: Reference guide - all animation values
const entranceVariants = {
  hidden: { scale: 0.9, opacity: 0 },
  visible: { scale: 1, opacity: 1, transition: { duration: 0.5, ease: 'easeOut' } },
};

const floatingAnimation = {
  y: [0, -2, 0],
  transition: { duration: 2, ease: 'easeInOut', repeat: Infinity },
};

const hoverAnimation = { scale: 1.05, y: -8 };
const tapAnimation = { scale: 0.98 };

const pulsingBorder = {
  scale: [1, 1.05, 1],
  opacity: [0.5, 0.8, 0.5],
  transition: { duration: 2, repeat: Infinity },
};
```

## State of the Art

| Old Approach (Current) | New Approach (Target) | Impact |
|------------------------|-----------------------|--------|
| D3 SVG canvas with manual zoom/pan | React Flow declarative canvas | Eliminates ~250 lines of D3 imperative code |
| SVG `<g>` nodes with manual positioning | Custom React components as nodes | Rich HTML/CSS nodes with animations |
| Manual `calculateOrthogonalPath()` | React Flow `smoothstep` edge type | Automatic edge routing with animation support |
| `d3-zoom` behavior with filter | React Flow built-in pan/zoom | Touch support, fitView, zoom controls built in |
| Manual bounding box for fitView | `reactFlowInstance.fitView()` | Smooth animated viewport fitting |
| Static positions from config | Dagre auto-layout | Automatic tree layout, no manual coordinates |
| CSS transition-based animations | Motion spring animations | Entrance, floating, pulse, hover, sidebar spring |
| Inline sidebar with width toggle | Portal/fixed sidebar with AnimatePresence | Spring animation, exit animation, independent of canvas |

**Package name change:** `reactflow` (v11) was renamed to `@xyflow/react` (v12). Always use `@xyflow/react`.

**Dagre maintainer change:** `dagre` (v0.8.5, unmaintained) was forked to `@dagrejs/dagre` (v2.0.3, active, ships own TS types). Always use `@dagrejs/dagre`.

**Motion rename:** `framer-motion` was renamed to `motion`. The codebase uses `motion` v12.29.0 and imports from `motion/react`.

## Key Decisions from CONTEXT.md (Locked)

These decisions are locked and must be followed precisely:

1. **Dynamic tree from backend SSE data** -- tree shape reflects actual routing, not hardcoded
2. **Show all domain agents, mute unchosen** -- all 4 agents always visible, unrouted ones grayed
3. **File group nodes between orchestrator and domains** -- intermediate nodes showing file clusters
4. **Warning badge on orchestrator node** -- small icon/count for warnings
5. **Teal/cyan accent `hsl(180 60% 45%)`** -- scoped to Command Center only
6. **Canvas background: `#111111` (`--color-jet`)** -- matches Holmes cards
7. **Chosen nodes: teal glow + subtle agent-type hue shift** -- per-agent-type tinting
8. **Progressive tree build via SSE** -- nodes animate in as events arrive
9. **Processing state: pulsing border + animated edge flow** -- simultaneous effects
10. **Completion: settle into solid teal** -- non-dramatic transition
11. **Viewport: stay zoomed to fit all** -- no auto-pan on agent activation

## Mapping SSE Events to Tree State

The existing SSE events map to React Flow node state as follows:

| SSE Event | Tree Action | Node Visual |
|-----------|-------------|-------------|
| `agent-started` | Add/update node to "processing" state | Pulsing teal border, spinner, animated incoming edge |
| `agent-complete` | Update node to "complete" state | Solid teal border, steady glow, floating animation |
| `agent-error` | Update node to "error" state | Red border/indicator |
| `processing-complete` | All nodes settled | Summary in footer |

No new SSE events needed. The existing `AGENT_SPAWNED` (mapped to `agent-started`) drives progressive node appearance.

## Open Questions

1. **Exact dagre spacing for file group nodes**
   - What we know: The guide uses `ranksep: 120, nodesep: 150`. Adding file group intermediate nodes increases tree depth by one rank.
   - What's unclear: Whether the same spacing works visually with the additional rank.
   - Recommendation: Start with guide values, fine-tune during implementation. Claude has discretion here per CONTEXT.md.

2. **How unchosen domain agents appear**
   - What we know: They appear muted after orchestrator completes.
   - What's unclear: Exact timing and animation (fade-in? instant appearance?).
   - Recommendation: Use a 300ms fade-in with `opacity: 0 -> 0.6` after orchestrator transitions to complete. Claude has discretion.

3. **Sidebar positioning (fixed vs absolute)**
   - What we know: Reference guide uses `fixed right-0 top-0 h-full w-96`.
   - What's unclear: Whether `fixed` works well within the page layout (case layout has header, nav).
   - Recommendation: Use `absolute` within the Command Center container rather than `fixed`, to avoid overlapping the case layout chrome. Test during implementation.

## Sources

### Primary (HIGH confidence)
- `@xyflow/react` v12.10.0 -- [npm](https://www.npmjs.com/package/@xyflow/react), [Official Dagre Example](https://reactflow.dev/examples/layout/dagre)
- `@dagrejs/dagre` v2.0.3 -- [npm](https://www.npmjs.com/package/@dagrejs/dagre)
- React Flow TypeScript guide -- [reactflow.dev/learn/advanced-use/typescript](https://reactflow.dev/learn/advanced-use/typescript)
- React Flow API Reference -- [reactflow.dev/api-reference/react-flow](https://reactflow.dev/api-reference/react-flow)
- React Flow Handles -- [reactflow.dev/learn/customization/handles](https://reactflow.dev/learn/customization/handles)
- React Flow ReactFlowProvider -- [reactflow.dev/api-reference/react-flow-provider](https://reactflow.dev/api-reference/react-flow-provider)
- Motion docs -- [motion.dev/docs/react-animation](https://motion.dev/docs/react-animation), [motion.dev/docs/react-animate-presence](https://motion.dev/docs/react-animate-presence)
- Existing codebase files (read in full): `AgentFlowCanvas.tsx`, `AgentNode.tsx`, `AgentDetailsPanel.tsx`, `CommandCenter.tsx`, `command-center-config.ts`, `command-center.ts`, `useCommandCenterSSE.ts`, `command-center-validation.ts`, `mock-command-center-data.ts`, `globals.css`

### Secondary (MEDIUM confidence)
- React Flow Dagre layout overview -- [reactflow.dev/learn/layouting/layouting](https://reactflow.dev/learn/layouting/layouting)
- React Flow fitView options -- [reactflow.dev/api-reference/types/fit-view-options](https://reactflow.dev/api-reference/types/fit-view-options)
- Portal tooltip pattern -- multiple sources confirming `createPortal` to `document.body`

### Tertiary (LOW confidence)
- Dagre spacing values (may need tuning for this specific tree shape)
- Custom node dimension caching behavior in React Flow 12 (may have changed from v11)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- verified versions on npm, confirmed codebase dependencies
- Architecture: HIGH -- patterns verified with official React Flow docs and existing codebase structure
- Pitfalls: HIGH -- well-documented in React Flow ecosystem, verified with official sources
- Animation patterns: HIGH -- motion/react patterns confirmed from codebase usage + official docs
- Color/theming: MEDIUM -- exact teal hue values are per Claude's discretion, integration approach verified from globals.css structure

**Research date:** 2026-02-03
**Valid until:** 2026-03-03 (stable libraries, 30-day validity)
