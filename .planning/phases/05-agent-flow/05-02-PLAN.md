---
phase: 05-agent-flow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/confirmation.py
  - backend/app/api/confirmations.py
  - backend/app/api/__init__.py
autonomous: true

must_haves:
  truths:
    - "Pipeline execution pauses when a confirmation is requested and resumes when user approves/rejects"
    - "Pending confirmations emit SSE events that the frontend can listen to"
    - "Confirmation API accepts POST with approved boolean and optional reason"
    - "Multiple confirmations can be pending simultaneously without interfering"
  artifacts:
    - path: "backend/app/services/confirmation.py"
      provides: "HITL confirmation service with asyncio.Event pause/resume pattern"
      contains: "request_confirmation"
    - path: "backend/app/api/confirmations.py"
      provides: "REST endpoints for responding to confirmations and listing pending ones"
      exports: ["router"]
    - path: "backend/app/api/__init__.py"
      provides: "Confirmation router registered"
      contains: "confirmations"
  key_links:
    - from: "backend/app/services/confirmation.py"
      to: "backend/app/services/agent_events.py"
      via: "emit_confirmation_required on request, emit_confirmation_resolved on response"
      pattern: "emit_confirmation"
    - from: "backend/app/api/confirmations.py"
      to: "backend/app/services/confirmation.py"
      via: "resolve_confirmation called from POST endpoint"
      pattern: "resolve_confirmation"
---

<objective>
Implement backend HITL confirmation system using asyncio.Event pause/resume pattern.

Purpose: ADK's `require_confirmation` does not work with DatabaseSessionService (official limitation). This plan implements a frontend-driven confirmation system where the pipeline pauses via `asyncio.Event.wait()`, emits an SSE event, and resumes when the user responds via REST API. Per CONTEXT.md: "Agent waits indefinitely for user response -- no timeout, pipeline stays paused."

Output: A confirmation service module and REST API endpoints for requesting and responding to confirmations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-agent-flow/05-CONTEXT.md
@.planning/phases/05-agent-flow/05-RESEARCH.md

@backend/app/services/agent_events.py
@backend/app/api/agents.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create confirmation service with asyncio.Event pattern</name>
  <files>
    backend/app/services/confirmation.py
  </files>
  <action>
  Create `backend/app/services/confirmation.py` with:

  1. Module-level in-memory stores (suitable for single-instance hackathon deployment):
     - `_pending_confirmations: dict[str, asyncio.Event]` -- maps request_id to asyncio.Event
     - `_confirmation_results: dict[str, ConfirmationResult]` -- maps request_id to user's response
     - `_confirmation_requests: dict[str, ConfirmationRequest]` -- maps request_id to the original request data (for listing and frontend display)

  2. Pydantic models:
     - `ConfirmationRequest` with fields: `request_id: str`, `case_id: str`, `agent_type: str`, `action_description: str`, `affected_items: list[str]`, `context: dict[str, object]`, `created_at: datetime`
     - `ConfirmationResult` with fields: `approved: bool`, `reason: str | None = None`, `responded_at: datetime`

  3. `async def request_confirmation(case_id: str, agent_type: str, action_description: str, affected_items: list[str], context: dict[str, object] | None = None) -> ConfirmationResult`:
     - Generate a UUID `request_id`
     - Create `asyncio.Event()` and store in `_pending_confirmations[request_id]`
     - Store `ConfirmationRequest` in `_confirmation_requests[request_id]`
     - Call `emit_confirmation_required()` from `agent_events.py` (passing case_id, request_id, agent_type, action_description, affected_items)
     - `await event.wait()` -- this blocks the pipeline coroutine WITHOUT blocking the event loop
     - After unblocking: retrieve and remove result from `_confirmation_results[request_id]`, clean up `_pending_confirmations[request_id]` and `_confirmation_requests[request_id]`
     - Return the `ConfirmationResult`
     - IMPORTANT: No timeout per CONTEXT.md ("Agent waits indefinitely")

  4. `def resolve_confirmation(request_id: str, approved: bool, reason: str | None = None) -> bool`:
     - Check if `request_id` exists in `_pending_confirmations`
     - If not found, return False
     - Store `ConfirmationResult` in `_confirmation_results[request_id]`
     - Call `_pending_confirmations[request_id].set()` to unblock the waiting coroutine
     - Emit `emit_confirmation_resolved()` SSE event
     - Return True

  5. `def get_pending_confirmations(case_id: str) -> list[ConfirmationRequest]`:
     - Return all pending confirmations for this case (filter by case_id)

  6. `def get_pending_confirmation_count(case_id: str) -> int`:
     - Return count of pending confirmations for the case (for notification badge)

  Add ABOUTME comment at top: "ABOUTME: Human-in-the-loop confirmation service for pipeline pause/resume.\nABOUTME: Uses asyncio.Event to block pipeline coroutines while waiting for user decisions."

  Import `emit_confirmation_required` and `emit_confirmation_resolved` from `agent_events.py` (added in Plan 01 Task 1).
  </action>
  <verify>
  - `cd backend && python -m py_compile app/services/confirmation.py` succeeds
  - `python -c "from app.services.confirmation import request_confirmation, resolve_confirmation, get_pending_confirmations"` succeeds
  </verify>
  <done>
  - Confirmation service supports pause/resume via asyncio.Event
  - Pipeline coroutine blocks without blocking event loop
  - No timeout (indefinite wait per CONTEXT.md)
  - Pending confirmations trackable by case_id
  - SSE events emitted on request and resolution
  </done>
</task>

<task type="auto">
  <name>Task 2: Create confirmation REST API endpoints</name>
  <files>
    backend/app/api/confirmations.py
    backend/app/api/__init__.py
  </files>
  <action>
  **Create `backend/app/api/confirmations.py`:**

  1. Create FastAPI router with `tags=["confirmations"]`

  2. Request/response schemas (Pydantic):
     - `ConfirmationResponseBody` with fields: `approved: bool`, `reason: str | None = None`
     - `ConfirmationListResponse` with fields: `confirmations: list[ConfirmationRequest]`, `count: int`

  3. Endpoints:

     `POST /api/cases/{case_id}/confirmations/{request_id}`:
     - Accepts `ConfirmationResponseBody` in request body
     - Calls `resolve_confirmation(request_id, body.approved, body.reason)`
     - If confirmation not found (returns False), return 404
     - On success, return 200 with `{"status": "resolved", "approved": body.approved}`
     - No auth required for hackathon simplicity (the SSE event already scoped to case)

     `GET /api/cases/{case_id}/confirmations/pending`:
     - Calls `get_pending_confirmations(case_id)`
     - Returns `ConfirmationListResponse` with list and count

  4. Add ABOUTME comment at top: "ABOUTME: REST API endpoints for HITL confirmation responses.\nABOUTME: Frontend calls these to approve/reject pending agent actions."

  **In `backend/app/api/__init__.py`:**

  Register the confirmation router. Look at how existing routers (agents, files, sse) are registered and follow the same pattern. The file likely imports routers and includes them on the app. Add the confirmations router import and include.

  If `__init__.py` uses a different registration pattern (e.g., routers are registered in `main.py`), follow that pattern instead. Check `backend/app/main.py` for router registration.
  </action>
  <verify>
  - `cd backend && python -m py_compile app/api/confirmations.py` succeeds
  - `python -c "from app.api.confirmations import router"` succeeds
  - Verify router registration: grep for "confirmations" in the app startup file to confirm the router is included
  </verify>
  <done>
  - POST endpoint accepts approval/rejection for pending confirmations
  - GET endpoint returns list of pending confirmations for a case
  - Router registered in app startup
  - Confirmation resolution unblocks the waiting pipeline coroutine
  </done>
</task>

</tasks>

<verification>
1. `cd backend && python -m py_compile app/services/confirmation.py app/api/confirmations.py` succeeds
2. Unit test concept (manual verification):
   - Start server
   - Call POST /api/cases/{id}/confirmations/{req_id} with `{"approved": true}` -- should 404 (no pending)
   - GET /api/cases/{id}/confirmations/pending -- should return empty list
3. The asyncio.Event pattern is correct: `await event.wait()` blocks the coroutine but not the event loop, so FastAPI can still handle the POST request that calls `event.set()`
</verification>

<success_criteria>
- Confirmation service module exists with request_confirmation/resolve_confirmation functions
- REST endpoints exist for responding to and listing pending confirmations
- Router registered in app
- asyncio.Event pattern correctly pauses pipeline without blocking event loop
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-flow/05-02-SUMMARY.md`
</output>
