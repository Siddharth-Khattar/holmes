---
phase: 06-domain-agents
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - backend/app/agents/strategy.py
autonomous: true

must_haves:
  truths:
    - "Strategy agent processes legal strategy files plus text summaries from other domain agents"
    - "Strategy agent runs sequentially AFTER parallel domain agents complete"
    - "Strategy agent has Pro-to-Flash fallback like other domain agents"
    - "Strategy agent output includes domain_agent_summaries_received field"
    - "Strategy agent accepts context_injection and stage_suffix parameters (consistent with other domain agents)"
  artifacts:
    - path: "backend/app/agents/strategy.py"
      provides: "StrategyAgent class + run_strategy function with context_injection param"
      contains: "async def run_strategy"
  key_links:
    - from: "backend/app/agents/strategy.py"
      to: "backend/app/agents/domain_runner.py"
      via: "consumes build_strategy_context output as domain_summaries parameter"
      pattern: "domain_summaries"
    - from: "backend/app/agents/strategy.py"
      to: "backend/app/services/adk_service.py"
      via: "uses build_domain_agent_content for file preparation"
      pattern: "from app.services.adk_service import"
---

<objective>
Implement the Legal Strategy agent that runs AFTER Financial, Legal, and Evidence agents. It receives its own strategy-relevant files plus text summaries of other agents' findings. It does not re-analyze raw evidence -- it synthesizes a strategic picture. Strategy agent follows the same parameter conventions as other domain agents (context_injection, stage_suffix) for consistency.

Purpose: The Strategy agent is unique in the pipeline because it is the only domain agent that runs sequentially (after the parallel batch) and receives cross-agent context. It informs investigation direction rather than performing forensic analysis.

Output: `backend/app/agents/strategy.py` with StrategyAgent class and run_strategy function.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-domain-agents/06-CONTEXT.md
@.planning/phases/06-domain-agents/06-RESEARCH.md

@backend/app/agents/triage.py
@backend/app/agents/factory.py
@backend/app/schemas/agent.py
@backend/app/services/adk_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Strategy agent module</name>
  <files>backend/app/agents/strategy.py</files>
  <action>
Create `backend/app/agents/strategy.py` following the same pattern as the other domain agents (financial.py, legal.py, evidence.py) but with key differences for its sequential, summary-consuming role.

**ABOUTME header**: "Legal Strategy Agent for case approach planning and investigation priorities." / "Runs after parallel domain agents, consuming their findings as text summaries."

**StrategyAgent class**: Same pattern as FinancialAgent but with `model` parameter defaulting to MODEL_PRO.

**parse_strategy_output**: Same reverse-event-scan pattern, returns `StrategyOutput | None`.

**Content preparation -- DIFFERENT from other agents:**

The strategy agent receives TWO types of input:
1. Its own routed files (strategy-relevant documents like playbooks, internal communications)
2. Text summaries of findings from the parallel domain agents

```python
async def _prepare_strategy_content(
    files: list[CaseFile],
    gcs_bucket: str,
    domain_summaries: str,
    hypotheses_text: str,
    context_injection: str | None = None,
) -> types.Content:
    """Build content for Strategy Agent.

    Unlike other domain agents, Strategy receives:
    1. Its own strategy-relevant files (playbooks, internal docs)
    2. TEXT summaries from Financial, Legal, Evidence agents
    3. Existing hypotheses to evaluate
    4. Optional case-specific context injection

    Per RESEARCH.md Pitfall 4: Strategy receives text summaries of
    domain findings, NOT the raw multimodal content, to avoid
    context window bloat.
    """
    prompt_parts: list[str] = []

    if context_injection:
        prompt_parts.append(f"--- CASE CONTEXT ---\n{context_injection}\n---\n")

    prompt_parts.append("Analyze the following for legal strategy insights.")

    if domain_summaries:
        prompt_parts.append(
            "\n\n--- DOMAIN AGENT FINDINGS SUMMARIES ---\n"
            + domain_summaries
        )

    if hypotheses_text:
        prompt_parts.append(
            "\n\n--- EXISTING HYPOTHESES TO EVALUATE ---\n"
            + hypotheses_text
        )

    prompt = "\n".join(prompt_parts)

    if files:
        # Strategy has its own files -- use build_domain_agent_content
        return await build_domain_agent_content(
            files=files,
            gcs_bucket=gcs_bucket,
            prompt=prompt,
        )
    else:
        # Strategy may have NO files of its own (only summaries)
        return types.Content(
            role="user",
            parts=[types.Part(text=prompt)],
        )
```

**run_strategy function signature -- consistent with other domain agents but with unique params:**

```python
async def run_strategy(
    case_id: str,
    workflow_id: str,
    user_id: str,
    files: list[CaseFile],
    domain_summaries: str,
    hypotheses: list[dict[str, object]],
    db_session: AsyncSession,
    publish_event: PublishFn | None = None,
    parent_execution_id: UUID | None = None,
    context_injection: str | None = None,
    stage_suffix: str = "",
) -> StrategyOutput | None:
```

Key differences from `run_financial`:
- `domain_summaries: str` parameter (text output from `build_strategy_context`)
- `context_injection` and `stage_suffix` params for consistency with other domain agents (strategy typically runs once, but the params maintain uniform interface)
- Stage name is f"strategy{stage_suffix}" (and f"strategy{stage_suffix}_fallback" for Flash fallback)
- agent_name="strategy" in execution record
- Content preparation uses `_prepare_strategy_content` with domain_summaries and context_injection
- `input_data` in execution record includes `"domain_summaries_length": len(domain_summaries)` and `"has_own_files": len(files) > 0`

Otherwise follows the SAME pattern: execution record creation, Pro-to-Flash fallback, parse retries, token/thinking extraction, etc.

**Edge case: Strategy agent with no files**

Per CONTEXT.md, the orchestrator routes files by domain. If no files are routed to "strategy", the pipeline code in agents.py (Plan 05) should still invoke run_strategy if any other domain agents ran, because the Strategy agent's primary input is the domain summaries. In this case `files=[]` and `_prepare_strategy_content` produces text-only content from summaries.

Handle this in run_strategy: if `not files and not domain_summaries`, return None with appropriate logging (nothing to analyze).
  </action>
  <verify>
Run from the backend directory:
1. `python -c "from app.agents.strategy import run_strategy, StrategyAgent, parse_strategy_output; print('Strategy agent module OK')"` -- imports work.
2. `python -c "import inspect; from app.agents.strategy import run_strategy; sig = inspect.signature(run_strategy); assert 'domain_summaries' in sig.parameters; assert 'context_injection' in sig.parameters; assert 'stage_suffix' in sig.parameters; print('All unique params exist')"` -- verify unique parameters.
3. `python -c "import inspect; from app.agents.strategy import run_strategy; sig = inspect.signature(run_strategy); params = list(sig.parameters.keys()); print(f'Params: {params}')"` -- verify full signature.
  </verify>
  <done>
Strategy agent module created with:
- StrategyAgent class with model parameter for Pro/Flash switching
- parse_strategy_output for structured output extraction
- _prepare_strategy_content that combines context_injection + strategy files + domain agent text summaries + hypothesis context
- run_strategy with domain_summaries, context_injection, and stage_suffix parameters, Pro-to-Flash fallback, stage-isolated session
- Handles edge case of no files (text-only analysis from summaries)
- Uniform interface with other domain agents (context_injection, stage_suffix)
  </done>
</task>

</tasks>

<verification>
- Strategy agent importable and has correct unique signature (domain_summaries, context_injection, stage_suffix params)
- Can handle files=[] case (summary-only input)
- Context injection prepended before analysis prompt when provided
- Follows same execution pattern as other domain agents (execution record, fallback, parsing)
- Stage name f"strategy{stage_suffix}" and f"strategy{stage_suffix}_fallback" used for session isolation
</verification>

<success_criteria>
- `run_strategy` accepts domain_summaries, context_injection, and stage_suffix parameters
- Strategy agent processes its own files AND domain agent summaries
- Context injection flows through to content preparation
- Pro-to-Flash fallback works
- Execution record tracks domain_summaries_length in input_data
- Empty files + empty summaries returns None gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/06-domain-agents/06-04-SUMMARY.md`
</output>
