---
phase: 07-knowledge-storage-and-domain-agent-enrichment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/knowledge_graph.py
  - backend/app/models/findings.py
  - backend/app/models/synthesis.py
  - backend/app/models/__init__.py
  - backend/alembic/versions/xxxx_add_knowledge_tables.py
autonomous: true

must_haves:
  truths:
    - "All 9 new tables exist in PostgreSQL after alembic upgrade head"
    - "kg_entities, kg_relationships, case_findings, case_hypotheses, case_contradictions, case_gaps, case_synthesis, timeline_events, locations tables all have correct columns"
    - "case_findings has a generated tsvector column with GIN index for full-text search"
    - "All foreign keys enforce referential integrity (cascade deletes on case_id)"
    - "New models are importable from app.models and visible to Alembic"
  artifacts:
    - path: "backend/app/models/knowledge_graph.py"
      provides: "KgEntity and KgRelationship SQLAlchemy models"
      contains: "class KgEntity"
    - path: "backend/app/models/findings.py"
      provides: "CaseFinding SQLAlchemy model with tsvector search"
      contains: "class CaseFinding"
    - path: "backend/app/models/synthesis.py"
      provides: "CaseHypothesis, CaseContradiction, CaseGap, CaseSynthesis, TimelineEvent, Location models"
      contains: "class CaseSynthesis"
    - path: "backend/app/models/__init__.py"
      provides: "All new models exported for Alembic visibility"
      contains: "KgEntity"
  key_links:
    - from: "backend/app/models/knowledge_graph.py"
      to: "backend/app/models/base.py"
      via: "Base inheritance"
      pattern: "from app.models.base import Base"
    - from: "backend/app/models/__init__.py"
      to: "backend/app/models/knowledge_graph.py"
      via: "import for Alembic metadata"
      pattern: "from app.models.knowledge_graph import"
---

<objective>
Create all 9 new database tables as SQLAlchemy models and a single Alembic migration.

Purpose: This is the storage foundation for the entire knowledge layer -- KG entities, relationships, findings, hypotheses, contradictions, gaps, synthesis, timeline events, and locations. Every downstream service (KG Builder, Synthesis Agent, Chat Agent) reads from and writes to these tables.

Output: 3 new model files, updated __init__.py, and 1 Alembic migration that creates all 9 tables with indexes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-knowledge-storage--and--domain-agent-enrichment/07-RESEARCH.md
@backend/app/models/agent_execution.py
@backend/app/models/base.py
@backend/app/models/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLAlchemy models for all 9 tables</name>
  <files>
    backend/app/models/knowledge_graph.py
    backend/app/models/findings.py
    backend/app/models/synthesis.py
    backend/app/models/__init__.py
  </files>
  <action>
    Create three new model files following the EXACT pattern from `agent_execution.py`:
    - All models inherit from `Base`
    - PK: `PG_UUID(as_uuid=True)` with `server_default=text("gen_random_uuid()")`
    - Timestamps: `DateTime(timezone=True)` with `server_default=text("now()")`
    - JSONB columns: `Mapped[dict | None]` or `Mapped[list | None]`
    - All FKs: `ForeignKey("table.id", ondelete="CASCADE")` for case_id, `ondelete="SET NULL"` for optional refs
    - Indexes defined in `__table_args__`
    - 2-line ABOUTME comment at top of each file

    **backend/app/models/knowledge_graph.py** -- KgEntity + KgRelationship:

    KgEntity columns:
    - id (PG_UUID PK), case_id (FK cases.id CASCADE), name (String 500), name_normalized (String 500, comment about dedup), entity_type (String 100), domain (String 50), confidence (Float, default 0.0), metadata (JSONB nullable), context (Text nullable), source_execution_id (FK agent_executions.id SET NULL nullable), source_finding_index (Integer nullable), merged_into_id (self-referential FK kg_entities.id SET NULL nullable), merge_count (Integer server_default="0"), degree (Integer server_default="0"), created_at

    Indexes on KgEntity: idx_kg_entities_case_id, idx_kg_entities_case_type (case_id + entity_type), idx_kg_entities_merged_into, idx_kg_entities_name_normalized (case_id + name_normalized for dedup queries)

    Relationships on KgEntity: case -> Case, source_execution -> AgentExecution, merged_into -> self

    KgRelationship columns:
    - id (PG_UUID PK), case_id (FK cases.id CASCADE), source_entity_id (FK kg_entities.id CASCADE), target_entity_id (FK kg_entities.id CASCADE), relationship_type (String 100), label (String 200), strength (Integer default 0, 0-100), source_execution_id (FK agent_executions.id SET NULL nullable), metadata (JSONB nullable), created_at

    Indexes on KgRelationship: idx_kg_relationships_case_id, idx_kg_relationships_source, idx_kg_relationships_target

    **backend/app/models/findings.py** -- CaseFinding:

    CaseFinding columns:
    - id (PG_UUID PK), case_id (FK cases.id CASCADE), workflow_id (PG_UUID not null), agent_type (String 50), agent_execution_id (FK agent_executions.id SET NULL nullable), file_group_label (String 100 nullable), category (String 200), title (String 200), finding_text (Text), confidence (Float), citations (JSONB nullable -- list of citation dicts), entity_ids (JSONB nullable -- list of UUID strings), created_at

    NOTE: Do NOT add search_vector as a model column. The tsvector generated column + GIN index will be added via raw SQL in the migration (see Pitfall 6 in RESEARCH.md). The model does not need to map this column -- SQLAlchemy queries will use `func.to_tsvector()` and `func.plainto_tsquery()` directly.

    Indexes: idx_case_findings_case_id, idx_case_findings_workflow, idx_case_findings_agent (case_id + agent_type)

    **backend/app/models/synthesis.py** -- 6 models for Phase 8 tables (created now, populated later):

    CaseHypothesis: id, case_id (FK CASCADE), workflow_id, claim (Text), status (String 20 -- PENDING/SUPPORTED/REFUTED), confidence (Float), supporting_evidence (JSONB nullable), contradicting_evidence (JSONB nullable), source_agent (String 50 nullable), reasoning (Text nullable), created_at

    CaseContradiction: id, case_id (FK CASCADE), workflow_id, claim_a (Text), claim_b (Text), source_a (JSONB nullable), source_b (JSONB nullable), severity (String 20 -- minor/significant/critical), domain (String 50 nullable), resolution_status (String 20, default "unresolved"), created_at

    CaseGap: id, case_id (FK CASCADE), workflow_id, description (Text), what_is_missing (Text), why_needed (Text nullable), priority (String 20 -- low/medium/high/critical), related_entity_ids (JSONB nullable), suggested_actions (Text nullable), created_at

    CaseSynthesis: id, case_id (FK CASCADE), workflow_id, case_summary (Text nullable), case_verdict (JSONB nullable), cross_modal_links (JSONB nullable), cross_domain_conclusions (JSONB nullable), key_findings_summary (Text nullable), risk_assessment (Text nullable), timeline_event_count (Integer default 0), created_at

    TimelineEvent: id, case_id (FK CASCADE), workflow_id, title (String 200), description (Text nullable), event_date (DateTime timezone nullable), event_end_date (DateTime timezone nullable), event_type (String 100 nullable), layer (String 50 nullable), source_entity_ids (JSONB nullable), citations (JSONB nullable), created_at

    Location: id, case_id (FK CASCADE), workflow_id, name (String 500), coordinates (JSONB nullable -- {lat, lng}), location_type (String 100 nullable), source_entity_ids (JSONB nullable), temporal_associations (JSONB nullable), created_at

    Add case_id indexes to all synthesis tables.

    **backend/app/models/__init__.py**: Add imports for ALL new model classes and add them to `__all__`. Follow the exact import pattern used for existing models. This is CRITICAL for Alembic to detect the tables.
  </action>
  <verify>
    Run `cd backend && python -c "from app.models import KgEntity, KgRelationship, CaseFinding, CaseHypothesis, CaseContradiction, CaseGap, CaseSynthesis, TimelineEvent, Location; print('All models importable')"` to confirm all imports work without circular dependency errors.
  </verify>
  <done>All 9 model classes defined in 3 files, registered in __init__.py, importable without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for all 9 tables</name>
  <files>
    backend/alembic/versions/xxxx_add_knowledge_tables.py
  </files>
  <action>
    Create a SINGLE Alembic migration that creates all 9 tables. The `down_revision` must chain from the latest existing migration `b3a1f7c42e90` (add_latest_workflow_id_to_cases).

    Use `op.create_table()` for each table with explicit column definitions matching the model definitions from Task 1. Follow the pattern from `0562cc9e65bd_add_agent_executions_table.py`.

    IMPORTANT: For the full-text search on case_findings, add the tsvector generated column and GIN index via RAW SQL (not op.create_table column) per RESEARCH.md Pitfall 6:
    ```python
    op.execute("""
        ALTER TABLE case_findings ADD COLUMN search_vector tsvector
        GENERATED ALWAYS AS (
            to_tsvector('english', coalesce(title, '') || ' ' || coalesce(finding_text, ''))
        ) STORED
    """)
    op.execute("""
        CREATE INDEX idx_case_findings_search ON case_findings USING gin(search_vector)
    """)
    ```

    Also add a tsvector search capability on kg_entities.name via a simple GIN index:
    ```python
    op.execute("""
        ALTER TABLE kg_entities ADD COLUMN name_search_vector tsvector
        GENERATED ALWAYS AS (to_tsvector('english', coalesce(name, ''))) STORED
    """)
    op.execute("""
        CREATE INDEX idx_kg_entities_name_search ON kg_entities USING gin(name_search_vector)
    """)
    ```

    The `downgrade()` function must drop all 9 tables in reverse dependency order (locations, timeline_events, case_synthesis, case_gaps, case_contradictions, case_hypotheses, case_findings, kg_relationships, kg_entities). Also drop the tsvector columns/indexes.

    Use a descriptive revision ID like `c7a1_add_knowledge_tables` (generate a proper hex string).

    Table creation order (respecting FKs): kg_entities first (self-ref), then kg_relationships (refs kg_entities), then case_findings, then synthesis tables (no cross-refs).
  </action>
  <verify>
    Run `cd backend && python -c "from alembic.config import Config; from alembic.script import ScriptDirectory; c = Config('alembic.ini'); s = ScriptDirectory.from_config(c); heads = s.get_heads(); print(f'Migration heads: {heads}')"` to verify the migration is detected in the chain and there's exactly one head.
  </verify>
  <done>Single Alembic migration creates all 9 tables with correct columns, indexes, FKs, and tsvector generated columns. Migration chain has one head.</done>
</task>

</tasks>

<verification>
1. All 9 model classes importable from `app.models`
2. Alembic migration chain has exactly one head (no branches)
3. Migration creates correct table structure (verify by reading the migration file)
4. tsvector generated columns use raw SQL (not SQLAlchemy column definition)
5. All FKs have appropriate ondelete behavior (CASCADE for case_id, SET NULL for optional refs)
</verification>

<success_criteria>
- 9 new SQLAlchemy models across 3 files
- 1 Alembic migration creating all 9 tables
- Full-text search infrastructure (tsvector + GIN) on case_findings and kg_entities
- All models registered in __init__.py for Alembic detection
- No circular import errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-storage--and--domain-agent-enrichment/07-01-SUMMARY.md`
</output>
