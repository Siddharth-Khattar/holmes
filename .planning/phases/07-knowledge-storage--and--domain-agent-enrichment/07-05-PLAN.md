---
phase: 07-knowledge-storage-and-domain-agent-enrichment
plan: 05
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - backend/app/api/knowledge_graph.py
  - backend/app/api/findings.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "GET /api/cases/:caseId/graph returns entities and relationships for frontend consumption"
    - "CRUD endpoints exist for entities and relationships (GET list, POST create, PATCH update, DELETE)"
    - "GET /api/cases/:caseId/findings returns paginated findings with optional agent_type filter"
    - "GET /api/cases/:caseId/findings/search returns full-text search results ranked by relevance"
    - "New routers registered in main.py"
  artifacts:
    - path: "backend/app/api/knowledge_graph.py"
      provides: "KG API endpoints: graph, entities CRUD, relationships CRUD"
      exports: ["router"]
    - path: "backend/app/api/findings.py"
      provides: "Findings API endpoints: list, detail, search"
      exports: ["router"]
    - path: "backend/app/main.py"
      provides: "New routers registered"
      contains: "knowledge_graph"
  key_links:
    - from: "backend/app/api/knowledge_graph.py"
      to: "backend/app/models/knowledge_graph.py"
      via: "SQLAlchemy queries for entity/relationship CRUD"
      pattern: "select\\(KgEntity\\)"
    - from: "backend/app/api/findings.py"
      to: "backend/app/services/findings_service.py"
      via: "Service layer for search and listing"
      pattern: "search_findings"
    - from: "backend/app/main.py"
      to: "backend/app/api/knowledge_graph.py"
      via: "Router registration"
      pattern: "app.include_router\\(knowledge_graph.router"
---

<objective>
Create API endpoints for KG and findings, and register them in main.py.

Purpose: These endpoints expose the knowledge graph and findings data to the frontend. The KG API provides graph visualization data, entity/relationship CRUD for manual corrections, and filtered queries. The findings API provides listing, detail view, and full-text search.

Output: 2 new API routers, updated main.py with router registration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-knowledge-storage--and--domain-agent-enrichment/07-RESEARCH.md
@.planning/phases/07-knowledge-storage--and--domain-agent-enrichment/07-CONTEXT.md
@backend/app/api/files.py
@backend/app/main.py
@backend/app/api/auth.py
@backend/app/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KG and findings API routers</name>
  <files>
    backend/app/api/knowledge_graph.py
    backend/app/api/findings.py
  </files>
  <action>
    Follow the EXACT router pattern from `files.py` -- APIRouter with prefix, CurrentUser dependency, Depends(get_db), case ownership verification.

    **backend/app/api/knowledge_graph.py** (2-line ABOUTME):

    Router prefix: `/api/cases/{case_id}` (entity and relationship routes share the case context).

    Endpoints:

    1. `GET /api/cases/{case_id}/graph` -> GraphResponse
       - Query all KgEntity rows for case_id WHERE merged_into_id IS NULL (exclude merged duplicates).
       - Query all KgRelationship rows for case_id.
       - Return GraphResponse with entities, relationships, counts.
       - Verify case ownership (query Case where id=case_id and user_id matches current_user.id).

    2. `GET /api/cases/{case_id}/entities` -> EntityListResponse
       - Optional query params: entity_type (str), domain (str), search (str for name search), limit (int=50), offset (int=0).
       - Filter by entity_type and domain if provided.
       - If search provided, filter where name ILIKE %search%.
       - WHERE merged_into_id IS NULL.
       - Return EntityListResponse with total count.

    3. `POST /api/cases/{case_id}/entities` -> EntityResponse (status 201)
       - Accept EntityCreateRequest body.
       - Create KgEntity with case_id, name_normalized computed from name.
       - Return created entity.

    4. `PATCH /api/cases/{case_id}/entities/{entity_id}` -> EntityResponse
       - Accept EntityUpdateRequest body.
       - Query entity by id AND case_id (prevent cross-case access).
       - Update only provided (non-None) fields. If name changes, recompute name_normalized.
       - Return updated entity.

    5. `DELETE /api/cases/{case_id}/entities/{entity_id}` -> 204 No Content
       - Query entity by id AND case_id.
       - Hard delete the entity (cascade deletes relationships).
       - Return 204.

    6. `GET /api/cases/{case_id}/relationships` -> RelationshipListResponse
       - Optional query params: entity_id (UUID, filter relationships involving this entity), relationship_type (str), limit (int=50), offset (int=0).
       - If entity_id provided, filter where source_entity_id OR target_entity_id matches.
       - Return with total count.

    7. `POST /api/cases/{case_id}/relationships` -> RelationshipResponse (status 201)
       - Accept RelationshipCreateRequest body.
       - Verify both source and target entities belong to the case.
       - Create KgRelationship with case_id.
       - Return created relationship.

    **Helper function (private):** `_get_user_case(db, case_id, user_id)` -- reuse the pattern from other API files. Query Case where id=case_id and user_id matches. Return Case or raise 404.

    **backend/app/api/findings.py** (2-line ABOUTME):

    Router prefix: `/api/cases/{case_id}/findings`

    Endpoints:

    1. `GET /api/cases/{case_id}/findings` -> FindingListResponse
       - Query params: agent_type (str, optional), category (str, optional), limit (int=50, default), offset (int=0).
       - Call `findings_service.list_findings()`.
       - Verify case ownership.

    2. `GET /api/cases/{case_id}/findings/{finding_id}` -> FindingResponse
       - Call `findings_service.get_finding_by_id()`.
       - Verify case_id matches.
       - Return 404 if not found.

    3. `GET /api/cases/{case_id}/findings/search` -> FindingSearchResponse
       - Query params: q (str, required), limit (int=20).
       - Call `findings_service.search_findings()`.
       - Return FindingSearchResponse with results and relevance scores.

    IMPORTANT: The `/search` endpoint must be defined BEFORE `/{finding_id}` in the router to avoid the path parameter catching "search" as a finding_id. Alternatively, use a POST endpoint for search or add type validation on finding_id (UUID).
  </action>
  <verify>
    Run `cd backend && python -c "from app.api.knowledge_graph import router as kg_router; from app.api.findings import router as findings_router; print(f'KG routes: {len(kg_router.routes)}, Findings routes: {len(findings_router.routes)}')"` to confirm routers are importable and have routes.
  </verify>
  <done>KG API with 7 endpoints (graph, entities CRUD, relationships CRUD). Findings API with 3 endpoints (list, detail, search). All endpoints follow existing auth/ownership patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Register new routers in main.py</name>
  <files>
    backend/app/main.py
  </files>
  <action>
    Add two new router registrations to `backend/app/main.py`:
    ```python
    from app.api import knowledge_graph, findings
    app.include_router(knowledge_graph.router, tags=["knowledge-graph"])
    app.include_router(findings.router, tags=["findings"])
    ```
    Place these after the existing `agents` and `confirmations` router includes.

    Run `make generate-types && make format` after changes.
  </action>
  <verify>
    Run `cd backend && python -c "from app.main import app; routes = [r.path for r in app.routes]; assert any('graph' in r for r in routes); assert any('findings' in r for r in routes); print('Routers registered in app')"` to confirm registration.

    Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes && make generate-types && make format` to confirm type generation and formatting pass.
  </verify>
  <done>New KG and findings routers registered in main.py. Type generation and formatting pass.</done>
</task>

</tasks>

<verification>
1. KG API endpoints return valid responses (verify route paths exist)
2. Findings API endpoints return valid responses with search support
3. New routers registered in main.py
4. Type check passes, format applied
</verification>

<success_criteria>
- 7 KG API endpoints (graph, entities CRUD, relationships CRUD) operational
- 3 findings API endpoints (list, detail, search) operational
- Both routers registered in main.py
- `make generate-types && make format` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-storage--and--domain-agent-enrichment/07-05-SUMMARY.md`
</output>
