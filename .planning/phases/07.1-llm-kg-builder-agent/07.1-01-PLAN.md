---
phase: 07.1-llm-kg-builder-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/alembic/versions/e4b2c1a37f90_evolve_kg_schema_for_llm_builder.py
  - backend/app/models/knowledge_graph.py
  - backend/app/schemas/kg_builder.py
  - backend/app/schemas/knowledge_graph.py
autonomous: true

must_haves:
  truths:
    - "KgEntity table has columns for aliases, description_brief, description_detailed, domains, source_finding_ids"
    - "KgRelationship table has columns for evidence_excerpt, source_finding_ids, temporal_context, corroboration_count, confidence"
    - "KgBuilderOutput Pydantic schema validates cleanly with Gemini structured output constraints (no dict types, no discriminated unions)"
    - "Existing KG API responses include the new fields when present"
  artifacts:
    - path: "backend/alembic/versions/e4b2c1a37f90_evolve_kg_schema_for_llm_builder.py"
      provides: "Alembic migration adding new columns to kg_entities and kg_relationships"
    - path: "backend/app/models/knowledge_graph.py"
      provides: "Updated SQLAlchemy ORM models with new mapped columns"
    - path: "backend/app/schemas/kg_builder.py"
      provides: "KgBuilderOutput, KgBuilderEntity, KgBuilderRelationship Pydantic models for LLM structured output"
    - path: "backend/app/schemas/knowledge_graph.py"
      provides: "Updated EntityResponse and RelationshipResponse with new fields"
  key_links:
    - from: "backend/app/schemas/kg_builder.py"
      to: "backend/app/models/knowledge_graph.py"
      via: "field names align between LLM output schema and ORM columns"
      pattern: "aliases|description_brief|description_detailed|domains|source_finding_ids"
    - from: "backend/app/schemas/knowledge_graph.py"
      to: "backend/app/models/knowledge_graph.py"
      via: "from_attributes=True reads new ORM columns into API response"
      pattern: "model_config.*from_attributes"
---

<objective>
Create the database schema evolution and Pydantic output schemas needed by the LLM-based KG Builder agent.

Purpose: The LLM KG Builder produces richer data than the programmatic builder -- entities with aliases, multi-domain tags, two-tier descriptions, and traceability to source findings; relationships with evidence excerpts, temporal context, and confidence. The DB and schemas must support this before the agent can be built.

Output: Alembic migration adding new nullable columns, updated ORM models, new KgBuilderOutput schema for Gemini structured output, and updated API response schemas exposing new fields.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-llm-kg-builder-agent/07.1-CONTEXT.md
@.planning/phases/07.1-llm-kg-builder-agent/07.1-RESEARCH.md

@backend/app/models/knowledge_graph.py
@backend/app/schemas/knowledge_graph.py
@backend/app/schemas/agent.py
@backend/alembic/versions/c7a1f8d23e51_add_knowledge_tables.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB Schema Evolution — Alembic Migration + ORM Model Update</name>
  <files>
    backend/alembic/versions/e4b2c1a37f90_evolve_kg_schema_for_llm_builder.py
    backend/app/models/knowledge_graph.py
  </files>
  <action>
Create an Alembic migration that adds new nullable columns to existing `kg_entities` and `kg_relationships` tables. All columns are nullable with defaults so existing data is unaffected.

**KgEntity new columns (add via op.add_column):**
- `aliases` — JSONB, nullable, default null. List of alternative names/references.
- `description_brief` — String(200), nullable. One-liner for tooltips.
- `description_detailed` — Text, nullable. 2-4 sentence paragraph. Semantically replaces `context` but `context` kept for backward compat.
- `domains` — JSONB, nullable. List of source domains (e.g., `["financial", "legal"]`). Authoritative multi-domain list; singular `domain` kept for backward compat.
- `source_finding_ids` — JSONB, nullable. List of case_finding UUIDs linking entity to evidence.

**KgRelationship new columns (add via op.add_column):**
- `evidence_excerpt` — Text, nullable. Exact quote supporting the relationship.
- `source_finding_ids` — JSONB, nullable. Finding IDs as evidence chain.
- `temporal_context` — String(200), nullable. When the relationship existed/occurred.
- `corroboration_count` — Integer, nullable, server_default="1". How many agents found this relationship.
- `confidence` — Float, nullable, server_default="0.0". LLM-assessed relationship confidence.

Use manual migration (no autogenerate), following the pattern in `c7a1f8d23e51_add_knowledge_tables.py`. Set the `Revision ID` to `e4b2c1a37f90` and `down_revision` to `c7a1f8d23e51`. Include downgrade that drops all added columns.

Then update the SQLAlchemy ORM models in `knowledge_graph.py`:
- Add all new columns as `Mapped` fields with appropriate types, all nullable.
- Update the KgEntity docstring to mention "LLM-based KG Builder" replacing "programmatic".
- Update the KgRelationship docstring similarly (replace "co-occurrence analysis" with "semantic relationship extraction").
- Keep all existing columns and indexes intact.
- Keep existing `domain` (singular) and `context` columns for backward compatibility.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "from app.models.knowledge_graph import KgEntity, KgRelationship; print('ORM models load OK'); print('KgEntity columns:', [c.key for c in KgEntity.__table__.columns]); print('KgRelationship columns:', [c.key for c in KgRelationship.__table__.columns])"` — should list all new columns without import errors.
  </verify>
  <done>
    - Alembic migration file exists and is syntactically valid Python
    - KgEntity ORM model has aliases, description_brief, description_detailed, domains, source_finding_ids columns
    - KgRelationship ORM model has evidence_excerpt, source_finding_ids, temporal_context, corroboration_count, confidence columns
    - All new columns are nullable (no schema breakage for existing data)
    - Existing columns (domain, context, etc.) preserved for backward compatibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Pydantic Schemas — KG Builder LLM Output + API Response Updates</name>
  <files>
    backend/app/schemas/kg_builder.py
    backend/app/schemas/knowledge_graph.py
  </files>
  <action>
**Create `backend/app/schemas/kg_builder.py`** — new file with Pydantic models for the LLM's structured output. Start with a 2-line ABOUTME comment.

These schemas define what the Gemini model outputs via constrained decoding. CRITICAL constraints for Gemini structured output:
- No `dict` types (use `list[MetadataEntry]` from `app.schemas.agent` instead).
- No discriminated unions or complex Union types.
- No `additionalProperties` in generated JSON schema.
- All fields explicit (no `**kwargs`).

Models to create:

1. `KgBuilderEntity(BaseModel)`:
   - `id` — int, Field(..., description="Sequential integer ID assigned by you for cross-referencing in relationships"). This is the LLM-assigned local ID (1, 2, 3...) — NOT a database UUID.
   - `name` — str, Field(..., description="Primary canonical name for this entity")
   - `entity_type` — str, Field(..., description="One of: PERSON, ORGANIZATION, LOCATION, EVENT, ASSET, FINANCIAL_ENTITY, COMMUNICATION, DOCUMENT, OTHER")
   - `aliases` — list[str], Field(default_factory=list, description="Alternative names, abbreviations, or references found across all domain agents")
   - `description_brief` — str, Field(..., max_length=200, description="One-liner summary for graph tooltips and cards")
   - `description_detailed` — str, Field(..., max_length=2000, description="2-4 sentence paragraph synthesized from all findings mentioning this entity")
   - `domains` — list[str], Field(..., description="All domains this entity appears in, e.g. ['financial', 'legal']")
   - `confidence` — float, Field(..., ge=0, le=100, description="0-100: how confident the entity exists and is correctly identified")
   - `source_finding_ids` — list[str], Field(default_factory=list, description="UUIDs of case_findings that mention this entity")
   - `properties` — list[MetadataEntry], Field(default_factory=list, description="Additional metadata such as timestamps, amounts, roles")
   - `other_type_explanation` — str, Field(default="", description="Required explanation when entity_type is OTHER — why no core type fits")

2. `KgBuilderRelationship(BaseModel)`:
   - `source_entity_id` — int, Field(..., description="ID of the source entity from the entities list above")
   - `target_entity_id` — int, Field(..., description="ID of the target entity from the entities list above")
   - `relationship_type` — str, Field(..., description="Semantic verb phrase: 'employed_by', 'transferred_funds_to', 'co-signed lease'")
   - `label` — str, Field(..., max_length=200, description="Human-readable edge label for graph display, e.g. 'CEO of', 'Wire transfer to'")
   - `evidence_excerpt` — str, Field(..., max_length=500, description="Exact verbatim quote from source material supporting this relationship")
   - `source_finding_ids` — list[str], Field(default_factory=list, description="UUIDs of case_findings that evidence this relationship")
   - `temporal_context` — str, Field(default="", description="When this relationship existed or occurred, e.g. '2023-Q3', 'January 2024'. Empty if truly unknown.")
   - `confidence` — float, Field(..., ge=0, le=100, description="0-100: confidence in this relationship's accuracy")
   - `strength` — int, Field(default=50, ge=0, le=100, description="Edge weight for graph visualization")

3. `KgBuilderOutput(BaseModel)`:
   - `entities` — list[KgBuilderEntity], Field(..., description="Curated, deduplicated list of investigation-relevant entities")
   - `relationships` — list[KgBuilderRelationship], Field(..., description="Semantic relationships between entities with evidence citations")

Import `MetadataEntry` from `app.schemas.agent` (it already exists and works with Gemini structured output).

**Why integer IDs instead of name matching:** Per RESEARCH.md Open Question 1, using integer IDs eliminates the entity-name-matching problem between the entities list and relationships. The LLM assigns sequential IDs (1, 2, 3...) and relationships reference these IDs. During DB write, we map LLM integer IDs to database UUIDs.

**Update `backend/app/schemas/knowledge_graph.py`** — add new optional fields to `EntityResponse` and `RelationshipResponse` to expose the new columns:

EntityResponse additions:
- `aliases` — list[str] | None = Field(default=None, description="Alternative names/references")
- `description_brief` — str | None = Field(default=None, description="One-liner summary for tooltips")
- `description_detailed` — str | None = Field(default=None, description="Multi-sentence synthesis from findings")
- `domains` — list[str] | None = Field(default=None, description="All domains this entity appears in")
- `source_finding_ids` — list[str] | None = Field(default=None, description="Finding IDs linking entity to evidence")

RelationshipResponse additions:
- `evidence_excerpt` — str | None = Field(default=None, description="Exact source quote supporting this relationship")
- `source_finding_ids` — list[str] | None = Field(default=None, description="Finding IDs as evidence chain")
- `temporal_context` — str | None = Field(default=None, description="When relationship existed/occurred")
- `corroboration_count` — int | None = Field(default=None, description="How many agents found this relationship")
- `confidence` — float | None = Field(default=None, description="LLM-assessed relationship confidence 0-100")

All new fields are Optional so existing API responses (from pre-LLM data) remain valid.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "
from app.schemas.kg_builder import KgBuilderOutput, KgBuilderEntity, KgBuilderRelationship
from app.schemas.knowledge_graph import EntityResponse, RelationshipResponse

# Verify KgBuilderOutput schema generates valid JSON schema
schema = KgBuilderOutput.model_json_schema()
print('KgBuilderOutput schema keys:', list(schema.get('properties', {}).keys()))

# Verify no 'additionalProperties' in any sub-schema (Gemini constraint)
import json
schema_str = json.dumps(schema)
assert 'additionalProperties' not in schema_str, 'Schema contains additionalProperties!'

# Verify EntityResponse has new fields
er = EntityResponse.model_fields
assert 'aliases' in er, 'Missing aliases field'
assert 'description_brief' in er, 'Missing description_brief field'
assert 'domains' in er, 'Missing domains field'

# Verify RelationshipResponse has new fields
rr = RelationshipResponse.model_fields
assert 'evidence_excerpt' in rr, 'Missing evidence_excerpt field'
assert 'temporal_context' in rr, 'Missing temporal_context field'
assert 'confidence' in rr, 'Missing confidence field'

print('All schema validations passed')
"` — should print "All schema validations passed" without errors.
  </verify>
  <done>
    - `backend/app/schemas/kg_builder.py` exists with KgBuilderOutput, KgBuilderEntity, KgBuilderRelationship
    - LLM output schema uses integer IDs for entity cross-referencing (not name matching)
    - No `dict` types in schema (uses list[MetadataEntry] for properties)
    - EntityResponse includes aliases, description_brief, description_detailed, domains, source_finding_ids
    - RelationshipResponse includes evidence_excerpt, source_finding_ids, temporal_context, corroboration_count, confidence
    - All new API response fields are Optional (backward compatible)
    - JSON schema validates without Gemini-incompatible constructs
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes && make generate-types && make format` — type generation and formatting pass
2. `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "from app.models.knowledge_graph import KgEntity, KgRelationship; from app.schemas.kg_builder import KgBuilderOutput; from app.schemas.knowledge_graph import EntityResponse, RelationshipResponse; print('All imports OK')"` — all modules import cleanly
3. Alembic migration file is syntactically valid and has proper upgrade/downgrade
4. ORM model columns match migration columns exactly
</verification>

<success_criteria>
- Alembic migration adds 10 new columns (5 on KgEntity, 5 on KgRelationship) as nullable
- ORM models expose all new columns as Mapped fields
- KgBuilderOutput schema is Gemini-structured-output-compatible (no dict, no Union, no additionalProperties)
- KgBuilderEntity uses integer `id` field for LLM cross-referencing
- API response schemas expose new fields as Optional
- All existing code continues to work (no schema breaks)
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-llm-kg-builder-agent/07.1-01-SUMMARY.md`
</output>
