---
phase: 07.1-llm-kg-builder-agent
plan: 02
type: execute
wave: 2
depends_on: ["07.1-01"]
files_modified:
  - backend/app/agents/kg_builder.py
  - backend/app/agents/prompts/kg_builder.py
  - backend/app/agents/factory.py
  - backend/app/services/kg_builder.py
  - backend/app/services/pipeline.py
autonomous: true

must_haves:
  truths:
    - "KG Builder agent receives all case_findings text + domain entity lists + case description as text-only input"
    - "KG Builder agent produces a KgBuilderOutput with curated entities (integer IDs) and semantic relationships"
    - "Old kg_entities and kg_relationships for the case are cleared before writing curated data"
    - "Entity degrees are computed after curated data is written"
    - "Pipeline replaces programmatic build_knowledge_graph() with LLM-based KG Builder invocation"
    - "KG Builder failure does NOT block the pipeline — logs error, emits SSE, pipeline continues"
    - "SSE events fire: KG Builder started, progress updates via thinking traces, KG Builder complete/error"
    - "Existing KG API endpoints return curated data without any changes to API routes"
  artifacts:
    - path: "backend/app/agents/kg_builder.py"
      provides: "KgBuilderAgentRunner subclass + run_kg_builder() + input assembly + DB write logic"
      min_lines: 150
    - path: "backend/app/agents/prompts/kg_builder.py"
      provides: "KG_BUILDER_SYSTEM_PROMPT constant with entity taxonomy + relationship instructions"
      min_lines: 60
    - path: "backend/app/agents/factory.py"
      provides: "AgentFactory.create_kg_builder_agent() static method"
    - path: "backend/app/services/kg_builder.py"
      provides: "Refactored: old programmatic functions preserved but marked deprecated; normalize_entity_name() and compute_entity_degrees() kept"
    - path: "backend/app/services/pipeline.py"
      provides: "Stage 7 replaced with LLM KG Builder invocation wrapped in try/except"
  key_links:
    - from: "backend/app/agents/kg_builder.py"
      to: "backend/app/schemas/kg_builder.py"
      via: "KgBuilderOutput used as output_type in runner"
      pattern: "KgBuilderOutput"
    - from: "backend/app/agents/kg_builder.py"
      to: "backend/app/models/knowledge_graph.py"
      via: "writes curated entities/relationships to ORM models"
      pattern: "KgEntity|KgRelationship"
    - from: "backend/app/services/pipeline.py"
      to: "backend/app/agents/kg_builder.py"
      via: "pipeline calls run_kg_builder() instead of build_knowledge_graph()"
      pattern: "run_kg_builder"
    - from: "backend/app/agents/factory.py"
      to: "backend/app/agents/prompts/kg_builder.py"
      via: "lazy import of KG_BUILDER_SYSTEM_PROMPT"
      pattern: "KG_BUILDER_SYSTEM_PROMPT"
---

<objective>
Build the LLM-based KG Builder agent, wire it into the pipeline, and replace the programmatic KG builder.

Purpose: The programmatic KG Builder produces noisy graphs with co-occurrence relationships, zero entity filtering, and incomplete deduplication. The LLM-based agent reads ALL domain findings holistically, producing curated entities with semantic relationships, natural deduplication, and cross-domain connections — directly improving graph quality for Phase 7.2 frontend and Phase 8 synthesis.

Output: Working KG Builder agent that runs in the pipeline after domain agents complete, producing curated knowledge graph data in existing DB tables.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-llm-kg-builder-agent/07.1-CONTEXT.md
@.planning/phases/07.1-llm-kg-builder-agent/07.1-RESEARCH.md
@.planning/phases/07.1-llm-kg-builder-agent/07.1-01-SUMMARY.md

@backend/app/agents/strategy.py
@backend/app/agents/domain_agent_runner.py
@backend/app/agents/factory.py
@backend/app/agents/base.py
@backend/app/agents/parsing.py
@backend/app/services/pipeline.py
@backend/app/services/kg_builder.py
@backend/app/services/agent_events.py
@backend/app/services/adk_service.py
@backend/app/services/findings_service.py
@backend/app/models/knowledge_graph.py
@backend/app/schemas/kg_builder.py
@backend/app/schemas/knowledge_graph.py
@backend/app/schemas/agent.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: KG Builder Agent — Runner, Factory, Prompt, Input Assembly, DB Write</name>
  <files>
    backend/app/agents/kg_builder.py
    backend/app/agents/prompts/kg_builder.py
    backend/app/agents/factory.py
    backend/app/services/kg_builder.py
  </files>
  <action>
**Create `backend/app/agents/prompts/kg_builder.py`** — new file with 2-line ABOUTME comment. Define `KG_BUILDER_SYSTEM_PROMPT` constant (str).

The prompt must instruct the LLM to:
1. Read ALL provided domain agent findings and entity lists holistically.
2. Extract only investigation-relevant entities using the 8+1 taxonomy: PERSON, ORGANIZATION, LOCATION, EVENT, ASSET, FINANCIAL_ENTITY, COMMUNICATION, DOCUMENT, OTHER. When using OTHER, the `other_type_explanation` field must explain why no core type fits.
3. Do NOT create standalone nodes for timestamps, monetary amounts, or physical objects — these are metadata (properties) on entities and relationships. EXCEPTION per CONTEXT.md: if an item is investigation-critical (e.g., a central $2M wire transfer), it MAY become its own FINANCIAL_ENTITY or EVENT entity — use judgment.
4. Assign each entity a sequential integer `id` (1, 2, 3...) for cross-referencing in relationships.
5. Deduplicate entities across all domain agents conservatively — merge ONLY when highly confident (same full name, same role). Keep separate if ambiguous. Populate `aliases` with all name variants found across agents. Resolve coreference (e.g., 'the CEO' in doc A + 'John Smith, CEO' in doc B) only with clear textual evidence.
6. Tag each entity with ALL domains it appears in (`domains` list), not a single primary domain.
7. Write two-tier descriptions: `description_brief` (one-liner for tooltips, max 200 chars) and `description_detailed` (2-4 sentence paragraph synthesized from all findings mentioning the entity).
8. Create semantic relationships with free-form `relationship_type` labels (verbs: 'employed_by', 'transferred_funds_to', 'owns', 'allegedly bribed'). NOT co-occurrence labels.
9. Every relationship MUST include `evidence_excerpt` — an exact verbatim quote from the findings supporting it.
10. Every relationship MUST include `temporal_context` when source material mentions dates/times. Leave empty ONLY when truly unknown.
11. Reference entities by their integer `id` in relationship `source_entity_id` and `target_entity_id`.
12. Reference source findings by the UUIDs provided in the input (prefixed as `[FINDING:uuid]`).
13. Do NOT flag suspicious or anomalous relationships — that is the Synthesis Agent's job. The KG Builder is a factual extractor.
14. Do NOT include a graph summary — entities and relationships are enough.
15. Merge duplicate relationships between the same entity pair into one edge with combined evidence. Track corroboration (how many agents independently found it) via listing multiple source_finding_ids.

**Create `backend/app/agents/kg_builder.py`** — new file with 2-line ABOUTME comment. Contains:

1. `KgBuilderAgentRunner(DomainAgentRunner[KgBuilderOutput])` subclass following the Strategy pattern:
   - `get_agent_name()` returns `"kg_builder"`
   - `_get_output_type()` returns `KgBuilderOutput`
   - `_create_agent_instance()` calls `AgentFactory.create_kg_builder_agent()`
   - `_prepare_content()` builds text-only Content from three sources:
     a. Case description
     b. All case_findings (queried from DB, formatted with `[FINDING:{uuid}]` prefix per finding, grouped by agent_type)
     c. All DomainEntity structured lists from domain_results (serialized as JSON)
     No multimodal files — text only.

2. `async def assemble_kg_builder_input(case_id, domain_results, db)` function that:
   - Queries all `CaseFinding` rows for the case, ordered by agent_type and created_at
   - Formats findings as: `[FINDING:{finding.id}] [{finding.agent_type}] {finding.title}\n{finding.finding_text}\n`
   - Extracts DomainEntity lists from domain_results (iterate over DomainRunResult.output.entities, serialize each as JSON with type/value/confidence/metadata)
   - Queries Case.description for context
   - Returns tuple of (findings_text, entities_json, case_description)

3. `async def write_kg_from_llm_output(case_id, output, execution_id, db)` function that:
   - Deletes all existing `KgRelationship` rows for the case (delete relationships first due to FK)
   - Deletes all existing `KgEntity` rows for the case
   - Flushes
   - Inserts entities from output.entities, building a mapping: `llm_int_id -> db_uuid`
   - For each entity: create KgEntity with name, name_normalized (via `normalize_entity_name`), entity_type, domain (first from domains list for backward compat), confidence, properties (from entity.properties list -> dict), context=description_detailed, aliases (JSONB), description_brief, description_detailed, domains (JSONB), source_finding_ids (JSONB), source_execution_id. Wrap each in try/except — skip malformed, log warning (lenient parsing per CONTEXT.md).
   - Inserts relationships from output.relationships, resolving source_entity_id and target_entity_id via the llm_int_id->db_uuid map. Wrap each in try/except — skip unresolved entities, log warning.
   - For each relationship: create KgRelationship with relationship_type, label, strength, evidence_excerpt, source_finding_ids (JSONB), temporal_context, confidence, corroboration_count (len of source_finding_ids), source_execution_id, properties (dict with any overflow data).
   - Calls `compute_entity_degrees(case_id, db)` from existing kg_builder.py
   - Flushes
   - Returns tuple of (entities_written, relationships_written)

4. `async def run_kg_builder(case_id, workflow_id, user_id, domain_results, db_session, publish_event)` top-level function:
   - Assembles input via assemble_kg_builder_input()
   - Calls KgBuilderAgentRunner().run() with the assembled text passed via kwargs
   - If output is not None: calls write_kg_from_llm_output() and returns (entities_count, relationships_count)
   - If output is None: logs warning, returns (0, 0)
   - Does NOT catch exceptions — the caller (pipeline.py) wraps this in try/except

Import `normalize_entity_name` and `compute_entity_degrees` from `app.services.kg_builder` (reuse existing functions — do NOT reimplement).

**Update `backend/app/agents/factory.py`** — add `create_kg_builder_agent()` static method:
- Lazy-imports KG_BUILDER_SYSTEM_PROMPT and KgBuilderOutput
- Uses `MODEL_PRO` default, `create_thinking_planner("high")`
- output_key = "kg_builder_result"
- No generate_content_config needed (text-only input, no media)
- Follows exact pattern of `create_strategy_agent()` but without media_resolution

**Update `backend/app/services/kg_builder.py`** — mark old functions with deprecation comments:
- Add comment at top of `extract_entities_from_output`, `build_relationships_from_findings`, `deduplicate_entities`, `build_knowledge_graph`: `# DEPRECATED: Replaced by LLM-based KG Builder agent (Phase 7.1). Kept for reference.`
- Keep `normalize_entity_name()` and `compute_entity_degrees()` — these are reused by the LLM builder.
- Do NOT delete any functions (backward compat, audit trail).
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "
from app.agents.kg_builder import KgBuilderAgentRunner, run_kg_builder, assemble_kg_builder_input, write_kg_from_llm_output
from app.agents.factory import AgentFactory
from app.agents.prompts.kg_builder import KG_BUILDER_SYSTEM_PROMPT

# Verify factory method exists
agent = AgentFactory.create_kg_builder_agent('test-case-id')
print(f'KG Builder agent created: {agent.name}')
print(f'Model: {agent.model}')
print(f'Output key: {agent.output_key}')
print(f'Prompt length: {len(KG_BUILDER_SYSTEM_PROMPT)} chars')

# Verify runner instantiation
runner = KgBuilderAgentRunner()
print(f'Runner agent name: {runner.get_agent_name()}')

print('All agent imports and instantiation OK')
"` — should print agent details without errors.
  </verify>
  <done>
    - KgBuilderAgentRunner subclasses DomainAgentRunner following Strategy pattern
    - Factory method creates fresh KG Builder agent with Pro model and high thinking
    - System prompt instructs entity taxonomy, semantic relationships, dedup, integer IDs, evidence grounding
    - Input assembly queries case_findings + extracts domain entities + gets case description
    - DB write clears old KG data, inserts curated entities/relationships with lenient parsing
    - Entity degrees computed post-write via reused compute_entity_degrees()
    - Old programmatic builder functions marked deprecated but preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Pipeline Wiring — Replace Programmatic KG Builder with LLM Agent</name>
  <files>
    backend/app/services/pipeline.py
  </files>
  <action>
Modify `backend/app/services/pipeline.py` to replace Stage 7 (lines ~968-1003, the `build_knowledge_graph()` call) with the LLM-based KG Builder agent invocation.

**Changes to make:**

1. **Update imports at the top of `run_analysis_workflow()`** (inside the function body, following existing lazy import pattern):
   - Replace: `from app.services.kg_builder import build_knowledge_graph`
   - With: `from app.agents.kg_builder import run_kg_builder`
   - Keep all other existing imports.

2. **Replace Stage 7 block** (currently lines ~968-1003). The new Stage 7 should:

   a. Still add strategy output to domain_results (keep lines ~974-983 that append strategy DomainRunResult).

   b. Emit KG Builder started event:
      ```python
      kg_builder_task_id = str(uuid4())
      await emit_agent_started(
          case_id=case_id,
          agent_type="kg_builder",
          task_id=kg_builder_task_id,
          file_id="",
          file_name="knowledge-graph-builder",
      )
      ```

   c. Wrap the KG Builder invocation in try/except (per CONTEXT.md: fail gracefully, continue pipeline):
      ```python
      try:
          kg_entities_created, kg_relationships_created = await run_kg_builder(
              case_id=case_id,
              workflow_id=workflow_id,
              user_id=user_id,
              domain_results=domain_results,
              db_session=db,
              publish_event=publish_fn,
          )
          await emit_agent_complete(
              case_id=case_id,
              agent_type="kg_builder",
              task_id=kg_builder_task_id,
              result={
                  "taskId": kg_builder_task_id,
                  "agentType": "kg_builder",
                  "outputs": [{
                      "type": "kg-builder-results",
                      "data": {
                          "entitiesCreated": kg_entities_created,
                          "relationshipsCreated": kg_relationships_created,
                      },
                  }],
              },
          )
      except Exception as exc:
          logger.exception("KG Builder failed for case=%s: %s", case_id, exc)
          kg_entities_created = 0
          kg_relationships_created = 0
          await emit_agent_error(
              case_id=case_id,
              agent_type="kg_builder",
              task_id=kg_builder_task_id,
              error=str(exc)[:500],
          )
      ```

   d. Keep `await db.commit()` after the KG Builder block.

3. **Remove the old `kg_exact_merges` variable** from the unpacking. The LLM builder returns `(entities_created, relationships_created)` — a 2-tuple, not 3-tuple.

4. **Update the KG build complete log** (line ~997-1003): Remove `merges=%d` from the format string since the LLM builder doesn't report merges.

5. **Update Stage 7b (backfill finding-to-entity links)**: The LLM builder already populates `source_finding_ids` on entities directly. Stage 7b can be simplified or kept as-is for backward compat — the execution-based backfill still works because `source_execution_id` is set. Keep it as-is (no change needed).

6. **Update the final `emit_processing_complete` call**: Replace `kg_entities_created` reference — it still works since we kept the variable name. Remove `+ kg_exact_merges` if it existed in any count.

7. **Important: do NOT change any code before Stage 7 or after the processing-complete event.** Only modify the Stage 7 block and its immediate surroundings.
  </action>
  <verify>
Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "
from app.services.pipeline import run_analysis_workflow
import inspect
source = inspect.getsource(run_analysis_workflow)
assert 'run_kg_builder' in source, 'Missing run_kg_builder import/call'
assert 'build_knowledge_graph' not in source, 'Old build_knowledge_graph still referenced'
assert 'kg_builder_task_id' in source, 'Missing KG Builder SSE task ID'
assert 'emit_agent_started' in source, 'Missing KG Builder started event'
assert 'emit_agent_error' in source, 'Missing KG Builder error handling'
print('Pipeline wiring verified')
"` — should print "Pipeline wiring verified" without errors.

Additionally verify the full module imports cleanly:
`python -c "from app.services import pipeline; print('Pipeline module loads OK')"` — no import errors.
  </verify>
  <done>
    - Pipeline Stage 7 calls run_kg_builder() instead of build_knowledge_graph()
    - KG Builder failure wrapped in try/except — logs error, emits SSE error event, pipeline continues with kg_entities_created=0
    - SSE lifecycle events: agent-started before KG Builder, agent-complete/agent-error after
    - Strategy output still appended to domain_results before KG Builder invocation
    - Stage 7b (backfill) preserved for backward compat
    - No changes to pipeline stages 1-6 or post-processing
    - Old build_knowledge_graph import removed from pipeline
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes && make generate-types && make format` — type generation and formatting pass
2. `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "from app.agents.kg_builder import run_kg_builder; from app.services.pipeline import run_analysis_workflow; from app.agents.factory import AgentFactory; print('Full import chain OK')"` — all modules in the chain import cleanly
3. Pipeline source code references `run_kg_builder` and does NOT reference `build_knowledge_graph`
4. KG Builder agent creates successfully via factory with correct model and thinking config
5. Old programmatic builder functions are marked deprecated but still importable (no breakage for any code that might reference them)
</verification>

<success_criteria>
- KG Builder Agent runs as a Gemini Pro LlmAgent with HIGH thinking, receiving text-only input
- Input assembled from case_findings (with [FINDING:uuid] prefixes) + DomainEntity JSON + case description
- Output parsed via KgBuilderOutput schema with integer-ID-based entity/relationship cross-referencing
- DB write clears old KG data, inserts curated data with lenient parsing (skip malformed, log warnings)
- Entity degrees computed after curated data is written
- Pipeline calls run_kg_builder() in try/except — failure is non-blocking
- SSE events fire for KG Builder lifecycle (started, thinking traces via callbacks, complete/error)
- Existing KG API endpoints (`GET /api/cases/:caseId/graph`) return the curated data without any API route changes
- Old programmatic builder functions preserved as deprecated
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-llm-kg-builder-agent/07.1-02-SUMMARY.md`
</output>
