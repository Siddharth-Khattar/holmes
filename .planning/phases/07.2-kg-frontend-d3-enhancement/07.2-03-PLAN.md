---
phase: 07.2-kg-frontend-d3-enhancement
plan: 03
type: execute
wave: 2
depends_on: ["07.2-01"]
files_modified:
  - frontend/src/components/knowledge-graph/GraphSvg.tsx
  - frontend/src/hooks/useGraphSimulation.ts
  - frontend/src/hooks/useGraphSelection.ts
autonomous: true

must_haves:
  truths:
    - "D3 force simulation runs with 5 forces (link, charge, center, collision, radial) and updates node positions via D3 selection refs, NOT React state"
    - "High-connection entities are visually closer to the center (radial force pulls them inward)"
    - "Node radius is sqrt-scaled from degree (10-60px range via d3.scalePow)"
    - "Clicking a node highlights it + connected edges, dims unconnected nodes/edges to ~20% opacity"
    - "Clicking same node again deselects and restores all to normal opacity"
    - "Selection highlighting runs in a separate useEffect that does NOT re-create or re-run the simulation"
    - "Nodes can be dragged, zoomed, and panned"
    - "Edges between the same entity pair are deduplicated into a single rendered line with a count badge"
    - "Search match highlighting applies a distinct accent glow ring to matching nodes, separate from selection dimming"
  artifacts:
    - path: "frontend/src/components/knowledge-graph/GraphSvg.tsx"
      provides: "D3 force-directed graph SVG canvas with nodes, edges, labels, zoom, drag, search highlight"
      min_lines: 150
    - path: "frontend/src/hooks/useGraphSimulation.ts"
      provides: "D3 force simulation lifecycle management"
      exports: ["useGraphSimulation"]
    - path: "frontend/src/hooks/useGraphSelection.ts"
      provides: "Selection state, DOM highlighting, and search match highlighting without re-running simulation"
      exports: ["useGraphSelection"]
  key_links:
    - from: "frontend/src/hooks/useGraphSimulation.ts"
      to: "frontend/src/lib/knowledge-graph-config.ts"
      via: "FORCE_CONFIG import for simulation parameters"
      pattern: "FORCE_CONFIG"
    - from: "frontend/src/hooks/useGraphSelection.ts"
      to: "D3 selection refs"
      via: "nodeGroupRef and linkGroupRef for direct DOM updates"
      pattern: "nodeGroupRef|linkGroupRef"
    - from: "frontend/src/components/knowledge-graph/GraphSvg.tsx"
      to: "frontend/src/hooks/useGraphSimulation.ts"
      via: "hook call for simulation lifecycle"
      pattern: "useGraphSimulation"
    - from: "frontend/src/components/knowledge-graph/GraphSvg.tsx"
      to: "searchMatchIds prop"
      via: "passed to useGraphSelection for search highlight effect"
      pattern: "searchMatchIds"
---

<objective>
Build the core D3.js force-directed graph canvas — the heart of the KG visualization — decomposed from the 1370-line monolith into modular components with correct performance patterns.

Purpose: This is the central visual component of Phase 7.2. The existing `knowledge-graph.tsx` uses React state per simulation tick (60fps re-renders) which is the primary performance bottleneck. This plan creates the GraphSvg component using stored D3 selection refs for tick updates (zero React re-renders during simulation), with a separate selection effect for click highlighting (no simulation restart on click).

Output: `GraphSvg.tsx` component rendering the force-directed graph, `useGraphSimulation.ts` hook managing D3 simulation lifecycle, `useGraphSelection.ts` hook managing selection highlighting and search match highlighting.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-kg-frontend-d3-enhancement/07.2-CONTEXT.md
@.planning/phases/07.2-kg-frontend-d3-enhancement/07.2-RESEARCH.md
@.planning/phases/07.2-kg-frontend-d3-enhancement/07.2-01-SUMMARY.md
@frontend/src/types/knowledge-graph.ts
@frontend/src/lib/knowledge-graph-config.ts
@frontend/src/components/app/knowledge-graph.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useGraphSimulation and useGraphSelection hooks</name>
  <files>
    frontend/src/hooks/useGraphSimulation.ts
    frontend/src/hooks/useGraphSelection.ts
  </files>
  <action>
    **A) Create `frontend/src/hooks/useGraphSimulation.ts`**

    ABOUTME comment. This hook manages the D3 force simulation lifecycle: creating, configuring, starting, and stopping the simulation. It transforms raw API data (EntityResponse[], RelationshipResponse[]) into ForceNode[] and ForceLink[] arrays, then builds and manages the d3.forceSimulation.

    **Input props:**
    ```typescript
    interface UseGraphSimulationProps {
      entities: EntityResponse[];
      relationships: RelationshipResponse[];
      width: number;
      height: number;
      svgRef: RefObject<SVGSVGElement | null>;
    }
    ```

    **Returned values:**
    ```typescript
    interface UseGraphSimulationReturn {
      forceNodes: ForceNode[];
      forceLinks: ForceLink[];
      simulationRef: MutableRefObject<Simulation<ForceNode, ForceLink> | null>;
      nodeGroupRef: MutableRefObject<d3.Selection<SVGGElement, ForceNode, SVGGElement, unknown> | null>;
      linkGroupRef: MutableRefObject<d3.Selection<SVGLineElement, ForceLink, SVGGElement, unknown> | null>;
      labelGroupRef: MutableRefObject<d3.Selection<SVGTextElement, ForceNode, SVGGElement, unknown> | null>;
      zoomRef: MutableRefObject<ZoomBehavior<SVGSVGElement, unknown> | null>;
      isSimulationRunning: boolean;
      toggleSimulation: () => void;
      resetZoom: () => void;
    }
    ```

    **Implementation steps:**

    1. **Data transformation (useMemo):**
       - Transform `EntityResponse[]` into `ForceNode[]`:
         - Compute `radius` using `scalePow().exponent(0.5).domain([0, maxDegree]).range([NODE_SIZE.minRadius, NODE_SIZE.maxRadius]).clamp(true)` from d3-scale
         - Compute `color` using `getEntityColor(entity.entity_type)` from config
       - Transform `RelationshipResponse[]` into deduplicated `ForceLink[]`:
         - Build edge map with canonical key: sort [source_entity_id, target_entity_id] alphabetically, join with `|||`
         - Each ForceLink holds an array of all RelationshipResponse objects between that entity pair + count
         - ForceLink.id = the canonical key
         - ForceLink.source / target = entity IDs (D3 will resolve to ForceNode objects)

    2. **Simulation setup (useEffect, depends on entities/relationships/width/height):**
       - Create `d3.forceSimulation<ForceNode>(forceNodes)`
       - Configure 5 forces using `FORCE_CONFIG` from config:
         - `forceLink<ForceLink, ForceNode>(forceLinks).id(d => d.id).distance(FORCE_CONFIG.link.distance).strength(FORCE_CONFIG.link.strength)`
           - Note: The ForceLink.id here is the entity node ID, but forceLink needs the node accessor. Use `.id((d: ForceNode) => d.id)` on the link force, and ensure ForceLink.source/target reference ForceNode.id values.
         - `forceManyBody().strength(FORCE_CONFIG.charge.strength)`
         - `forceCenter(width / 2, height / 2).strength(FORCE_CONFIG.center.strength)`
         - `forceCollide<ForceNode>().radius((d) => d.radius + FORCE_CONFIG.collision.padding)`
         - `forceRadial<ForceNode>()` — radius function: high degree = small radius (center), low degree = large radius (periphery). See RESEARCH.md Pattern 4 for the formula:
           ```
           const maxConnections = Math.max(...forceNodes.map(n => n.entity.degree), 1);
           const maxRadius = Math.min(width, height) * 0.35;
           const minRadius = FORCE_CONFIG.radial.minRadius;
           radius: (d) => maxRadius - (d.entity.degree / maxConnections) * (maxRadius - minRadius)
           strength: (d) => FORCE_CONFIG.radial.strengthBase + (d.entity.degree / maxConnections) * FORCE_CONFIG.radial.strengthScale
           ```
       - Store simulation in `simulationRef`

    3. **SVG rendering (useEffect, same as simulation setup):**
       Using `d3.select(svgRef.current)`:
       - Create zoom behavior with `d3Zoom<SVGSVGElement, unknown>().scaleExtent(SVG_CONFIG.zoomExtent)`, store in `zoomRef`
       - Create main `<g>` group that transforms on zoom
       - Create `<defs>` for node glow filter (keep existing pattern from current knowledge-graph.tsx)
       - Create link group: `<line>` elements for each ForceLink, with:
         - `stroke: EDGE_STYLE.defaultColor`
         - `stroke-width` scaled from ForceLink's primary relationship strength (0-100 -> EDGE_STYLE.minWidth to EDGE_STYLE.maxWidth)
         - `stroke-opacity: EDGE_STYLE.defaultOpacity`
       - Create edge label group: `<text>` elements for each ForceLink showing the label. For deduplicated edges with count > 1, show `"{label} (+{count-1} more)"`. Horizontal orientation always (no rotation).
       - Create node group: `<circle>` elements for each ForceNode, with:
         - `r: node.radius`
         - `fill: node.color`
         - `filter: url(#node-glow)`
         - `cursor: pointer`
       - Create label group: `<text>` elements below each node circle showing `entity.name`, font-size from SVG_CONFIG, truncated if needed
       - Store all D3 selections in their respective refs (`nodeGroupRef`, `linkGroupRef`, `labelGroupRef`)
       - Add drag behavior on nodes using `d3.drag<SVGCircleElement, ForceNode>()`:
         - dragstarted: set `d.fx = d.x; d.fy = d.y`, reheat simulation with `alphaTarget(0.3).restart()`
         - dragged: `d.fx = event.x; d.fy = event.y`
         - dragended: `d.fx = null; d.fy = null`, simulation `alphaTarget(0)`

    4. **Tick handler (CRITICAL — use D3 refs, NOT React state):**
       ```typescript
       simulation.on('tick', () => {
         linkGroupRef.current
           ?.attr('x1', d => (d.source as ForceNode).x!)
           .attr('y1', d => (d.source as ForceNode).y!)
           .attr('x2', d => (d.target as ForceNode).x!)
           .attr('y2', d => (d.target as ForceNode).y!);

         // Edge labels at midpoint, always horizontal
         edgeLabelGroupRef.current
           ?.attr('x', d => ((d.source as ForceNode).x! + (d.target as ForceNode).x!) / 2)
           .attr('y', d => ((d.source as ForceNode).y! + (d.target as ForceNode).y!) / 2);

         nodeGroupRef.current
           ?.attr('cx', d => d.x!)
           .attr('cy', d => d.y!);

         labelGroupRef.current
           ?.attr('x', d => d.x!)
           .attr('y', d => d.y! + d.radius + SVG_CONFIG.labelOffset);
       });
       ```
       ABSOLUTELY NO `setState` or `requestAnimationFrame(() => setState(...))` in the tick handler.

    5. **Cleanup:** Return cleanup function that stops simulation and removes SVG children.

    6. **Toggle simulation:** Function to pause/resume (set `alphaTarget(0)` to pause, `alpha(0.3).restart()` to resume).

    7. **Reset zoom:** Function to reset zoom transform to identity with smooth transition.

    **B) Create `frontend/src/hooks/useGraphSelection.ts`**

    ABOUTME comment. This hook manages selection state, applies visual highlighting via D3 selection refs, AND handles search match highlighting — completely SEPARATE from the simulation lifecycle.

    **Input props:**
    ```typescript
    interface UseGraphSelectionProps {
      nodeGroupRef: MutableRefObject<d3.Selection<...> | null>;
      linkGroupRef: MutableRefObject<d3.Selection<...> | null>;
      labelGroupRef: MutableRefObject<d3.Selection<...> | null>;
      forceNodes: ForceNode[];
      forceLinks: ForceLink[];
      searchMatchIds?: Set<string>;  // Entity IDs matching search query (from useGraphFilters)
    }
    ```

    **Returned values:**
    ```typescript
    interface UseGraphSelectionReturn {
      selectedEntityId: string | null;
      connectedEntityIds: Set<string>;
      selectEntity: (entityId: string | null) => void;
    }
    ```

    **Implementation:**
    1. `selectedEntityId` state (string | null)
    2. `connectedEntityIds` derived (useMemo): for the selected entity, collect all entity IDs connected via any ForceLink
    3. `selectEntity(id)`: if id === selectedEntityId, deselect (set null); otherwise set id
    4. **Selection highlighting useEffect** (depends ONLY on `selectedEntityId`):
       - If no selection: restore all nodes to full opacity, all edges to default color/opacity
       - If selected:
         - Selected node: add accent glow/border (stroke: white, stroke-width: 3)
         - Connected nodes: full opacity
         - Unconnected nodes: opacity 0.2
         - Connected edges: stroke white, opacity 1
         - Unconnected edges: opacity 0.15
         - Labels: same opacity as their node
       - This effect ONLY modifies visual attributes via D3 refs. It does NOT touch the simulation.

    5. **Search match highlighting useEffect** (depends ONLY on `searchMatchIds`):
       - This is a SEPARATE useEffect from the selection highlighting effect.
       - If `searchMatchIds` is undefined/empty: remove any search highlight styling from all nodes.
       - If `searchMatchIds` has entries:
         - Matching nodes: apply a distinct accent glow ring — use a bright stroke (e.g., `#F5F4EF` smoke or a warm accent like `#E87461` coral) with `stroke-width: 3` and `stroke-opacity: 1`. This ring is VISUALLY DISTINCT from the selection white border.
         - Non-matching nodes: reduce opacity to ~0.3 (but do NOT hide them — search highlights, it does not filter).
         - Non-matching edges: reduce opacity to ~0.2.
         - Matching node labels: full opacity.
         - Non-matching labels: reduced opacity.
       - IMPORTANT: When BOTH selection AND search are active, selection takes priority for the selected node's subgraph. Search highlighting applies to the remaining non-selected nodes. The two effects should compose gracefully — if a node is both selected AND matches search, it gets the selection style (white border).

    **CRITICAL PERFORMANCE PATTERN (from RESEARCH.md Pitfall 2):**
    The selection useEffect and search highlight useEffect must NOT be in the same effect as simulation setup. They depend ONLY on their respective state (and the ref objects, which are stable). When the user clicks a node or types in search, ONLY the relevant effect runs — the simulation continues undisturbed.

    6. **Click handler setup:** The hook should expose `selectEntity` which the GraphSvg component calls when a node's `<circle>` is clicked. The click handler is attached in GraphSvg (not in this hook) because the node elements are created in the simulation hook.
  </action>
  <verify>
    1. `cd frontend && bun run typecheck` — both hooks type-check with no errors
    2. `useGraphSimulation` does NOT contain `setState` or `setNodePositions` in the tick handler — verify with grep:
       ```
       grep -n "setState\|setNode" frontend/src/hooks/useGraphSimulation.ts
       ```
       Should return zero results.
    3. `useGraphSelection` has a useEffect that depends only on `selectedEntityId` AND a separate useEffect that depends on `searchMatchIds`:
       ```
       grep -A1 "useEffect" frontend/src/hooks/useGraphSelection.ts
       ```
       Should show both `[selectedEntityId]` and `[searchMatchIds]` in dependency arrays.
    4. No `any` types in either file
    5. Both files have ABOUTME comments
  </verify>
  <done>
    `useGraphSimulation` manages D3 force simulation with 5 forces, D3 ref-based tick updates (zero React re-renders), sqrt-scaled node radius, radial centrality force, edge deduplication, drag/zoom. `useGraphSelection` manages selection highlighting AND search match highlighting in separate effects that do not restart simulation. Search highlighting applies a distinct accent glow ring to matching nodes. Both hooks have correct TypeScript types with no `any`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GraphSvg component</name>
  <files>
    frontend/src/components/knowledge-graph/GraphSvg.tsx
  </files>
  <action>
    ABOUTME comment: Core D3 force-directed graph SVG canvas for knowledge graph visualization. Uses stored D3 selection refs for tick updates.

    Create `frontend/src/components/knowledge-graph/GraphSvg.tsx`.

    **Props:**
    ```typescript
    interface GraphSvgProps {
      entities: EntityResponse[];
      relationships: RelationshipResponse[];
      onEntitySelect: (entityId: string | null) => void;
      selectedEntityId: string | null;
      searchMatchIds?: Set<string>;
      className?: string;
    }
    ```

    Note: The `searchMatchIds` prop is passed down from the parent (KnowledgeGraphCanvas in Plan 05) and forwarded to `useGraphSelection` to enable search highlighting directly on the graph nodes.

    **Implementation:**

    1. Use `useRef<SVGSVGElement>(null)` for the SVG element
    2. Use `useResizeObserver` or a simple `useEffect` with `getBoundingClientRect()` to get container width/height (the parent determines size via CSS)
    3. Call `useGraphSimulation({ entities, relationships, width, height, svgRef })` to get all D3 refs and controls
    4. Call `useGraphSelection({ nodeGroupRef, linkGroupRef, labelGroupRef, forceNodes, forceLinks, searchMatchIds })` to get selection state
    5. Wire up node click events: In a useEffect (after simulation creates nodes), attach click handlers to nodeGroupRef that call `selectEntity(d.id)`. ALSO call the parent's `onEntitySelect` callback so the page can open the entity timeline sidebar.
    6. Render:
       ```tsx
       <div className={clsx("relative w-full h-full", className)}>
         <svg ref={svgRef} className="w-full h-full" style={{ background: 'var(--color-charcoal)' }}>
           {/* SVG dot background pattern */}
           <defs>
             <pattern id="kg-dot-pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
               <circle cx="10" cy="10" r="1" fill="rgba(138,138,130,0.1)" />
             </pattern>
           </defs>
           <rect width="100%" height="100%" fill="url(#kg-dot-pattern)" />
           {/* D3 renders all nodes/edges into this SVG via refs */}
         </svg>

         {/* Bottom instruction bar */}
         <div className="absolute bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-full bg-jet/80 border border-stone/15 text-stone text-xs">
           Click nodes to explore relationships · Scroll to zoom · Drag to pan
         </div>

         {/* Zoom controls (reuse CanvasZoomControls or simple custom) */}
         <div className="absolute top-4 right-4 flex flex-col gap-1">
           {/* Zoom in/out/reset buttons */}
           {/* Simulation pause/resume toggle */}
         </div>
       </div>
       ```

    7. Add tooltip on node hover: Use a simple absolutely-positioned div that follows mouse position, shows entity name, entity type, degree count, and description_brief.

    8. Edge hover tooltip: Shows relationship label, temporal_context, evidence_excerpt (truncated), corroboration_count.

    9. Edge deduplication display: For edges with count > 1, render the edge label as `"{primary_label} +{count-1}"`. The primary label is the first (or strongest) relationship. On edge click or hover, show a small popover listing all relationships between that entity pair with their labels and types.

    **IMPORTANT:** The SVG background dot pattern should be defined in the JSX `<defs>`. All dynamic D3 content (nodes, edges, labels) is rendered by D3 via the refs — NOT via React JSX. The component only renders the static SVG shell; D3 populates it.

    **Selection propagation:** When user clicks a node, BOTH the internal selection hook AND the parent `onEntitySelect` callback are called. This allows the parent (KnowledgeGraphCanvas in Plan 05) to open the entity timeline sidebar.

    **Background click:** Clicking the SVG background (not a node) should deselect: call `onEntitySelect(null)`.
  </action>
  <verify>
    1. `cd frontend && bun run typecheck` — GraphSvg type-checks correctly
    2. The file does NOT import `useState` for node positions — verify:
       ```
       grep "setNodePositions\|nodePositions" frontend/src/components/knowledge-graph/GraphSvg.tsx
       ```
       Should return zero results.
    3. The file imports and uses both `useGraphSimulation` and `useGraphSelection`
    4. The GraphSvgProps interface includes `searchMatchIds?: Set<string>`
    5. The file has ABOUTME comment
    6. No `any` types
  </verify>
  <done>
    `GraphSvg.tsx` renders the D3 force-directed graph with dark background, dot pattern, zoom controls, instruction bar, node/edge tooltips, and edge deduplication display. All dynamic rendering is via D3 refs. Selection propagates to parent via callback. Search match IDs forwarded to selection hook for accent glow highlighting. Background click deselects.
  </done>
</task>

</tasks>

<verification>
- `useGraphSimulation` tick handler uses D3 selection refs ONLY (no React state updates per tick)
- `useGraphSelection` selection effect depends ONLY on selectedEntityId (does not restart simulation)
- `useGraphSelection` has a SEPARATE search highlight effect depending on searchMatchIds
- GraphSvg props include `searchMatchIds?: Set<string>` which is forwarded to useGraphSelection
- GraphSvg renders force-directed graph with 5 forces, sqrt-scaled nodes, radial centrality
- Edge deduplication collapses same-pair relationships into single edge with count
- Node click highlights connected subgraph, dims everything else
- Search match nodes get a distinct accent glow ring (different from selection white border)
- Background click deselects
- Drag, zoom, pan all work
- No `any` types in any file
- All files have ABOUTME comments
- Run `make generate-types` then `make format` before commit
</verification>

<success_criteria>
The core D3 graph visualization is complete: force simulation with 5 forces, sqrt-scaled node sizing, radial centrality layout, edge deduplication, selection highlighting, search match highlighting, drag/zoom/pan — all using D3 refs for performance (zero React re-renders during simulation). The GraphSvg component receives data, emits selection events to its parent, and accepts searchMatchIds for search-driven accent glow.
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-kg-frontend-d3-enhancement/07.2-03-SUMMARY.md`
</output>
