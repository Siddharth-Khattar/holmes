---
phase: 08-synthesis-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - backend/app/api/synthesis.py
  - backend/app/api/timeline.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "GET /api/cases/:caseId/synthesis returns synthesis summary + verdict"
    - "GET /api/cases/:caseId/hypotheses returns list of hypotheses with flat evidence"
    - "GET /api/cases/:caseId/contradictions returns list with severity filtering"
    - "GET /api/cases/:caseId/gaps returns list with priority filtering"
    - "GET /api/cases/:caseId/tasks returns investigation tasks"
    - "GET /api/cases/:caseId/timeline returns timeline events with domain/category filtering"
    - "All endpoints enforce auth + case ownership"
  artifacts:
    - path: "backend/app/api/synthesis.py"
      provides: "6 synthesis API endpoints"
      exports: ["router"]
    - path: "backend/app/api/timeline.py"
      provides: "2 timeline API endpoints"
      exports: ["router"]
  key_links:
    - from: "backend/app/api/synthesis.py"
      to: "backend/app/schemas/synthesis.py"
      via: "response_model references"
      pattern: "HypothesisResponse|ContradictionResponse|GapResponse|TaskResponse|SynthesisResponse"
    - from: "backend/app/main.py"
      to: "backend/app/api/synthesis.py"
      via: "router registration"
      pattern: "synthesis.router"
---

<objective>
Create backend API endpoints for all synthesis data types and timeline events.

Purpose: The frontend Verdict view and Timeline page need API endpoints to fetch synthesis-generated data. These endpoints follow the existing KG API pattern (auth + ownership check, query model, return Pydantic response).

Output: 8 new API endpoints registered in main.py, providing read access to all synthesis tables.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-synthesis-intelligence/08-CONTEXT.md
@.planning/phases/08-synthesis-intelligence/08-RESEARCH.md
@.planning/phases/08-synthesis-intelligence/08-01-SUMMARY.md
@backend/app/api/knowledge_graph.py
@backend/app/api/findings.py
@backend/app/schemas/synthesis.py
@backend/app/models/synthesis.py
@backend/app/models/investigation_task.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Synthesis API endpoints</name>
  <files>
    backend/app/api/synthesis.py
  </files>
  <action>
Create `backend/app/api/synthesis.py` with ABOUTME comment. Follow the `knowledge_graph.py` API pattern exactly for auth, ownership checks, and query structure.

Import dependencies:
- `from app.api.cases import get_user_case` (or the equivalent auth helper used in knowledge_graph.py -- check the actual function name)
- Models: CaseSynthesis, CaseHypothesis, CaseContradiction, CaseGap from app.models.synthesis, InvestigationTask from app.models.investigation_task
- Schemas: SynthesisResponse, HypothesisResponse, ContradictionResponse, GapResponse, TaskResponse from app.schemas.synthesis
- SQLAlchemy: select, AsyncSession, UUID
- FastAPI: APIRouter, Depends, HTTPException, Query

Create router: `router = APIRouter(prefix="/api/cases/{case_id}", tags=["synthesis"])`

**Endpoints:**

1. `GET /synthesis` -> `SynthesisResponse`
   - Query `CaseSynthesis` WHERE case_id, ORDER BY created_at DESC, LIMIT 1
   - Return 404 if not found (synthesis hasn't run yet)
   - Parse case_verdict JSONB into VerdictResponse in the schema

2. `GET /hypotheses` -> `list[HypothesisResponse]`
   - Query `CaseHypothesis` WHERE case_id, ORDER BY confidence DESC
   - Optional query param `status: str | None = None` to filter by PENDING/SUPPORTED/REFUTED
   - Return empty list if none found (not 404)

3. `GET /hypotheses/{hypothesis_id}` -> `HypothesisResponse`
   - Query by ID + case_id ownership check
   - Return 404 if not found

4. `GET /contradictions` -> `list[ContradictionResponse]`
   - Query `CaseContradiction` WHERE case_id, ORDER BY CASE severity WHEN 'critical' THEN 1 WHEN 'significant' THEN 2 ELSE 3 END
   - Optional query param `severity: str | None = None` to filter
   - Return empty list if none found

5. `GET /gaps` -> `list[GapResponse]`
   - Query `CaseGap` WHERE case_id, ORDER BY CASE priority WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END
   - Optional query param `priority: str | None = None` to filter
   - Return empty list if none found

6. `GET /tasks` -> `list[TaskResponse]`
   - Query `InvestigationTask` WHERE case_id, ORDER BY CASE priority WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END, created_at ASC
   - Optional query params: `task_type: str | None = None`, `status: str | None = None`
   - Return empty list if none found

Every endpoint must:
- Accept `case_id: UUID` path param
- Get current user via the same auth dependency used in knowledge_graph.py
- Verify case ownership (call the ownership helper)
- Use `Annotated[AsyncSession, Depends(get_db)]` for DB session
- Use `from_attributes=True` model validation on query results

For the severity/priority ordering, use SQLAlchemy `case()` expression:
```python
from sqlalchemy import case as sa_case
priority_order = sa_case(
    (Model.priority == "critical", 1),
    (Model.priority == "high", 2),
    (Model.priority == "medium", 3),
    else_=4,
)
```
  </action>
  <verify>
    Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "from app.api.synthesis import router; print(len(router.routes), 'routes')"` -- should print 6 routes.
  </verify>
  <done>6 synthesis endpoints exist: /synthesis, /hypotheses (list), /hypotheses/{id}, /contradictions, /gaps, /tasks. All enforce auth + ownership, support filtering, return proper Pydantic responses.</done>
</task>

<task type="auto">
  <name>Task 2: Timeline API endpoints + router registration</name>
  <files>
    backend/app/api/timeline.py
    backend/app/main.py
  </files>
  <action>
**1. Create `backend/app/api/timeline.py`** with ABOUTME comment.

Follow the same pattern as synthesis.py endpoints.

Router: `router = APIRouter(prefix="/api/cases/{case_id}", tags=["timeline"])`

**Endpoints:**

1. `GET /timeline` -> Returns a response matching the frontend's `TimelineApiResponse` shape:
   ```python
   {
     "events": list[TimelineEventResponse],
     "totalCount": int,
     "dateRange": {"earliest": str, "latest": str},
     "layerCounts": {"financial": N, "legal": N, "evidence": N, "strategy": N}
   }
   ```
   - Query `TimelineEvent` WHERE case_id, ORDER BY event_date ASC NULLS LAST
   - Optional query params: `layers: str | None = None` (comma-separated: "financial,legal"), `startDate: str | None = None`, `endDate: str | None = None`, `q: str | None = None` (search query matching title or description), `minConfidence: float | None = None`
   - For `layers` param: filter WHERE layer IN (parsed list)
   - For date range: filter WHERE event_date >= startDate AND event_date <= endDate
   - For search: filter WHERE title ILIKE %q% OR description ILIKE %q%
   - Compute dateRange from min/max event_date in results
   - Compute layerCounts by counting events per layer value
   - Create a `TimelineApiResponseModel(BaseModel)` in schemas/synthesis.py (or inline) with fields: events (list[TimelineEventResponse]), totalCount (int), dateRange (dict with earliest/latest strings), layerCounts (dict[str, int])
   - Note: The frontend expects `date` field (not `event_date`). The TimelineEventResponse schema should either rename event_date to date OR the frontend will be updated in Plan 05. For now, return event_date as `event_date` and also include an alias `date` in the response serialization. Actually -- look at the frontend TimelineEventSchema which expects `date: z.string().datetime()`. The simplest approach: add a computed `date` field to TimelineEventResponse that mirrors event_date as ISO string. This will be handled when the frontend types are updated in Plan 05.

2. `GET /timeline/{event_id}` -> `TimelineEventResponse`
   - Query by ID + case_id ownership check
   - Return 404 if not found

**2. Register both routers in `backend/app/main.py`**:

Add imports and include_router calls following the existing pattern (look for where knowledge_graph router is registered):
```python
from app.api.synthesis import router as synthesis_router
from app.api.timeline import router as timeline_router

app.include_router(synthesis_router)
app.include_router(timeline_router)
```

Make sure to place these near the existing router registrations (after knowledge_graph_router or findings_router).
  </action>
  <verify>
    Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/backend && source .venv/bin/activate && python -c "from app.api.timeline import router; print(len(router.routes), 'routes')"` -- should print 2 routes. Then `python -c "from app.main import app; routes = [r.path for r in app.routes if hasattr(r, 'path')]; print([r for r in routes if 'synthesis' in r or 'timeline' in r or 'hypotheses' in r])"` -- should show the new API paths.
  </verify>
  <done>2 timeline endpoints exist (/timeline list, /timeline/{id}). Both synthesis and timeline routers registered in main.py. Timeline list endpoint returns shape matching frontend TimelineApiResponse (events, totalCount, dateRange, layerCounts). All endpoints enforce auth + ownership.</done>
</task>

</tasks>

<verification>
- All 8 endpoints return proper JSON responses
- Auth + ownership checks on every endpoint (same pattern as knowledge_graph.py)
- Priority/severity ordering uses SQLAlchemy case() expression
- Timeline list returns dateRange and layerCounts aggregation
- Both routers registered in main.py
- `python -c "from app.main import app"` succeeds without import errors
</verification>

<success_criteria>
- GET /api/cases/{id}/synthesis returns CaseSynthesis with parsed verdict
- GET /api/cases/{id}/hypotheses returns flat evidence list per hypothesis
- GET /api/cases/{id}/contradictions supports severity filter
- GET /api/cases/{id}/gaps supports priority filter
- GET /api/cases/{id}/tasks supports task_type and status filters
- GET /api/cases/{id}/timeline returns events with dateRange + layerCounts aggregation
- All endpoints match the contracts expected by frontend Plans 04 and 05
</success_criteria>

<output>
After completion, create `.planning/phases/08-synthesis-intelligence/08-03-SUMMARY.md`
</output>
