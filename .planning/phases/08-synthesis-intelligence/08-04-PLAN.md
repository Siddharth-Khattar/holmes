---
phase: 08-synthesis-intelligence
plan: 04
type: execute
wave: 3
depends_on: ["08-02", "08-03"]
files_modified:
  - frontend/src/types/synthesis.ts
  - frontend/src/lib/api/synthesis.ts
  - frontend/src/hooks/useSynthesisData.ts
autonomous: true

must_haves:
  truths:
    - "Frontend TypeScript types match all backend synthesis API response shapes"
    - "API client functions authenticate and fetch from all 5 synthesis endpoints"
    - "React Query hooks cache synthesis data with 30s stale time"
  artifacts:
    - path: "frontend/src/types/synthesis.ts"
      provides: "TypeScript types matching API response schemas"
      exports: ["SynthesisResponse", "HypothesisResponse", "ContradictionResponse", "GapResponse", "TaskResponse", "KeyFindingResponse", "VerdictResponse", "SynthesisEvidenceItem"]
    - path: "frontend/src/lib/api/synthesis.ts"
      provides: "API client functions for synthesis endpoints"
      exports: ["fetchSynthesis", "fetchHypotheses", "fetchContradictions", "fetchGaps", "fetchTasks"]
    - path: "frontend/src/hooks/useSynthesisData.ts"
      provides: "React Query hooks for all synthesis endpoints"
      exports: ["useSynthesis", "useHypotheses", "useContradictions", "useGaps", "useTasks"]
  key_links:
    - from: "frontend/src/hooks/useSynthesisData.ts"
      to: "frontend/src/lib/api/synthesis.ts"
      via: "queryFn references in React Query hooks"
      pattern: "fetchSynthesis|fetchHypotheses"
    - from: "frontend/src/lib/api/synthesis.ts"
      to: "backend/app/api/synthesis.py"
      via: "HTTP GET requests to synthesis API endpoints"
      pattern: "/api/cases/"
---

<objective>
Create frontend TypeScript types, API client, and React Query hooks for all synthesis data endpoints.

Purpose: These are the foundational data layer files that the Verdict view components (Plan 05) and Command Center integration (Plan 06) depend on. Splitting these out ensures clean type contracts before building UI.

Output: TypeScript interfaces for all synthesis response types, 5 fetch functions with auth, 5 React Query hooks.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-synthesis-intelligence/08-CONTEXT.md
@.planning/phases/08-synthesis-intelligence/08-RESEARCH.md
@.planning/phases/08-synthesis-intelligence/08-01-SUMMARY.md
@.planning/phases/08-synthesis-intelligence/08-03-SUMMARY.md
@frontend/src/lib/api/graph.ts
@frontend/src/types/knowledge-graph.ts
@frontend/src/hooks/use-case-graph.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TypeScript types for synthesis API responses</name>
  <files>
    frontend/src/types/synthesis.ts
  </files>
  <action>
Create `frontend/src/types/synthesis.ts` with ABOUTME comment.

Define TypeScript interfaces matching the backend API response schemas:

```typescript
export interface SynthesisEvidenceItem {
  finding_id: string;
  role: "supporting" | "contradicting" | "neutral";
  excerpt: string;
}

export interface HypothesisResponse {
  id: string;
  case_id: string;
  workflow_id: string;
  claim: string;
  status: "PENDING" | "SUPPORTED" | "REFUTED";
  confidence: number; // 0-1
  evidence: SynthesisEvidenceItem[];
  source_agent: string | null;
  reasoning: string | null;
  created_at: string;
}

export interface ContradictionResponse {
  id: string;
  case_id: string;
  workflow_id: string;
  claim_a: string;
  claim_b: string;
  source_a: { finding_id: string; excerpt: string } | null;
  source_b: { finding_id: string; excerpt: string } | null;
  severity: "minor" | "significant" | "critical";
  domain: string | null;
  resolution_status: string;
  created_at: string;
}

export interface GapResponse {
  id: string;
  case_id: string;
  workflow_id: string;
  description: string;
  what_is_missing: string;
  why_needed: string | null;
  priority: "low" | "medium" | "high" | "critical";
  related_entity_ids: string[] | null;
  suggested_actions: string | null;
  created_at: string;
}

export interface TaskResponse {
  id: string;
  case_id: string;
  workflow_id: string;
  title: string;
  description: string;
  task_type: string;
  priority: "low" | "medium" | "high" | "critical";
  status: "pending" | "in_progress" | "completed" | "dismissed";
  source_hypothesis_id: string | null;
  source_contradiction_id: string | null;
  source_gap_id: string | null;
  created_at: string;
}

export interface KeyFindingResponse {
  title: string;
  description: string;
  importance_rank: number;
  source_finding_ids: string[];
}

export interface VerdictResponse {
  verdict: string;
  evidence_strength: "Conclusive" | "Substantial" | "Inconclusive";
  key_strengths: string[];
  key_weaknesses: string[];
}

export interface SynthesisResponse {
  id: string;
  case_id: string;
  workflow_id: string;
  case_summary: string | null;
  case_verdict: VerdictResponse | null;
  cross_modal_links: unknown[] | null;
  cross_domain_conclusions: unknown[] | null;
  key_findings_summary: string | null; // JSON string of KeyFindingResponse[]
  risk_assessment: string | null;
  timeline_event_count: number;
  created_at: string;
}
```
  </action>
  <verify>Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run typecheck` -- no type errors in the new file.</verify>
  <done>All 8 TypeScript interfaces defined matching backend Pydantic response schemas, no `any` types used</done>
</task>

<task type="auto">
  <name>Task 2: API client functions + React Query hooks</name>
  <files>
    frontend/src/lib/api/synthesis.ts
    frontend/src/hooks/useSynthesisData.ts
  </files>
  <action>
**1. Create `frontend/src/lib/api/synthesis.ts`** with ABOUTME comment.

Follow the pattern from `lib/api/graph.ts` -- use the same auth/fetch pattern:

```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL || "";

async function fetchWithAuth(url: string): Promise<Response> {
  const response = await fetch(url, {
    credentials: "include",
    headers: { "Content-Type": "application/json" },
  });
  if (!response.ok) {
    throw new Error(`API error: ${response.status} ${response.statusText}`);
  }
  return response;
}

export async function fetchSynthesis(caseId: string): Promise<SynthesisResponse | null> { ... }
export async function fetchHypotheses(caseId: string, status?: string): Promise<HypothesisResponse[]> { ... }
export async function fetchContradictions(caseId: string, severity?: string): Promise<ContradictionResponse[]> { ... }
export async function fetchGaps(caseId: string, priority?: string): Promise<GapResponse[]> { ... }
export async function fetchTasks(caseId: string, taskType?: string, status?: string): Promise<TaskResponse[]> { ... }
```

Each function: build URL with query params, call fetchWithAuth, parse JSON, return typed data. Handle 404 for fetchSynthesis by returning null (not throwing).

**2. Create `frontend/src/hooks/useSynthesisData.ts`** with ABOUTME comment.

Create React Query hooks following the `use-case-graph.ts` pattern:

```typescript
export function useSynthesis(caseId: string) {
  return useQuery({
    queryKey: ["synthesis", caseId],
    queryFn: () => fetchSynthesis(caseId),
    staleTime: 30_000,
    retry: 1,
  });
}

export function useHypotheses(caseId: string) {
  return useQuery({
    queryKey: ["hypotheses", caseId],
    queryFn: () => fetchHypotheses(caseId),
    staleTime: 30_000,
  });
}

export function useContradictions(caseId: string) {
  return useQuery({
    queryKey: ["contradictions", caseId],
    queryFn: () => fetchContradictions(caseId),
    staleTime: 30_000,
  });
}

export function useGaps(caseId: string) {
  return useQuery({
    queryKey: ["gaps", caseId],
    queryFn: () => fetchGaps(caseId),
    staleTime: 30_000,
  });
}

export function useTasks(caseId: string) {
  return useQuery({
    queryKey: ["tasks", caseId],
    queryFn: () => fetchTasks(caseId),
    staleTime: 30_000,
  });
}
```
  </action>
  <verify>Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run typecheck` -- no type errors in the new files.</verify>
  <done>5 fetch functions with auth + query param support, 5 React Query hooks with 30s stale time, fetchSynthesis returns null on 404</done>
</task>

</tasks>

<verification>
- `bun run typecheck` passes with no errors in new files
- Types match backend API response schemas (same field names and types)
- API client uses credentials: "include" for auth
- React Query hooks use consistent query keys
</verification>

<success_criteria>
- TypeScript types match all backend Pydantic API response schemas
- API client handles 404 gracefully for synthesis endpoint (returns null)
- React Query hooks provide loading/error/data states for all 5 endpoints
- No `any` types in TypeScript code
</success_criteria>

<output>
After completion, create `.planning/phases/08-synthesis-intelligence/08-04-SUMMARY.md`
</output>
