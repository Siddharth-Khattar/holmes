---
phase: 08.1-geospatial
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/geocoding_service.py
autonomous: true

must_haves:
  truths:
    - "Geocoding service can convert addresses to coordinates"
    - "Reverse geocoding can convert coordinates to addresses"
    - "Geocoding results are cached to reduce API calls"
  artifacts:
    - path: "backend/app/services/geocoding_service.py"
      provides: "Google Maps geocoding service with caching"
      exports: ["geocode_address", "reverse_geocode", "batch_geocode", "GeocodingService"]
  key_links:
    - from: "geocoding_service.py"
      to: "Google Maps Geocoding API"
      via: "HTTP requests via googlemaps library"
      pattern: "googlemaps\\.Client"
---

<objective>
Implement geocoding service that converts location names/addresses to coordinates using Google Maps API.

Purpose: Provide geocoding capability for Geospatial Agent to convert location references into mappable coordinates with caching to minimize API costs.
Output: GeocodingService class with forward/reverse geocoding and batch support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-geospatial/CONTEXT.md
@.planning/phases/08.1-geospatial/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install googlemaps library</name>
  <files>backend/pyproject.toml</files>
  <action>
Add googlemaps Python library to backend dependencies:
- Add to `pyproject.toml` under `[project.dependencies]`: `googlemaps = "^4.10.0"`
- Run `cd backend && poetry lock && poetry install` to install the dependency

The googlemaps library provides official Google Maps API client with built-in rate limiting and error handling.
  </action>
  <verify>
Run `cd backend && poetry show googlemaps` to confirm installation.
  </verify>
  <done>googlemaps library installed and available for import.</done>
</task>

<task type="auto">
  <name>Task 2: Implement GeocodingService with caching</name>
  <files>backend/app/services/geocoding_service.py</files>
  <action>
Create `backend/app/services/geocoding_service.py` with the following implementation:

**Class Structure:**
```python
class GeocodingService:
    """Google Maps geocoding service with in-memory caching."""

    def __init__(self, api_key: str):
        self.client = googlemaps.Client(key=api_key)
        self._cache: dict[str, dict[str, float] | None] = {}
        self._reverse_cache: dict[tuple[float, float], str | None] = {}

    async def geocode_address(address: str) -> dict[str, float] | None:
        """Forward geocode: address → {lat, lng} or None."""
        # Check cache first
        # Call self.client.geocode(address)
        # Extract lat/lng from first result
        # Cache result
        # Return {lat, lng} or None

    async def reverse_geocode(lat: float, lng: float) -> str | None:
        """Reverse geocode: {lat, lng} → address or None."""
        # Check reverse_cache first
        # Call self.client.reverse_geocode((lat, lng))
        # Extract formatted_address from first result
        # Cache result
        # Return address or None

    async def batch_geocode(addresses: list[str]) -> list[dict[str, float] | None]:
        """Batch geocode multiple addresses."""
        # Loop through addresses calling geocode_address
        # Caching in geocode_address makes this efficient
        # Return list of results
```

**Key Implementation Details:**
- Use `googlemaps.Client` (synchronous library) but expose async methods using `asyncio.to_thread` for non-blocking calls
- In-memory dict caching (simple for v1; can upgrade to Redis in Phase 9 if needed)
- Normalize addresses before caching (lowercase, strip whitespace) to maximize cache hits
- Handle API errors gracefully: return None instead of raising exceptions
- Log warnings for failed geocoding attempts
- API key from environment variable `GOOGLE_MAPS_API_KEY`

**Error Handling:**
- Catch `googlemaps.exceptions.ApiError` and return None
- Catch `googlemaps.exceptions.HTTPError` and return None
- Catch `googlemaps.exceptions.Timeout` and return None
- Log all failures at WARNING level with address/coordinates included

**Example Usage:**
```python
service = GeocodingService(api_key=os.getenv("GOOGLE_MAPS_API_KEY"))
coords = await service.geocode_address("123 Main St, Springfield, IL")
# Returns: {"lat": 39.7817, "lng": -89.6501}
```

**Why googlemaps library:**
- Official Google Maps client
- Built-in rate limiting
- Handles API key authentication
- Retry logic included
- Used in production by thousands of projects

**Cache invalidation:** Not needed for v1 (geocoding results don't change). Can add TTL in future if needed.
  </action>
  <verify>
Run `cd backend && python -c "import asyncio; from app.services.geocoding_service import GeocodingService; print('Import successful')"` to verify module loads without errors.
  </verify>
  <done>GeocodingService class exists with geocode_address, reverse_geocode, batch_geocode methods and in-memory caching.</done>
</task>

</tasks>

<verification>
**Module Check:**
```bash
cd backend
python -c "from app.services.geocoding_service import GeocodingService; print('✓ GeocodingService import successful')"
```

**Dependency Check:**
```bash
cd backend
poetry show googlemaps | grep "version"
```

**Type Check:**
```bash
cd backend
poetry run pyright app/services/geocoding_service.py
```

All checks must pass with zero errors.
</verification>

<success_criteria>
- googlemaps library installed in backend environment
- GeocodingService class exists with forward/reverse/batch geocoding methods
- In-memory caching implemented for both forward and reverse geocoding
- Error handling returns None instead of raising exceptions
- Module imports without errors
- Type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-geospatial/08.1-01-SUMMARY.md` with:
- geocoding_service.py creation details
- Caching strategy explanation
- API error handling approach
- Example usage patterns
</output>
