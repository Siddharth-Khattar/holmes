---
phase: 08.1-geospatial
plan: 03
type: execute
wave: 3
depends_on: ["08.1-02"]
files_modified:
  - backend/app/api/locations.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "User can trigger geospatial analysis via POST endpoint"
    - "User can check geospatial status via GET endpoint"
    - "User can fetch all locations via GET endpoint"
    - "User can fetch single location detail via GET endpoint"
    - "User can fetch movement paths via GET endpoint"
    - "User can delete geospatial data via DELETE endpoint"
  artifacts:
    - path: "backend/app/api/locations.py"
      provides: "Locations REST API with 6 endpoints"
      exports: ["router"]
      min_lines: 300
  key_links:
    - from: "locations.py POST /geospatial/generate"
      to: "run_geospatial function"
      via: "Async task spawn"
      pattern: "asyncio\\.create_task\\(run_geospatial"
    - from: "locations.py GET endpoints"
      to: "Location model"
      via: "SQLAlchemy queries with auth filtering"
      pattern: "select\\(Location\\).*where.*case_id"
    - from: "main.py"
      to: "locations router"
      via: "FastAPI include_router"
      pattern: "app\\.include_router\\(locations\\.router"
---

<objective>
Create REST API endpoints for geospatial data generation, status checking, and retrieval.

Purpose: Enable frontend to trigger on-demand geospatial analysis and fetch results for map visualization.
Output: 6 REST endpoints registered in main.py with full auth and case ownership enforcement.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-geospatial/CONTEXT.md
@.planning/phases/08.1-geospatial/REQUIREMENTS.md

# Pattern reference (synthesis API)
@backend/app/api/synthesis.py
@backend/app/api/timeline.py
@backend/app/api/knowledge_graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create locations API endpoints</name>
  <files>backend/app/api/locations.py</files>
  <action>
Create `backend/app/api/locations.py` with 6 endpoints following synthesis.py and knowledge_graph.py patterns:

```python
"""Locations API endpoints for geospatial intelligence."""

from __future__ import annotations

import asyncio
import logging
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import delete, func, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.api.deps import get_current_user, get_db
from app.models.case import Case
from app.models.synthesis import Location
from app.models.user import User
from app.services.agent_events import (
    emit_agent_started,
    emit_geospatial_complete,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/cases/{case_id}", tags=["geospatial"])


def sa_case(user: User, case_id: UUID) -> select:
    """Build SQLAlchemy select for case with ownership check."""
    return select(Case).where(Case.id == case_id, Case.user_id == user.id)


@router.post("/geospatial/generate", status_code=202)
async def generate_geospatial_intelligence(
    case_id: UUID,
    force: bool = Query(default=False, description="Force regeneration even if exists"),
    db: AsyncSession = Depends(get_db),
    user: User = Depends(get_current_user),
):
    """Trigger on-demand geospatial analysis.

    Spawns Geospatial Agent async task. Returns immediately with 202 Accepted.
    Frontend should subscribe to SSE for progress updates.
    """
    # Verify case ownership
    case_stmt = sa_case(user, case_id)
    case = (await db.execute(case_stmt)).scalar_one_or_none()
    if not case:
        raise HTTPException(status_code=404, detail="Case not found")

    # Check if analysis already exists (unless force=True)
    if not force:
        existing_stmt = select(func.count(Location.id)).where(
            Location.case_id == case_id
        )
        existing_count = (await db.execute(existing_stmt)).scalar()
        if existing_count and existing_count > 0:
            return {
                "status": "exists",
                "message": "Geospatial analysis already exists. Use force=true to regenerate.",
                "location_count": existing_count,
            }

    # Spawn async task (non-blocking)
    from app.agents.geospatial import run_geospatial

    workflow_id = UUID("00000000-0000-0000-0000-000000000000")  # TODO: get from request or generate

    async def run_task():
        async with db.begin_nested():
            await emit_agent_started(case_id, "geospatial", str(case_id))
            try:
                await run_geospatial(str(case_id), workflow_id, db)
                # Count results
                count_stmt = select(func.count(Location.id)).where(
                    Location.case_id == case_id
                )
                location_count = (await db.execute(count_stmt)).scalar() or 0
                await emit_geospatial_complete(case_id, location_count, path_count=0)
            except Exception as e:
                logger.error(f"Geospatial generation failed: {e}", exc_info=True)
                raise

    asyncio.create_task(run_task())

    return {"status": "generating", "case_id": str(case_id)}


@router.get("/geospatial/status")
async def get_geospatial_status(
    case_id: UUID,
    db: AsyncSession = Depends(get_db),
    user: User = Depends(get_current_user),
):
    """Check if geospatial analysis exists and its status."""
    # Verify case ownership
    case_stmt = sa_case(user, case_id)
    case = (await db.execute(case_stmt)).scalar_one_or_none()
    if not case:
        raise HTTPException(status_code=404, detail="Case not found")

    # Check if locations exist
    count_stmt = select(func.count(Location.id)).where(Location.case_id == case_id)
    location_count = (await db.execute(count_stmt)).scalar() or 0

    if location_count == 0:
        return {
            "exists": False,
            "status": "not_started",
            "location_count": 0,
        }

    # Get latest location timestamp
    latest_stmt = (
        select(Location.created_at)
        .where(Location.case_id == case_id)
        .order_by(Location.created_at.desc())
        .limit(1)
    )
    latest_created = (await db.execute(latest_stmt)).scalar_one_or_none()

    return {
        "exists": True,
        "status": "complete",
        "location_count": location_count,
        "last_generated": latest_created.isoformat() if latest_created else None,
    }


@router.get("/locations")
async def get_locations(
    case_id: UUID,
    location_type: str | None = Query(
        default=None,
        description="Filter by type: crime_scene, witness_location, evidence_location, suspect_location, other",
    ),
    db: AsyncSession = Depends(get_db),
    user: User = Depends(get_current_user),
):
    """Get all locations for map visualization."""
    # Verify case ownership
    case_stmt = sa_case(user, case_id)
    case = (await db.execute(case_stmt)).scalar_one_or_none()
    if not case:
        raise HTTPException(status_code=404, detail="Case not found")

    # Build query
    stmt = select(Location).where(Location.case_id == case_id)
    if location_type:
        stmt = stmt.where(Location.location_type == location_type)
    stmt = stmt.order_by(Location.name)

    locations = (await db.execute(stmt)).scalars().all()

    return {
        "locations": [
            {
                "id": str(loc.id),
                "name": loc.name,
                "coordinates": (
                    {"lat": loc.latitude, "lng": loc.longitude}
                    if loc.latitude and loc.longitude
                    else None
                ),
                "location_type": loc.location_type,
                "event_count": len(loc.events.get("events", [])) if loc.events else 0,
                "citation_count": (
                    len(loc.citations.get("citations", [])) if loc.citations else 0
                ),
            }
            for loc in locations
        ]
    }


@router.get("/locations/{location_id}")
async def get_location_detail(
    case_id: UUID,
    location_id: UUID,
    db: AsyncSession = Depends(get_db),
    user: User = Depends(get_current_user),
):
    """Get detailed location data with events and citations."""
    # Verify case ownership
    case_stmt = sa_case(user, case_id)
    case = (await db.execute(case_stmt)).scalar_one_or_none()
    if not case:
        raise HTTPException(status_code=404, detail="Case not found")

    # Get location
    stmt = select(Location).where(
        Location.case_id == case_id, Location.id == location_id
    )
    location = (await db.execute(stmt)).scalar_one_or_none()
    if not location:
        raise HTTPException(status_code=404, detail="Location not found")

    return {
        "id": str(location.id),
        "name": location.name,
        "coordinates": (
            {"lat": location.latitude, "lng": location.longitude}
            if location.latitude and location.longitude
            else None
        ),
        "location_type": location.location_type,
        "events": location.events.get("events", []) if location.events else [],
        "citations": (
            location.citations.get("citations", []) if location.citations else []
        ),
        "temporal_associations": {
            "start": (
                location.temporal_start.isoformat() if location.temporal_start else None
            ),
            "end": location.temporal_end.isoformat() if location.temporal_end else None,
        },
        "source_entity_ids": (
            location.source_entity_ids.get("entity_ids", [])
            if location.source_entity_ids
            else []
        ),
    }


@router.get("/paths")
async def get_paths(
    case_id: UUID,
    db: AsyncSession = Depends(get_db),
    user: User = Depends(get_current_user),
):
    """Get movement paths for visualization.

    Note: For Phase 8.1, paths are stored in location JSONB.
    Phase 8.2 may add dedicated paths table.
    """
    # Verify case ownership
    case_stmt = sa_case(user, case_id)
    case = (await db.execute(case_stmt)).scalar_one_or_none()
    if not case:
        raise HTTPException(status_code=404, detail="Case not found")

    # For v1, return empty array (paths stored in location JSONB, not exposed yet)
    # Phase 8.2 can add proper path extraction
    return {"paths": []}


@router.delete("/geospatial")
async def delete_geospatial_data(
    case_id: UUID,
    db: AsyncSession = Depends(get_db),
    user: User = Depends(get_current_user),
):
    """Clear geospatial data for regeneration."""
    # Verify case ownership
    case_stmt = sa_case(user, case_id)
    case = (await db.execute(case_stmt)).scalar_one_or_none()
    if not case:
        raise HTTPException(status_code=404, detail="Case not found")

    # Count before delete
    count_stmt = select(func.count(Location.id)).where(Location.case_id == case_id)
    location_count = (await db.execute(count_stmt)).scalar() or 0

    # Delete all locations for this case
    delete_stmt = delete(Location).where(Location.case_id == case_id)
    await db.execute(delete_stmt)
    await db.commit()

    return {"deleted": True, "location_count": location_count}
```

**Key Implementation Details:**
- Follows synthesis.py and knowledge_graph.py patterns (sa_case helper, auth enforcement)
- POST /generate spawns async task via asyncio.create_task (non-blocking)
- GET /status checks if locations exist and returns count + timestamp
- GET /locations returns list with minimal data for map markers
- GET /locations/{id} returns full detail with events, citations, temporal data
- GET /paths returns empty array for v1 (paths in JSONB, not exposed yet)
- DELETE /geospatial clears all locations for regeneration
- All endpoints enforce case ownership via sa_case helper
  </action>
  <verify>
Run `cd backend && poetry run python -c "from app.api.locations import router; print('✓ Locations router import successful')"` to verify module loads.

Run `cd backend && poetry run pyright app/api/locations.py` to verify type safety.
  </verify>
  <done>Locations API router exists with 6 endpoints, all enforcing auth and case ownership.</done>
</task>

<task type="auto">
  <name>Task 2: Register locations router in main.py</name>
  <files>backend/app/main.py</files>
  <action>
Register locations router in `backend/app/main.py`:

Add import:
```python
from app.api import locations
```

Add router registration (after synthesis router):
```python
app.include_router(locations.router)
```

**Placement:** After synthesis router, before health endpoint.

**Why this placement:** Groups all case-related routers together (cases, files, agents, confirmations, knowledge_graph, synthesis, timeline, locations).
  </action>
  <verify>
Run `cd backend && poetry run python -c "from app.main import app; print('✓ Main app loads with locations router')"` to verify app starts.

Check router registration:
```bash
cd backend
poetry run python -c "
from app.main import app
routes = [r.path for r in app.routes if 'geospatial' in r.path or 'locations' in r.path]
print('Geospatial routes:', routes)
assert len(routes) >= 6, f'Expected 6+ routes, got {len(routes)}'
print('✓ All geospatial routes registered')
"
```
  </verify>
  <done>Locations router registered in main.py, all 6 endpoints accessible via FastAPI.</done>
</task>

</tasks>

<verification>
**Type Check:**
```bash
cd backend
poetry run pyright app/api/locations.py
```

**Import Check:**
```bash
cd backend
poetry run python -c "from app.api.locations import router; print('✓ Router import successful')"
```

**Route Registration Check:**
```bash
cd backend
poetry run python -c "
from app.main import app
routes = [r.path for r in app.routes if 'geospatial' in r.path or 'locations' in r.path]
print('Registered routes:', routes)
assert len(routes) >= 6
print('✓ All routes registered')
"
```

All checks must pass.
</verification>

<success_criteria>
- locations.py exists with 6 endpoints (POST generate, GET status, GET list, GET detail, GET paths, DELETE)
- All endpoints enforce auth via get_current_user dependency
- All endpoints enforce case ownership via sa_case helper
- POST /generate spawns async task and returns 202 Accepted
- GET endpoints return proper JSON responses
- DELETE endpoint clears all locations for case
- Router registered in main.py
- Type checks pass
- Module imports without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-geospatial/08.1-03-SUMMARY.md` with:
- 6 API endpoints implementation details
- Auth and case ownership enforcement pattern
- Async task spawning approach
- Response schema examples
- Router registration confirmation
</output>
