---
phase: 08.1-geospatial
plan: 04
type: execute
wave: 4
depends_on: ["08.1-03"]
files_modified:
  - frontend/src/hooks/useGeospatialData.ts
  - frontend/src/types/geospatial.types.ts
  - frontend/src/lib/api/geospatial.ts
  - frontend/src/app/(app)/cases/[id]/geospatial/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can trigger geospatial analysis via Generate button"
    - "Status banner shows generation progress in real-time"
    - "Map displays real location data after generation"
    - "User can refresh analysis to regenerate"
  artifacts:
    - path: "frontend/src/hooks/useGeospatialData.ts"
      provides: "React hook for fetching geospatial data and status"
      exports: ["useGeospatialData"]
      min_lines: 80
    - path: "frontend/src/lib/api/geospatial.ts"
      provides: "API client for geospatial endpoints"
      exports: ["fetchGeospatialStatus", "generateGeospatialIntelligence", "fetchLocations", "fetchLocationDetail", "deleteGeospatialData"]
      min_lines: 60
    - path: "frontend/src/app/(app)/cases/[id]/geospatial/page.tsx"
      provides: "Geospatial page with trigger UI and real data integration"
      contains: "useGeospatialData"
  key_links:
    - from: "page.tsx Generate button"
      to: "generateGeospatialIntelligence API call"
      via: "onClick handler"
      pattern: "onClick.*generateGeospatialIntelligence"
    - from: "useGeospatialData hook"
      to: "fetchGeospatialStatus and fetchLocations APIs"
      via: "useEffect with interval polling"
      pattern: "useEffect.*fetchGeospatialStatus|fetchLocations"
    - from: "GeospatialMap component"
      to: "real location data from hook"
      via: "landmarks prop"
      pattern: "landmarks=\\{locations\\}"
---

<objective>
Replace mock geospatial data with real API integration, add trigger UI for on-demand generation, and implement status tracking.

Purpose: Enable users to generate geospatial intelligence on demand and visualize real location data on the map.
Output: Working trigger UI with real-time status updates and map displaying API data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-geospatial/CONTEXT.md
@.planning/phases/08.1-geospatial/REQUIREMENTS.md

# Frontend pattern reference
@frontend/src/hooks/useSynthesisData.ts
@frontend/src/lib/api/synthesis.ts
@frontend/src/app/(app)/cases/[id]/command-center/page.tsx

# Existing geospatial code
@frontend/src/components/Geospatial/GeospatialMap.tsx
@frontend/src/types/geospatial.types.ts
@frontend/src/lib/mock-geospatial-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create geospatial API client and hook</name>
  <files>
    frontend/src/lib/api/geospatial.ts
    frontend/src/hooks/useGeospatialData.ts
  </files>
  <action>
**File 1: frontend/src/lib/api/geospatial.ts**

Create API client for geospatial endpoints following synthesis.ts pattern:

```typescript
import { apiClient } from "./api-client";

export interface GeospatialStatus {
  exists: boolean;
  status: "not_started" | "generating" | "complete";
  location_count: number;
  last_generated?: string;
}

export interface LocationResponse {
  id: string;
  name: string;
  coordinates: { lat: number; lng: number } | null;
  location_type: string;
  event_count: number;
  citation_count: number;
}

export interface LocationDetailResponse extends LocationResponse {
  events: Array<{
    event_title: string;
    event_description: string;
    timestamp: string;
    layer: string;
    confidence: number;
  }>;
  citations: Array<{
    file_id: string;
    file_name?: string;
    locator: string;
    excerpt: string;
  }>;
  temporal_associations: {
    start: string | null;
    end: string | null;
  };
  source_entity_ids: string[];
}

export async function fetchGeospatialStatus(
  caseId: string
): Promise<GeospatialStatus> {
  return apiClient.get<GeospatialStatus>(
    `/api/cases/${caseId}/geospatial/status`
  );
}

export async function generateGeospatialIntelligence(
  caseId: string,
  force = false
): Promise<{ status: string; case_id: string }> {
  return apiClient.post(
    `/api/cases/${caseId}/geospatial/generate?force=${force}`,
    {}
  );
}

export async function fetchLocations(
  caseId: string,
  locationTypeFilter?: string
): Promise<LocationResponse[]> {
  const params = locationTypeFilter
    ? `?location_type=${locationTypeFilter}`
    : "";
  const response = await apiClient.get<{ locations: LocationResponse[] }>(
    `/api/cases/${caseId}/locations${params}`
  );
  return response.locations;
}

export async function fetchLocationDetail(
  caseId: string,
  locationId: string
): Promise<LocationDetailResponse> {
  return apiClient.get<LocationDetailResponse>(
    `/api/cases/${caseId}/locations/${locationId}`
  );
}

export async function deleteGeospatialData(
  caseId: string
): Promise<{ deleted: boolean; location_count: number }> {
  return apiClient.delete(`/api/cases/${caseId}/geospatial`);
}
```

**File 2: frontend/src/hooks/useGeospatialData.ts**

Create React hook for geospatial data management:

```typescript
"use client";

import { useState, useEffect, useCallback } from "react";
import {
  fetchGeospatialStatus,
  fetchLocations,
  generateGeospatialIntelligence,
  deleteGeospatialData,
  type GeospatialStatus,
  type LocationResponse,
} from "@/lib/api/geospatial";
import type { Landmark } from "@/types/geospatial.types";

export function useGeospatialData(caseId: string) {
  const [status, setStatus] = useState<GeospatialStatus | null>(null);
  const [locations, setLocations] = useState<Landmark[]>([]);
  const [loading, setLoading] = useState(true);
  const [generating, setGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Transform API location to frontend Landmark type
  const transformLocation = (loc: LocationResponse): Landmark => ({
    id: loc.id,
    name: loc.name,
    location: loc.coordinates
      ? { lat: loc.coordinates.lat, lng: loc.coordinates.lng }
      : { lat: 0, lng: 0 }, // Fallback for unmappable locations
    type: loc.location_type as
      | "crime_scene"
      | "witness_location"
      | "evidence_location"
      | "suspect_location"
      | "other",
    events: [], // Will be populated from detail endpoint if needed
  });

  // Fetch status and locations
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // Check status first
      const statusData = await fetchGeospatialStatus(caseId);
      setStatus(statusData);

      // If complete, fetch locations
      if (statusData.exists && statusData.status === "complete") {
        const locationsData = await fetchLocations(caseId);
        const transformedLocations = locationsData.map(transformLocation);
        setLocations(transformedLocations);
      } else {
        setLocations([]);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to fetch data");
      console.error("Geospatial data fetch error:", err);
    } finally {
      setLoading(false);
    }
  }, [caseId]);

  // Generate intelligence
  const generate = useCallback(
    async (force = false) => {
      try {
        setGenerating(true);
        setError(null);
        await generateGeospatialIntelligence(caseId, force);
        setStatus({ exists: true, status: "generating", location_count: 0 });
        // Poll for completion
        const pollInterval = setInterval(async () => {
          const statusData = await fetchGeospatialStatus(caseId);
          setStatus(statusData);
          if (statusData.status === "complete") {
            clearInterval(pollInterval);
            setGenerating(false);
            await fetchData();
          }
        }, 3000); // Poll every 3 seconds
      } catch (err) {
        setError(
          err instanceof Error ? err.message : "Failed to generate intelligence"
        );
        setGenerating(false);
        console.error("Geospatial generation error:", err);
      }
    },
    [caseId, fetchData]
  );

  // Refresh (delete + regenerate)
  const refresh = useCallback(async () => {
    try {
      setError(null);
      await deleteGeospatialData(caseId);
      await generate(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to refresh");
      console.error("Geospatial refresh error:", err);
    }
  }, [caseId, generate]);

  // Initial fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    status,
    locations,
    loading,
    generating,
    error,
    generate,
    refresh,
    refetch: fetchData,
  };
}
```

**Key Implementation Details:**
- Follows useSynthesisData.ts pattern (apiClient usage, error handling, loading states)
- Transform API response (LocationResponse → Landmark) to match existing frontend types
- Polling mechanism for generation progress (every 3 seconds until status is "complete")
- refresh function: DELETE old data then POST new generation
- generate function: triggers analysis and starts polling
  </action>
  <verify>
Run `cd frontend && bun run typecheck` to verify TypeScript compilation.

Check imports:
```bash
cd frontend
bun run build 2>&1 | grep -i "geospatial" || echo "✓ No geospatial build errors"
```
  </verify>
  <done>geospatial.ts API client exists with 5 functions. useGeospatialData hook exists with status tracking, generation triggering, and polling.</done>
</task>

<task type="auto">
  <name>Task 2: Update geospatial page with trigger UI and real data</name>
  <files>
    frontend/src/app/(app)/cases/[id]/geospatial/page.tsx
    frontend/src/types/geospatial.types.ts
  </files>
  <action>
**File 1: frontend/src/app/(app)/cases/[id]/geospatial/page.tsx**

Update page to replace mock data with real API integration and add trigger UI:

```typescript
"use client";

import { useState } from "react";
import { useParams } from "next/navigation";
import { GeospatialMap } from "@/components/Geospatial/GeospatialMap";
import { useGeospatialData } from "@/hooks/useGeospatialData";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2, MapPin, RefreshCw } from "lucide-react";

export default function GeospatialPage() {
  const params = useParams();
  const caseId = params.id as string;
  const { status, locations, loading, generating, error, generate, refresh } =
    useGeospatialData(caseId);

  const [showConfirmRefresh, setShowConfirmRefresh] = useState(false);

  const handleRefresh = () => {
    if (showConfirmRefresh) {
      refresh();
      setShowConfirmRefresh(false);
    } else {
      setShowConfirmRefresh(true);
    }
  };

  return (
    <div className="flex h-full flex-col">
      {/* Status Banner */}
      <div className="border-b border-neutral-800 bg-neutral-950 p-4">
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {!status?.exists && (
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <MapPin className="h-5 w-5 text-neutral-400" />
              <div>
                <p className="text-sm font-medium text-neutral-200">
                  Geospatial intelligence not yet generated
                </p>
                <p className="text-xs text-neutral-400">
                  Extract and visualize location-based evidence from case data
                </p>
              </div>
            </div>
            <Button onClick={() => generate()} disabled={loading || generating}>
              {generating && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Generate Geospatial Intelligence
            </Button>
          </div>
        )}

        {status?.status === "generating" && (
          <div className="flex items-center gap-3">
            <Loader2 className="h-5 w-5 animate-spin text-primary-500" />
            <div>
              <p className="text-sm font-medium text-neutral-200">
                Analyzing locations and movement patterns...
              </p>
              <p className="text-xs text-neutral-400">
                This may take 1-2 minutes. You can leave this page.
              </p>
            </div>
          </div>
        )}

        {status?.status === "complete" && (
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <MapPin className="h-5 w-5 text-green-500" />
              <div>
                <p className="text-sm font-medium text-neutral-200">
                  Geospatial analysis complete
                </p>
                <p className="text-xs text-neutral-400">
                  {status.location_count} locations found
                  {status.last_generated &&
                    ` • Last updated: ${new Date(
                      status.last_generated
                    ).toLocaleString()}`}
                </p>
              </div>
            </div>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={generating}
            >
              {generating ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <RefreshCw className="mr-2 h-4 w-4" />
              )}
              {showConfirmRefresh ? "Confirm Refresh?" : "Refresh"}
            </Button>
          </div>
        )}
      </div>

      {/* Map */}
      <div className="flex-1">
        {status?.status === "complete" && locations.length > 0 ? (
          <GeospatialMap
            landmarks={locations}
            paths={[]} // Phase 8.1 v1: paths not exposed yet
            onViewSource={(fileId, locator) => {
              console.log("View source:", fileId, locator);
              // Phase 10: open Source Panel
            }}
          />
        ) : (
          <div className="flex h-full items-center justify-center">
            <div className="text-center">
              <MapPin className="mx-auto h-12 w-12 text-neutral-600" />
              <p className="mt-4 text-sm text-neutral-400">
                {status?.status === "generating"
                  ? "Generating geospatial intelligence..."
                  : "No geospatial data available"}
              </p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
```

**File 2: frontend/src/types/geospatial.types.ts**

Add any missing types if needed (existing types should already cover Landmark, LandmarkEvent, GeospatialPath, MapView). No changes needed if types already exist.

**Key Implementation Details:**
- Status banner shows 3 states: not_started, generating, complete
- Generate button triggers on-demand analysis
- Refresh button: first click shows "Confirm Refresh?", second click executes (prevents accidental regeneration)
- Empty state when no data available
- Loading state during generation
- Error handling with Alert component
- Remove all mockGeospatialData imports and usage
  </action>
  <verify>
Run `cd frontend && bun run typecheck` to verify TypeScript compilation.

Run `cd frontend && bun run build` to ensure page builds without errors.
  </verify>
  <done>Geospatial page updated with trigger UI (status banner, generate button, refresh button). Mock data removed. Real API data integrated via useGeospatialData hook.</done>
</task>

</tasks>

<verification>
**Type Check:**
```bash
cd frontend
bun run typecheck
```

**Build Check:**
```bash
cd frontend
bun run build
```

**Mock Data Removal Check:**
```bash
cd frontend
grep -r "mockGeospatialData" src/app/\(app\)/cases/\[id\]/geospatial/ || echo "✓ Mock data removed"
```

All checks must pass.
</verification>

<success_criteria>
- geospatial.ts API client exists with 5 functions
- useGeospatialData hook exists with status, locations, generate, refresh functions
- Geospatial page updated with status banner showing 3 states
- Generate button triggers analysis and shows loading state
- Refresh button with confirmation prevents accidental regeneration
- Mock data completely removed from geospatial page
- Real API data flows to GeospatialMap component
- TypeScript compiles without errors
- Page builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-geospatial/08.1-04-SUMMARY.md` with:
- API client implementation details
- useGeospatialData hook functionality
- Status banner state machine (not_started → generating → complete)
- Trigger UI implementation
- Mock data removal confirmation
</output>
