# Phase 8.1: Geospatial Agent & Map View - Research

**Researched:** 2026-02-09
**Domain:** On-demand geospatial intelligence extraction, geocoding, interactive mapping
**Confidence:** HIGH

## Summary

Phase 8.1 implements on-demand geospatial intelligence as a post-synthesis utility agent. The Geospatial Agent follows the established DomainAgentRunner pattern (like Synthesis and KG Builder), receiving location references from synthesis outputs/findings, geocoding them via Google Maps API, detecting movement patterns, and storing results in the `locations` table. The frontend adds a Map View tab with @vis.gl/react-google-maps for interactive visualization, showing color-coded markers, movement paths, and location-specific intelligence panels with citations.

The architecture follows proven patterns from Phase 8: text-only input assembled from DB (synthesis outputs + findings + KG entities), LLM-based agent with geocoding tools for disambiguation and enrichment, structured output written to existing `locations` table. The map uses Google's official React library (already installed: @vis.gl/react-google-maps 1.7.1) with smart offset for nearby markers instead of clustering. Key technical challenges are geocoding ambiguity resolution, coordinate system correctness (WGS84), and rate limit management.

**Primary recommendation:** Clone the Synthesis Agent pattern (DomainAgentRunner subclass + AgentFactory + text-only input assembly + structured output write). Use @vis.gl/react-google-maps with Google Maps Geocoding API. Implement LLM-based location extraction with context-aware disambiguation (not NER library). Apply smart offset for nearby markers, solid/dashed polylines for movement patterns, and timeline-centric detail panels matching existing sidebar patterns.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @vis.gl/react-google-maps | 1.7.1 | Interactive React map component | Official Google Maps React integration, already installed, superior to react-google-maps |
| Google Maps Geocoding API | Current | Address to coordinates conversion | Industry standard, 30-day cache allowed, rate limit 3,000/min |
| Google Maps JavaScript API | v3 | Map display and controls | Required by @vis.gl/react-google-maps |
| google.adk.agents | Current | LLM agent framework with tools | All Holmes agents use LlmAgent pattern |
| PostGIS | Current (via PG) | Geospatial queries on PostgreSQL | ST_Distance, ST_DWithin for proximity queries, GiST indexing |
| Pydantic | v2 | Location output schema | GeospatialOutput structured schema |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @googlemaps/markerclusterer | Latest | Marker clustering (if needed) | Only if >100 locations per case (unlikely) |
| react-full-screen | Latest | Fullscreen map API | For fullscreen toggle in map toolbar |
| Google Earth Engine API | Python | Satellite imagery retrieval | Future phase (REQ-GEO-005), not Phase 8.1 |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| @vis.gl/react-google-maps | Mapbox GL JS + react-map-gl | More styling flexibility but different pricing model, requires Mapbox account |
| @vis.gl/react-google-maps | Leaflet + react-leaflet | Free/open-source but lacks Google's geocoding accuracy and POI data |
| LLM location extraction | spaCy NER | Faster but misses context-dependent disambiguation (e.g., "Springfield" → which state?) |
| Smart offset markers | Marker clustering | Clustering loses individual location visibility, contradicts CONTEXT.md decision |

**Installation:**
```bash
# Backend (Python)
# No new packages needed - google.adk, pydantic, asyncpg already installed

# Frontend (already installed in package.json)
# @vis.gl/react-google-maps: 1.7.1
```

## Architecture Patterns

### Recommended Project Structure
```
backend/app/
├── agents/
│   ├── geospatial.py           # GeospatialAgentRunner + assemble_geospatial_input + write_geospatial_output
│   └── prompts/
│       └── geospatial.py       # GEOSPATIAL_SYSTEM_PROMPT
├── schemas/
│   └── geospatial.py           # GeospatialOutput Pydantic schema
├── models/
│   └── synthesis.py            # Location model already exists (lines 170-196)
├── api/
│   └── geospatial.py           # GET /cases/{id}/locations, GET /locations/{id}
└── services/
    └── geocoding.py            # Geocoding API wrapper with caching

frontend/src/
├── app/(app)/cases/[id]/geospatial/
│   └── page.tsx                # Map View page with toolbar + map + detail sidebar
├── components/
│   ├── geospatial/
│   │   ├── MapView.tsx         # @vis.gl/react-google-maps wrapper
│   │   ├── LocationMarker.tsx  # Custom marker with color coding
│   │   ├── MovementPath.tsx    # Polyline component for routes
│   │   ├── LocationDetailPanel.tsx  # Timeline-centric event list
│   │   ├── UnresolvedPanel.tsx # Ambiguous locations list
│   │   └── MapToolbar.tsx      # Generate button + filters + fullscreen
│   └── detail-sidebar/
│       └── LocationDetail.tsx  # New sidebar content type
└── hooks/
    ├── useGeospatialData.ts    # React Query hook for locations API
    └── useGoogleMaps.ts        # Map API initialization hook
```

### Pattern 1: GeospatialAgentRunner (Clone Synthesis Pattern)

**What:** DomainAgentRunner subclass that assembles location-focused input and produces geocoded location output.

**When to use:** Triggered by user click on "Generate Geospatial Intelligence" button (manual, not automatic).

**Example:**
```python
# Source: backend/app/agents/synthesis.py (lines 42-85)
# Clone and adapt for geospatial
from google.adk.agents import LlmAgent, Tool
from app.agents.domain_agent_runner import DomainAgentRunner
from app.schemas.geospatial import GeospatialOutput

class GeospatialAgentRunner(DomainAgentRunner[GeospatialOutput]):
    """Geospatial agent runner with geocoding tools."""

    def get_agent_name(self) -> str:
        return "geospatial"

    def _get_output_type(self) -> type[GeospatialOutput]:
        return GeospatialOutput

    def _create_agent_instance(
        self, case_id: str, model: str, publish_fn: PublishFn | None,
    ) -> LlmAgent:
        return AgentFactory.create_geospatial_agent(
            case_id, model=model, publish_fn=publish_fn
        )

    async def _prepare_content(
        self, files: list[CaseFile], gcs_bucket: str,
        hypotheses: list[dict[str, object]],
        context_injection: str | None = None, **kwargs: object,
    ) -> types.Content:
        """Build text-only Content from pre-assembled geospatial input."""
        geospatial_input = str(kwargs.get("geospatial_input", ""))
        return types.Content(
            role="user",
            parts=[types.Part(text=geospatial_input)],
        )
```

### Pattern 2: Input Assembly (From Synthesis + Findings + KG)

**What:** Assemble text input containing all location references from synthesis outputs, domain findings, and KG entities.

**When to use:** Before running the geospatial agent.

**Example:**
```python
# Source: backend/app/agents/synthesis.py (lines 93-247)
async def assemble_geospatial_input(case_id: str, db: AsyncSession) -> str:
    """Assemble text-only input for Geospatial Agent.

    Queries:
    - timeline_events (event locations)
    - case_findings (location mentions in text)
    - kg_entities where entity_type='location'
    - case_synthesis (cross-modal links referencing locations)
    """
    case_uuid = UUID(case_id)

    # Query timeline events with location info
    timeline_result = await db.execute(
        select(TimelineEvent)
        .where(TimelineEvent.case_id == case_uuid)
        .order_by(TimelineEvent.event_date)
    )
    timeline_events = list(timeline_result.scalars().all())

    # Query findings that mention locations
    findings_result = await db.execute(
        select(CaseFinding)
        .where(CaseFinding.case_id == case_uuid)
        .order_by(CaseFinding.agent_type)
    )
    findings = list(findings_result.scalars().all())

    # Query KG location entities
    location_entities = await db.execute(
        select(KgEntity)
        .where(
            KgEntity.case_id == case_uuid,
            KgEntity.entity_type == "location",
            KgEntity.merged_into_id.is_(None)
        )
    )
    locations = list(location_entities.scalars().all())

    # Assemble sections
    parts = [
        "--- TIMELINE EVENTS WITH LOCATIONS ---",
        format_timeline_events(timeline_events),
        "--- DOMAIN FINDINGS ---",
        format_findings_for_locations(findings),
        "--- KNOWN LOCATION ENTITIES ---",
        format_location_entities(locations),
    ]

    return "\n\n".join(parts)
```

### Pattern 3: Geocoding with Context-Aware Disambiguation

**What:** LLM-based location extraction and geocoding with contextual disambiguation.

**When to use:** When locations are ambiguous (e.g., "Springfield" without state context).

**Example:**
```python
# Source: Google Maps Geocoding API Best Practices
# https://developers.google.com/maps/documentation/geocoding/best-practices
from app.services.geocoding import geocode_with_cache

async def geocode_location(
    location_name: str,
    context_excerpts: list[str],
    case_metadata: dict,
) -> dict | None:
    """Geocode with context-based disambiguation.

    Strategy:
    1. Try exact location name first
    2. If multiple results, use LLM to pick best match based on case context
    3. If no results, extract address components from context and retry
    4. Cache results for 30 days (Google ToS allows this)
    """
    # First attempt: direct geocoding
    results = await geocode_with_cache(location_name)

    if not results:
        return None

    if len(results) == 1:
        return results[0]  # Unambiguous

    # Multiple results: use LLM to disambiguate based on context
    disambiguation_prompt = f"""
    Location name: {location_name}

    Geocoding returned {len(results)} possible matches:
    {format_geocoding_results(results)}

    Case context excerpts:
    {format_context_excerpts(context_excerpts)}

    Which result is most likely given the case context?
    Return the index (0-based) of the best match.
    """

    # Use LLM to select best match
    best_index = await llm_select_best_geocoding_match(
        disambiguation_prompt, max_index=len(results)-1
    )

    return results[best_index]
```

### Pattern 4: Map Component with @vis.gl/react-google-maps

**What:** Declarative React map using Google's official library.

**When to use:** Map View page rendering.

**Example:**
```typescript
// Source: @vis.gl/react-google-maps documentation
// https://visgl.github.io/react-google-maps/docs
import { APIProvider, Map, AdvancedMarker } from '@vis.gl/react-google-maps';
import { useGeospatialData } from '@/hooks/useGeospatialData';

export function MapView({ caseId }: { caseId: string }) {
  const { locations, isLoading } = useGeospatialData(caseId);
  const [selectedLocation, setSelectedLocation] = useState<string | null>(null);

  if (isLoading) return <MapSkeleton />;

  return (
    <APIProvider apiKey={process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}>
      <Map
        defaultCenter={{ lat: 37.7749, lng: -122.4194 }}
        defaultZoom={10}
        mapId="holmes-case-map"
        style={{ width: '100%', height: '100%' }}
      >
        {locations.map((location) => (
          <AdvancedMarker
            key={location.id}
            position={{ lat: location.latitude, lng: location.longitude }}
            onClick={() => setSelectedLocation(location.id)}
          >
            <LocationMarker
              type={location.location_type}
              color={getEntityColor(location.location_type)}
            />
          </AdvancedMarker>
        ))}

        {/* Movement paths */}
        {locations.filter(loc => loc.movement_to).map((loc) => (
          <MovementPath
            key={`path-${loc.id}`}
            from={loc}
            to={findLocation(locations, loc.movement_to)}
            isInferred={loc.movement_confidence < 0.8}
          />
        ))}
      </Map>

      {selectedLocation && (
        <LocationDetailPanel
          locationId={selectedLocation}
          caseId={caseId}
          onClose={() => setSelectedLocation(null)}
        />
      )}
    </APIProvider>
  );
}
```

### Pattern 5: Smart Offset for Nearby Markers

**What:** Spread nearby markers slightly to prevent overlap without clustering.

**When to use:** When multiple locations are within ~50 pixels of each other on the map.

**Example:**
```typescript
// Apply slight offset to nearby markers for visibility
function applySmartOffset(
  locations: Location[],
  mapBounds: google.maps.LatLngBounds,
): Location[] {
  const OFFSET_THRESHOLD_METERS = 100; // Treat as "nearby" within 100m
  const OFFSET_AMOUNT = 0.0001; // ~11 meters at equator

  const offsetLocations = [...locations];
  const spatialIndex = new Map<string, number>();

  for (let i = 0; i < offsetLocations.length; i++) {
    const loc = offsetLocations[i];
    const gridKey = `${Math.floor(loc.latitude * 10000)},${Math.floor(loc.longitude * 10000)}`;

    const nearbyCount = spatialIndex.get(gridKey) || 0;

    if (nearbyCount > 0) {
      // Apply spiral offset
      const angle = (nearbyCount * Math.PI * 2) / 8; // 8-point spiral
      offsetLocations[i] = {
        ...loc,
        latitude: loc.latitude + Math.cos(angle) * OFFSET_AMOUNT * nearbyCount,
        longitude: loc.longitude + Math.sin(angle) * OFFSET_AMOUNT * nearbyCount,
      };
    }

    spatialIndex.set(gridKey, nearbyCount + 1);
  }

  return offsetLocations;
}
```

### Anti-Patterns to Avoid

- **Using deprecated google-map-react library**: The community-maintained google-map-react is less reliable than Google's official @vis.gl/react-google-maps. Use the official library.
- **Pre-fetching and caching geocoded coordinates without place IDs**: Google's ToS allows caching lat/lng for 30 days but requires place IDs for longer storage. Cache both.
- **Measuring distances in lat/lng degrees**: Always use PostGIS ST_Distance with geography type or Google Maps Distance Matrix API. Degrees are not meters.
- **Auto-triggering geospatial agent on synthesis**: CONTEXT.md explicitly states manual trigger only. User controls when to generate.
- **Clustering markers**: CONTEXT.md decision: smart offset, not clustering. Each location must remain individually visible.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Geocoding API calls | Custom HTTP wrapper | Google Maps Platform client library OR simple aiohttp with retry | Client library includes retry logic + quota management |
| Location extraction from text | Regex patterns | LLM with context-aware reasoning | Handles ambiguity (e.g., "Springfield" → Springfield, IL vs MA) based on case context |
| Map marker clustering | Custom quadtree + viewport calculation | @googlemaps/markerclusterer OR smart offset | Per CONTEXT.md: smart offset preferred, but if clustering needed, use battle-tested library |
| Movement pattern detection | Custom trajectory analysis | LLM-based reasoning on temporal + spatial associations | LLM can infer patterns from narrative context (e.g., "traveled from X to Y on date Z") |
| Coordinate transformations | Manual math | PostGIS ST_Transform OR leave in WGS84 | Google Maps uses WGS84 (EPSG:4326); PostGIS handles other CRS |
| Place disambiguation | String matching | LLM-based contextual selection | "Paris" could be Paris, France or Paris, Texas — LLM uses case context to decide |

**Key insight:** Geocoding and location intelligence are inherently ambiguous tasks. LLMs excel at using narrative context to disambiguate (e.g., case about Texas fraud → "Houston" likely means Houston, TX). Don't attempt rule-based disambiguation.

## Common Pitfalls

### Pitfall 1: Coordinate System Mismatches
**What goes wrong:** Storing coordinates in one CRS (e.g., Web Mercator EPSG:3857) but displaying in another (WGS84 EPSG:4326), causing locations to appear in the wrong place.
**Why it happens:** Different mapping libraries default to different coordinate systems. Google Maps uses WGS84.
**How to avoid:**
- Store all coordinates in the `locations` table as WGS84 (latitude/longitude in degrees).
- Use `GEOGRAPHY` type in PostGIS (not GEOMETRY) for automatic WGS84 handling.
- Never perform distance calculations on raw lat/lng degrees — use PostGIS `ST_Distance` with geography type.
**Warning signs:** Locations appear hundreds of miles from their actual position; distance queries return nonsensical values.

### Pitfall 2: Geocoding API Rate Limit Exhaustion
**What goes wrong:** Agent tries to geocode 200 locations simultaneously, hits Google's 3,000/minute quota, subsequent requests fail.
**Why it happens:** Batch geocoding without rate limiting.
**How to avoid:**
- Implement request batching with delays: max 50 requests per second.
- Use exponential backoff for `OVER_QUERY_LIMIT` responses.
- Cache geocoded results in DB for 30 days (Google ToS allows this).
- For large batches, use async queue with semaphore limiting concurrency.
**Warning signs:** `OVER_QUERY_LIMIT` errors in logs; some locations fail to geocode.

### Pitfall 3: Ambiguous Location Stored Without Disambiguation
**What goes wrong:** Agent geocodes "Springfield" to Springfield, MA when case context indicates Springfield, IL. User sees wrong location on map.
**Why it happens:** Geocoding API returns first result without considering case context.
**How to avoid:**
- When geocoding returns multiple results, use LLM to select best match based on case excerpts.
- Store `confidence_score` and `disambiguation_reasoning` in `locations` table.
- Flag low-confidence locations (<0.7) as "unresolved" and show in separate panel per CONTEXT.md.
**Warning signs:** Locations in unexpected geographic regions; user reports "wrong city."

### Pitfall 4: Missing Location Entity Citations
**What goes wrong:** Location shows on map but clicking it reveals no supporting evidence or source excerpts.
**Why it happens:** Agent output doesn't link locations back to specific findings/timeline events.
**How to avoid:**
- GeospatialOutput schema MUST include `source_finding_ids`, `source_event_ids`, and `evidence_excerpts` for each location.
- Detail panel displays timeline-centric view: "Events that happened at this location" with expandable citations.
- Follow existing citation pattern from KG entities (file_id + page/timestamp + excerpt).
**Warning signs:** Location detail panel shows "No events found at this location."

### Pitfall 5: Fullscreen Mode State Loss
**What goes wrong:** User enters fullscreen, clicks on location, exits fullscreen, and detail panel disappears.
**Why it happens:** Fullscreen API triggers component remount; local state is lost.
**How to avoid:**
- Store selected location ID in URL params (`?location={id}`) or React Context.
- Listen to `fullscreenchange` event and preserve UI state across transitions.
- Use libraries like `react-full-screen` which handle state persistence.
**Warning signs:** User complains "map resets when I exit fullscreen."

### Pitfall 6: Movement Paths Crossing Map Boundaries
**What goes wrong:** Movement path from New York to London draws straight line across Atlantic, crossing continents.
**Why it happens:** Polylines in Google Maps default to straight Euclidean lines, not great-circle (geodesic) paths.
**How to avoid:**
- Set `geodesic: true` on Polyline component for long-distance paths.
- For short distances (<100km), straight lines are fine.
- Detect long-distance paths (>1000km) and enable geodesic automatically.
**Warning signs:** Movement paths look wrong on global map views; lines cross through continents.

### Pitfall 7: Map Tooltip Performance Degradation
**What goes wrong:** Hovering over markers causes lag; map stutters with 50+ locations.
**Why it happens:** Tooltip renders trigger expensive re-renders of entire map component.
**How to avoid:**
- Use React.memo on LocationMarker components.
- Implement single shared Tooltip component (not one per marker).
- Delay tooltip display by 200ms (debounce hover events).
- Keep tooltip content lightweight (location name only; full details on click).
**Warning signs:** Map FPS drops when hovering; browser devtools show excessive renders.

### Pitfall 8: Geospatial Agent Input Too Large
**What goes wrong:** Agent receives 500 timeline events + 200 findings + 100 KG entities, exceeds context window, crashes.
**Why it happens:** Large cases generate massive amounts of location-referencing data.
**How to avoid:**
- Filter input to only findings/events that mention location keywords (regex pre-filter).
- Summarize findings longer than 500 tokens (extract location mentions only).
- Limit input to most recent 100 timeline events + top 50 findings by relevance.
- Use Gemini Pro with 1M context window (already standard for synthesis).
**Warning signs:** Agent times out; logs show "context length exceeded."

## Code Examples

### Example 1: Geocoding with Caching and Rate Limiting
```python
# Source: Google Maps Geocoding API Best Practices
# https://developers.google.com/maps/documentation/geocoding/best-practices
import asyncio
from datetime import datetime, timedelta
from typing import Any

import aiohttp
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.geocoding_cache import GeocodingCache  # New model

GOOGLE_MAPS_API_KEY = os.getenv("GOOGLE_MAPS_API_KEY")
CACHE_TTL_DAYS = 30  # Google ToS allows 30-day cache

async def geocode_with_cache(
    address: str,
    db: AsyncSession,
    component_restrictions: dict[str, str] | None = None,
) -> list[dict[str, Any]]:
    """Geocode address with 30-day cache and rate limiting.

    Args:
        address: Full address or place name
        db: Database session
        component_restrictions: Optional country/region filters

    Returns:
        List of geocoding results (empty if none found)
    """
    # Check cache first
    cache_key = f"{address}:{component_restrictions or {}}"
    cached = await db.execute(
        select(GeocodingCache).where(
            GeocodingCache.cache_key == cache_key,
            GeocodingCache.expires_at > datetime.utcnow(),
        )
    )
    if cached_result := cached.scalar_one_or_none():
        return cached_result.results

    # Rate limit: max 50 requests/second = 20ms between requests
    await asyncio.sleep(0.02)

    # Call Google Maps Geocoding API
    async with aiohttp.ClientSession() as session:
        params = {
            "address": address,
            "key": GOOGLE_MAPS_API_KEY,
        }
        if component_restrictions:
            params["components"] = "|".join(
                f"{k}:{v}" for k, v in component_restrictions.items()
            )

        async with session.get(
            "https://maps.googleapis.com/maps/api/geocode/json",
            params=params,
        ) as response:
            data = await response.json()

    if data["status"] == "OVER_QUERY_LIMIT":
        # Exponential backoff
        await asyncio.sleep(1)
        return await geocode_with_cache(address, db, component_restrictions)

    results = data.get("results", [])

    # Cache results for 30 days
    cache_entry = GeocodingCache(
        cache_key=cache_key,
        address=address,
        results=results,
        expires_at=datetime.utcnow() + timedelta(days=CACHE_TTL_DAYS),
    )
    db.add(cache_entry)
    await db.flush()

    return results
```

### Example 2: Movement Path Polyline Component
```typescript
// Source: @vis.gl/react-google-maps Polyline examples
import { useMap } from '@vis.gl/react-google-maps';
import { useEffect, useRef } from 'react';

interface MovementPathProps {
  from: { latitude: number; longitude: number };
  to: { latitude: number; longitude: number };
  isInferred: boolean; // true = dashed line, false = solid line
  color?: string;
}

export function MovementPath({ from, to, isInferred, color = '#4285F4' }: MovementPathProps) {
  const map = useMap();
  const polylineRef = useRef<google.maps.Polyline | null>(null);

  useEffect(() => {
    if (!map) return;

    // Calculate distance to determine if geodesic is needed
    const distance = google.maps.geometry.spherical.computeDistanceBetween(
      new google.maps.LatLng(from.latitude, from.longitude),
      new google.maps.LatLng(to.latitude, to.longitude)
    );

    const polyline = new google.maps.Polyline({
      path: [
        { lat: from.latitude, lng: from.longitude },
        { lat: to.latitude, lng: to.longitude },
      ],
      geodesic: distance > 100000, // Use geodesic for >100km
      strokeColor: color,
      strokeOpacity: isInferred ? 0.6 : 1.0,
      strokeWeight: 2,
      icons: isInferred ? [
        {
          icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 3 },
          offset: '0',
          repeat: '20px', // Dashed pattern
        },
      ] : undefined,
    });

    polyline.setMap(map);
    polylineRef.current = polyline;

    return () => {
      polyline.setMap(null);
    };
  }, [map, from, to, isInferred, color]);

  return null;
}
```

### Example 3: Location Detail Panel (Timeline-Centric)
```typescript
// Source: CONTEXT.md Phase 8.1 decisions + existing sidebar patterns
import { useQuery } from '@tanstack/react-query';
import { format } from 'date-fns';

interface LocationDetailPanelProps {
  locationId: string;
  caseId: string;
  onClose: () => void;
}

export function LocationDetailPanel({ locationId, caseId, onClose }: LocationDetailPanelProps) {
  const { data: location } = useQuery({
    queryKey: ['location', locationId],
    queryFn: () => api.getLocation(caseId, locationId),
  });

  const { data: events } = useQuery({
    queryKey: ['location-events', locationId],
    queryFn: () => api.getLocationEvents(caseId, locationId),
  });

  if (!location) return <PanelSkeleton />;

  return (
    <div className="location-detail-panel">
      <div className="panel-header">
        <h3>{location.name}</h3>
        <button onClick={onClose}>×</button>
      </div>

      <div className="location-meta">
        <div className="confidence">
          Confidence: {Math.round(location.confidence_score * 100)}%
        </div>
        <div className="coordinates">
          {location.latitude.toFixed(6)}, {location.longitude.toFixed(6)}
        </div>
      </div>

      {location.disambiguation_reasoning && (
        <div className="disambiguation-note">
          {location.disambiguation_reasoning}
        </div>
      )}

      <div className="events-section">
        <h4>Events at this Location</h4>
        {events?.length ? (
          <div className="event-list">
            {events.sort((a, b) =>
              new Date(a.event_date).getTime() - new Date(b.event_date).getTime()
            ).map((event) => (
              <div key={event.id} className="event-card">
                <div className="event-date">
                  {format(new Date(event.event_date), 'MMM d, yyyy')}
                </div>
                <div className="event-title">{event.title}</div>
                <div className="event-description">{event.description}</div>

                {/* Expandable citations */}
                <details className="event-sources">
                  <summary>View Sources ({event.citations?.length || 0})</summary>
                  <CitationList citations={event.citations} caseId={caseId} />
                </details>
              </div>
            ))}
          </div>
        ) : (
          <div className="empty-state">No events recorded at this location</div>
        )}
      </div>
    </div>
  );
}
```

### Example 4: GeospatialOutput Schema
```python
# Source: Adapted from backend/app/schemas/synthesis.py
from pydantic import BaseModel, Field

class LocationEvidence(BaseModel):
    """Citation for location reference."""
    finding_id: str | None = None
    event_id: str | None = None
    excerpt: str
    confidence: float = Field(ge=0, le=1)

class GeospatialLocation(BaseModel):
    """Single geocoded location."""
    name: str
    location_type: str  # "address", "city", "building", "landmark", "region"
    latitude: float = Field(ge=-90, le=90)
    longitude: float = Field(ge=-180, le=180)
    place_id: str | None = None  # Google Place ID for cache
    confidence_score: float = Field(ge=0, le=1, description="Geocoding confidence")
    disambiguation_reasoning: str | None = Field(
        None,
        description="Why this location was chosen over alternatives",
    )
    temporal_associations: list[str] = Field(
        default_factory=list,
        description="Dates/periods associated with this location",
    )
    evidence: list[LocationEvidence] = Field(
        min_items=1,
        description="Source citations for location reference",
    )
    related_entity_ids: list[str] = Field(
        default_factory=list,
        description="KG entity UUIDs associated with location",
    )

class MovementPattern(BaseModel):
    """Detected movement between locations."""
    from_location_index: int = Field(description="Index in locations array")
    to_location_index: int = Field(description="Index in locations array")
    movement_date: str | None = Field(None, description="ISO 8601 date if known")
    confidence: float = Field(ge=0, le=1, description="Inferred vs confirmed")
    evidence_excerpt: str

class UnresolvedLocation(BaseModel):
    """Location that could not be geocoded with confidence."""
    name: str
    context_excerpt: str
    ambiguity_reason: str  # "multiple_matches", "no_results", "insufficient_context"
    possible_matches: list[dict] | None = None

class GeospatialOutput(BaseModel):
    """Structured output from Geospatial Agent."""
    locations: list[GeospatialLocation] = Field(
        default_factory=list,
        description="Successfully geocoded locations",
    )
    movement_patterns: list[MovementPattern] = Field(
        default_factory=list,
        description="Detected movement between locations",
    )
    unresolved_locations: list[UnresolvedLocation] = Field(
        default_factory=list,
        description="Locations that could not be geocoded",
    )
    spatial_insights: str = Field(
        description="Narrative summary of geographic patterns",
    )
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Rule-based NER (spaCy) for location extraction | LLM-based context-aware extraction | 2025-2026 | LLMs achieve 15-30% better disambiguation accuracy using case context |
| Community react-google-maps | Official @vis.gl/react-google-maps | 2024 | Better type safety, official support, tighter Google Maps integration |
| Manual geocoding with fetch() | Client libraries with retry logic | 2025 | Built-in quota management, exponential backoff |
| Marker clustering by default | Smart offset for investigative use cases | 2026 | Maintains individual location visibility for case analysis |
| Separate geocoding/location services | LLM agents with geocoding tools | 2025-2026 (Agentic AI trend) | Function calling enables context-aware geocoding decisions |

**Deprecated/outdated:**
- google-map-react library: Unmaintained, use @vis.gl/react-google-maps
- Places API Autocomplete for batch geocoding: Use Geocoding API for complete addresses
- Client-side geocoding without caching: Google ToS allows 30-day cache, use it
- GEOMETRY PostGIS type for coordinates: Use GEOGRAPHY for automatic WGS84 spherical calculations

## Open Questions

1. **Google Earth Engine Integration Timing**
   - REQ-GEO-005 requires Earth Engine for satellite imagery, but approval process takes days/weeks.
   - What we know: Earth Engine needs GCP project setup, OAuth2 auth, quota tier selection (by April 27, 2026).
   - What's unclear: Should Phase 8.1 include Earth Engine stubs or defer entirely to future phase?
   - Recommendation: Defer to Phase 8.2. Phase 8.1 focuses on geocoding + map display only.

2. **Location Entity Color Palette Reuse**
   - CONTEXT.md says "reuse Knowledge Graph entity color palette for location markers."
   - What we know: KG uses color-coded entity types (person, organization, location, event, etc.).
   - What's unclear: Does `location_type` ("address", "city", "building") map to KG entity types, or do we need a separate geospatial color palette?
   - Recommendation: Map `location_type` to existing KG colors where possible (e.g., "building" → organization color), add new colors for geospatial-specific types.

3. **Geospatial Agent Trigger from Chat**
   - REQ-GEO-002 mentions "on-demand invocation via Chat interface" but CONTEXT.md says manual button only.
   - What we know: User can click "Generate Geospatial Intelligence" in Map View toolbar.
   - What's unclear: Should Chat Agent have a `run_geospatial_agent()` tool for user queries like "map all locations"?
   - Recommendation: Yes, add tool to Chat Agent (Phase 9) but keep manual button as primary trigger in Phase 8.1.

## Sources

### Primary (HIGH confidence)
- [@vis.gl/react-google-maps Documentation](https://visgl.github.io/react-google-maps/docs) - Official React library docs
- [Google Maps Geocoding API Best Practices](https://developers.google.com/maps/documentation/geocoding/best-practices) - Authoritative geocoding guidance
- [PostGIS ST_Distance Documentation](https://postgis.net/docs/ST_Distance.html) - Geospatial query functions
- [Google Earth Engine Python API Guide](https://developers.google.com/earth-engine/tutorials/community/intro-to-python-api) - Earth Engine setup (future phase)
- Codebase: `backend/app/agents/synthesis.py` - DomainAgentRunner pattern to clone
- Codebase: `backend/app/models/synthesis.py` lines 170-196 - Location model already exists
- Codebase: `frontend/package.json` line 24 - @vis.gl/react-google-maps 1.7.1 already installed

### Secondary (MEDIUM confidence)
- [React Map Library Comparison](https://blog.logrocket.com/react-map-library-comparison/) - Leaflet vs Mapbox vs Google Maps
- [Google Maps API Pricing 2026](https://developers.google.com/maps/billing-and-pricing/pricing) - Rate limits and costs
- [PostGIS Geospatial Search Guide](https://neon.com/guides/geospatial-search) - PostgreSQL + PostGIS patterns
- [Mapbox MCP Server for LLM Agents](https://www.mapbox.com/blog/introducing-the-mapbox-model-context-protocol-mcp-server) - LLM geocoding tools pattern
- [Modern Named Entity Recognition 2026](https://akankshaonearth.medium.com/modern-named-entity-recognition-beyond-traditional-nlp-with-transformers-and-llms-2026-c935ef31e692) - LLM-based NER approaches

### Tertiary (LOW confidence)
- [Performance Testing on Marker Clustering](https://www.mdpi.com/2220-9964/8/8/348) - Comparative study (2019, may be outdated)
- [Oregon Geolocation Privacy Law](https://www.proskauer.com/blog/oregon-strengthens-geolocation-data-privacy) - Privacy compliance considerations

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - @vis.gl/react-google-maps already installed, Google Maps API is industry standard
- Architecture: HIGH - Direct clone of Synthesis Agent pattern, proven in Phase 8
- Pitfalls: HIGH - Coordinate systems, rate limits, ambiguity are well-documented challenges
- Geocoding strategy: MEDIUM - LLM-based disambiguation is emerging pattern, limited production examples
- Earth Engine integration: LOW - REQ-GEO-005 is future phase, approval timeline uncertain

**Research date:** 2026-02-09
**Valid until:** 90 days (geocoding API pricing/quotas may change; mapping library APIs stable)
