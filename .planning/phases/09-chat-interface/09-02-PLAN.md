---
phase: 09-chat-interface
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - frontend/src/types/chatbot.ts
  - frontend/src/hooks/useChatbot.ts
  - frontend/src/components/app/chatbot.tsx
  - frontend/src/app/(app)/cases/[id]/layout.tsx
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "User types a message and sees tokens stream in real-time"
    - "Tool calls show as expandable 'Agent is working...' section"
    - "Citations render as inline clickable chips in assistant messages"
    - "Clicking a citation chip opens SourceViewerModal at the correct page/timestamp"
    - "Stop button appears during streaming and cancels the response"
    - "Clear button resets chat history with single click"
    - "Chat is disabled with message when analysis hasn't been run"
    - "Assistant messages render full markdown (headers, lists, bold, code blocks)"
    - "Errors appear as inline red-tinted message bubbles with retry button"
  artifacts:
    - path: "frontend/src/types/chatbot.ts"
      provides: "Streaming event types, citation types, tool activity types"
      exports: ["ChatMessage", "ChatCitation", "ToolActivity", "ChatStreamEvent"]
    - path: "frontend/src/hooks/useChatbot.ts"
      provides: "SSE streaming hook with token accumulation and abort support"
      exports: ["useChatbot"]
    - path: "frontend/src/components/app/chatbot.tsx"
      provides: "Enhanced chat UI with markdown, citations, tool activity, stop/clear buttons"
      exports: ["Chatbot"]
  key_links:
    - from: "frontend/src/hooks/useChatbot.ts"
      to: "/api/cases/:caseId/chat"
      via: "fetchEventSource POST"
      pattern: "fetchEventSource.*cases.*chat"
    - from: "frontend/src/components/app/chatbot.tsx"
      to: "frontend/src/hooks/useChatbot.ts"
      via: "hook consumption"
      pattern: "useChatbot"
    - from: "frontend/src/components/app/chatbot.tsx"
      to: "frontend/src/hooks/useSourceNavigation.ts"
      via: "citation click handler"
      pattern: "useSourceNavigation"
---

<objective>
Rewrite the frontend chat hook for SSE streaming and enhance the chatbot component with markdown rendering, inline citation chips, tool activity indicators, stop/clear buttons, and disabled state when analysis hasn't run.

Purpose: Connects the existing floating chat UI to the real backend agent, transforming it from mock responses into evidence-backed streaming Q&A with clickable source citations.

Output: Updated frontend types, rewritten hook, and enhanced chatbot component.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-chat-interface/09-CONTEXT.md
@.planning/phases/09-chat-interface/09-RESEARCH.md
@.planning/phases/09-chat-interface/09-01-SUMMARY.md

# Key frontend files to reference and modify
@frontend/src/types/chatbot.ts
@frontend/src/hooks/useChatbot.ts
@frontend/src/components/app/chatbot.tsx
@frontend/src/app/(app)/cases/[id]/layout.tsx
@frontend/src/hooks/useSourceNavigation.ts
@frontend/src/lib/citation-utils.ts
@frontend/src/lib/api-client.ts
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install fetch-event-source, update types, rewrite useChatbot hook</name>
  <files>
    frontend/package.json
    frontend/src/types/chatbot.ts
    frontend/src/hooks/useChatbot.ts
  </files>
  <action>
  **Install dependency:**
  Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun add @microsoft/fetch-event-source`

  **Update `frontend/src/types/chatbot.ts`:**
  Rewrite the types file to support streaming. Keep existing types that are still useful, add new ones:

  ```typescript
  // Core message type -- updated with citations and error state
  export interface ChatMessage {
    id: string;
    role: "user" | "assistant" | "error";
    content: string;
    timestamp: Date;
    citations?: ChatCitation[];
    isStreaming?: boolean;  // true while tokens are still arriving
  }

  // Structured citation extracted from [[file_id|locator|label]] markers
  export interface ChatCitation {
    file_id: string;
    locator: string;
    label: string;
  }

  // Tool activity tracking during streaming
  export interface ToolActivity {
    tool_name: string;
    status: "running" | "complete";
    started_at: Date;
  }

  // SSE event types from backend
  export type ChatStreamEvent =
    | { event: "chat-token"; data: { text: string } }
    | { event: "chat-tool-start"; data: { tool_name: string } }
    | { event: "chat-tool-end"; data: { tool_name: string } }
    | { event: "chat-done"; data: { message: string; citations: ChatCitation[] } }
    | { event: "chat-error"; data: { error: string } };

  // Context passed to the chatbot
  export interface ChatbotContext {
    caseId?: string;
    caseName?: string;
    caseDescription?: string;
    caseStatus?: string;
  }

  // Hook return type
  export interface UseChatbotReturn {
    messages: ChatMessage[];
    isStreaming: boolean;
    toolActivities: ToolActivity[];
    sendMessage: (content: string) => Promise<void>;
    stopStreaming: () => void;
    clearMessages: () => void;
    error: string | null;
  }
  ```

  **Rewrite `frontend/src/hooks/useChatbot.ts`:**
  Complete rewrite to use SSE streaming via `@microsoft/fetch-event-source`.

  The hook must:
  1. Accept `{ caseId: string }` as primary config (not the old ChatbotContext).
  2. Manage state: `messages: ChatMessage[]`, `isStreaming: boolean`, `toolActivities: ToolActivity[]`, `error: string | null`.
  3. Use an `AbortController` ref for stream cancellation.
  4. `sendMessage(content: string)`:
     - Add user message to state immediately.
     - Add a placeholder assistant message with `isStreaming: true` and empty content.
     - Get auth token from the api-client module (import `getAuthToken` or use the pattern from `api-client.ts` to read the session cookie/token).
     - Call `fetchEventSource` with:
       - URL: `${NEXT_PUBLIC_API_URL}/api/cases/${caseId}/chat`
       - Method: POST
       - Headers: `Content-Type: application/json`, `Authorization: Bearer ${token}`
       - Body: `{ message: content }`
       - `signal: abortController.signal`
     - `onmessage` handler: Switch on `event.event`:
       - `chat-token`: Append `data.text` to the streaming assistant message content. Update the last message in state.
       - `chat-tool-start`: Add to `toolActivities` with status "running".
       - `chat-tool-end`: Update matching tool activity to status "complete".
       - `chat-done`: Finalize the assistant message: set `isStreaming: false`, set `content` to `data.message`, set `citations` to `data.citations`.
       - `chat-error`: Add an error message bubble (role "error") with the error text.
     - `onerror` handler: Set error state, add error message. Throw to prevent retries.
     - `onclose` handler: If streaming was not explicitly stopped, finalize message.
  5. `stopStreaming()`: Call `abortController.abort()`. Finalize the current streaming message with whatever content has been accumulated so far (set `isStreaming: false`).
  6. `clearMessages()`: Reset messages to empty array. Reset error. Generate new session ID (so backend creates a fresh ADK session).

  **Important patterns to follow:**
  - Use `useRef` for the AbortController (not state -- avoids re-renders).
  - Use functional state updates (`setMessages(prev => ...)`) to avoid stale closures.
  - The auth token retrieval must match the existing pattern in the codebase. Check `api-client.ts` for how tokens are obtained. It likely uses Better Auth's session cookie. The `api` object in `api-client.ts` includes auth headers automatically -- look at how it's done and replicate for the `fetchEventSource` call.
  - Do NOT send conversation history in the request body. The ADK session manages history server-side. Frontend sends only the latest message.
  - Handle the case where `NEXT_PUBLIC_API_URL` is the env var for the backend URL (check how other API calls in the codebase construct URLs).
  </action>
  <verify>
  Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run typecheck` to verify types compile. Check that `@microsoft/fetch-event-source` is in package.json.
  </verify>
  <done>
  Types updated with streaming/citation/tool-activity interfaces. useChatbot hook rewritten with SSE streaming via fetchEventSource. Auth token obtained matching codebase pattern. AbortController for cancellation. Functional state updates for stale-closure safety.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance chatbot component with markdown, citations, tool activity, stop/clear, disabled state</name>
  <files>
    frontend/src/components/app/chatbot.tsx
    frontend/src/app/(app)/cases/[id]/layout.tsx
  </files>
  <action>
  **Enhance `frontend/src/components/app/chatbot.tsx`:**

  Preserve the existing visual design (liquid glass, dragging, resizing, floating button, header, animations). Enhance the message rendering and add new features:

  **1. Markdown rendering for assistant messages:**
  - Import `ReactMarkdown` from `react-markdown` and `remarkGfm` from `remark-gfm`.
  - Replace the plain `<p>` text rendering for assistant messages with `<ReactMarkdown remarkPlugins={[remarkGfm]}>`.
  - Apply appropriate Tailwind prose classes for dark theme styling. Use custom className mapping -- do NOT use `@tailwindcss/typography` prose classes if not installed. Instead, style markdown elements via ReactMarkdown's `components` prop:
    - `h1/h2/h3`: appropriate sizes with `text-[#faf9f7]` color
    - `p`: `text-sm leading-relaxed`
    - `ul/ol`: `list-disc/list-decimal ml-4`
    - `code`: `bg-black/20 px-1 rounded text-xs`
    - `pre`: `bg-black/30 p-3 rounded-lg overflow-x-auto`
    - `strong`: `font-semibold`
    - `a`: `text-blue-400 hover:underline`

  **2. Citation chip rendering in assistant messages:**
  - Before passing content to ReactMarkdown, parse citation markers using regex: `\[\[([a-f0-9-]+)\|([^|]*)\|([^\]]+)\]\]`
  - Replace each citation marker with a special placeholder token (e.g., `__CITE_0__`) and store the citation data.
  - Use ReactMarkdown's `components.text` (or process the rendered output) to replace placeholders with `<CitationChip>` components.
  - **Alternative simpler approach:** Create a custom `ChatMessageContent` component that:
    1. Splits the text on the citation regex.
    2. Renders non-citation parts through ReactMarkdown (or as plain text within markdown flow).
    3. Renders citation parts as inline `<button>` chips styled as small pill badges.
  - Citation chip design: Small rounded pill with file icon, label text, glass background (`bg-white/10 hover:bg-white/20 border border-white/20 rounded-full px-2 py-0.5 text-xs inline-flex items-center gap-1 cursor-pointer`).
  - On chip click: Call `useSourceNavigation` hook's `openFromCitation` (or equivalent) with `{ file_id, locator, excerpt: "" }`. Import `useSourceNavigation` from `@/hooks/useSourceNavigation`.
  - On chip hover: Show a tooltip with the locator info and file label (use `title` attribute for simplicity, or a lightweight tooltip).

  **3. Tool activity section (expandable "Agent is working..."):**
  - When `toolActivities.length > 0` and `isStreaming`, show a collapsible section above the streaming message.
  - Collapsed view: "Agent is working..." with a spinning indicator and count badge.
  - Expanded view: List of tool activities with status icons:
    - "running": spinning icon + tool_name (humanized: "query_knowledge_graph" -> "Searching knowledge graph...")
    - "complete": checkmark icon + tool_name
  - Style: subtle glass background, smaller text, matches existing chat bubble style.
  - Map tool names to human-readable labels:
    - `query_knowledge_graph` -> "Searching knowledge graph"
    - `get_findings` -> "Querying domain findings"
    - `get_synthesis` -> "Loading synthesis data"
    - `search_findings` -> "Searching case evidence"

  **4. Stop button:**
  - Show a "Stop" button (square icon) next to the send button when `isStreaming` is true.
  - On click: Call `stopStreaming()` from the hook.
  - Style: Same button style as send but with a stop icon (Square from lucide-react).

  **5. Clear button:**
  - Add a small "Clear" button in the header (between minimize and close, or next to the title).
  - On click: Call `clearMessages()` from the hook. No confirmation needed (per CONTEXT.md decision).
  - Style: Small text button or icon (Trash2 from lucide-react), subtle styling.

  **6. Disabled state when analysis hasn't run:**
  - Accept `analysisAvailable: boolean` prop (or derive from caseStatus).
  - When disabled, overlay the message area with a centered message: "Run analysis first to enable chat"
  - Disable the input field and send button.
  - Keep the chat window openable but non-functional.

  **7. Error messages as inline bubbles:**
  - Messages with `role: "error"` render as red-tinted bubbles.
  - Style: `bg-red-500/10 border-red-500/20 text-red-400`.
  - Include a "Retry" button that re-sends the last user message.

  **8. Update hook consumption:**
  - Replace `const { messages, isTyping, sendMessage } = useChatbot(...)` with the new hook signature:
    `const { messages, isStreaming, toolActivities, sendMessage, stopStreaming, clearMessages, error } = useChatbot({ caseId })`
  - Remove the old `context` passing pattern. The hook now only needs `caseId`.

  **Update `frontend/src/app/(app)/cases/[id]/layout.tsx`:**
  - Pass `analysisAvailable={caseData.latest_workflow_id !== null && caseData.status !== "PROCESSING"}` to the `<Chatbot>` component (or use caseStatus to derive this).
  - Update the `ChatbotProps` interface to accept this new prop.
  - Keep existing props (caseId, caseContext) for backward compatibility, but the hook now primarily uses caseId.

  **Do NOT:**
  - Remove or significantly alter the existing liquid glass styling, dragging, resizing, or animation behavior.
  - Break the existing layout structure.
  - Add any new CSS files or Tailwind plugins.
  </action>
  <verify>
  1. Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes && make generate-types` (if applicable).
  2. Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes && make format` (or `cd frontend && bun run format`).
  3. Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run typecheck`.
  4. Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run build` to verify no build errors.
  </verify>
  <done>
  Chatbot component renders markdown via react-markdown. Citation markers parsed and rendered as inline clickable chips that open SourceViewerModal. Tool activities show as expandable "Agent is working..." section. Stop button cancels streaming. Clear button resets history. Chat disabled when analysis hasn't run. Error messages render as red bubbles with retry. Layout passes analysisAvailable prop. Typecheck and build pass.
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes in frontend directory
2. `bun run build` succeeds in frontend directory
3. Types include ChatCitation, ToolActivity, ChatStreamEvent
4. useChatbot hook uses fetchEventSource with POST to /api/cases/:caseId/chat
5. Citation chips are clickable and use useSourceNavigation
6. Markdown renders correctly in assistant messages
7. Stop button appears during streaming
8. Clear button works without confirmation
9. Chat disabled when analysis hasn't run
</verification>

<success_criteria>
- Frontend chatbot connects to real backend via SSE streaming
- Tokens stream in real-time (classic ChatGPT feel)
- Citation chips are inline, clickable, and open SourceViewerModal
- Tool activity shows during agent processing
- Stop/Clear buttons work correctly
- Chat disabled with message when no analysis
- Error handling with inline red bubbles and retry
- Typecheck and build both pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-chat-interface/09-02-SUMMARY.md`
</output>
