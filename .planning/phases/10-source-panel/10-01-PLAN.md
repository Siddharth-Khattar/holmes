---
phase: 10-source-panel
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/citation-utils.ts
  - frontend/src/hooks/useSourceNavigation.ts
  - frontend/src/hooks/useEntityResolver.ts
  - frontend/src/components/ui/citation-link.tsx
  - frontend/src/components/ui/entity-badge.tsx
autonomous: true

must_haves:
  truths:
    - "parseLocator correctly parses page:N, ts:HH:MM:SS, and region:x,y,w,h formats"
    - "useSourceNavigation resolves a citation {file_id, locator, excerpt} into a SourceViewerContent object"
    - "useEntityResolver returns resolved {name, entity_type, color} for any entity UUID"
    - "CitationLink renders a clickable link showing file name + excerpt snippet"
    - "EntityBadge renders a color-coded entity name with type label"
  artifacts:
    - path: "frontend/src/lib/citation-utils.ts"
      provides: "Locator parser and file category mapper"
      exports: ["parseLocator", "categoryToViewerType", "ParsedLocator"]
    - path: "frontend/src/hooks/useSourceNavigation.ts"
      provides: "Citation-to-SourceViewerModal data pipeline hook"
      exports: ["useSourceNavigation"]
    - path: "frontend/src/hooks/useEntityResolver.ts"
      provides: "Entity UUID to name+type resolution hook"
      exports: ["useEntityResolver"]
    - path: "frontend/src/components/ui/citation-link.tsx"
      provides: "Reusable clickable citation link component"
      exports: ["CitationLink"]
    - path: "frontend/src/components/ui/entity-badge.tsx"
      provides: "Reusable entity name + type badge component"
      exports: ["EntityBadge"]
  key_links:
    - from: "frontend/src/hooks/useSourceNavigation.ts"
      to: "frontend/src/lib/api/files.ts"
      via: "listFiles + getDownloadUrl for file metadata and signed URLs"
      pattern: "listFiles|getDownloadUrl"
    - from: "frontend/src/hooks/useSourceNavigation.ts"
      to: "frontend/src/lib/citation-utils.ts"
      via: "parseLocator and categoryToViewerType"
      pattern: "parseLocator|categoryToViewerType"
    - from: "frontend/src/hooks/useEntityResolver.ts"
      to: "frontend/src/lib/api/graph.ts"
      via: "fetchGraph to load all entities for the case"
      pattern: "fetchGraph"
    - from: "frontend/src/components/ui/entity-badge.tsx"
      to: "frontend/src/lib/knowledge-graph-config.ts"
      via: "getEntityColor for type-based coloring"
      pattern: "getEntityColor"
---

<objective>
Build the shared utilities and hooks that all views will use for citation-to-source navigation and entity name resolution. This is the foundation layer -- no view modifications yet.

Purpose: Every view (KG, Verdict, Geospatial, Timeline) needs to (1) resolve citations into SourceViewerModal content and (2) resolve entity UUIDs into human-readable names. Building these as shared hooks eliminates duplication and ensures consistent behavior.

Output: 5 new files -- citation-utils.ts, useSourceNavigation.ts, useEntityResolver.ts, citation-link.tsx, entity-badge.tsx
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-source-panel/10-CONTEXT.md
@.planning/phases/10-source-panel/10-RESEARCH.md
@frontend/src/components/source-viewer/SourceViewerModal.tsx
@frontend/src/lib/api/files.ts
@frontend/src/lib/api/graph.ts
@frontend/src/hooks/useFileUrlCache.ts
@frontend/src/lib/knowledge-graph-config.ts
@frontend/src/lib/api-client.ts
@frontend/src/types/knowledge-graph.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Citation utilities and useSourceNavigation hook</name>
  <files>
    frontend/src/lib/citation-utils.ts
    frontend/src/hooks/useSourceNavigation.ts
  </files>
  <action>
Create `frontend/src/lib/citation-utils.ts`:

1. Define and export `ParsedLocator` interface:
   ```
   type: "page" | "timestamp" | "region" | "unknown"
   page?: number        // 1-indexed
   timestamp?: number   // seconds
   region?: { x: number; y: number; w: number; h: number }
   ```

2. Export `parseLocator(locator: string): ParsedLocator`:
   - `"page:3"` -> `{ type: "page", page: 3 }`
   - `"ts:01:23:45"` -> `{ type: "timestamp", timestamp: 5025 }` (HH:MM:SS to seconds via reduce)
   - `"ts:23:45"` -> `{ type: "timestamp", timestamp: 1425 }` (MM:SS also supported)
   - `"region:x,y,w,h"` -> `{ type: "region", region: { x, y, w, h } }`
   - Anything else -> `{ type: "unknown" }`
   - Handle null/undefined/empty string gracefully (return unknown)

3. Export `categoryToViewerType(category: string): SourceViewerContent["type"]`:
   - "DOCUMENT" -> "pdf"
   - "AUDIO" -> "audio"
   - "VIDEO" -> "video"
   - "IMAGE" -> "image"
   - Default -> "pdf" (fallback)

4. Export `Citation` interface (reusable across all consumers):
   ```
   file_id: string
   locator: string
   excerpt?: string
   ```

5. Export `FindingCitation` interface (extends Citation concept, matches backend):
   ```
   finding_id: string
   excerpt: string
   ```

Add ABOUTME comment describing the file.

---

Create `frontend/src/hooks/useSourceNavigation.ts`:

1. Hook signature: `useSourceNavigation(caseId: string)` returning:
   ```
   {
     openSource: (citation: Citation) => Promise<void>
     openFromFinding: (findingId: string) => Promise<void>
     sourceContent: SourceViewerContent | null
     isLoading: boolean
     error: string | null
     closeSource: () => void
   }
   ```

2. Internal state: `sourceContent` (SourceViewerContent | null), `isLoading`, `error`, request counter ref for race condition prevention.

3. Fetch and cache case files list using React Query: `useQuery({ queryKey: ["case-files", caseId], queryFn: () => listFiles(caseId, 1, 200), staleTime: 5 * 60 * 1000 })`. This fetches all files once and caches them.

4. Use `useFileUrlCache` hook for signed URL caching.

5. `openSource(citation)` implementation:
   a. Increment request counter ref
   b. Set isLoading=true, error=null
   c. Look up file in cached files list by `citation.file_id`
   d. If not found, set error="Source file not available", return
   e. Get signed URL: check cache first via `getCachedUrl(caseId, citation.file_id)`, if miss call `getDownloadUrl(caseId, citation.file_id, true)` and cache via `setCachedUrl`
   f. Parse locator via `parseLocator(citation.locator)`
   g. Map category via `categoryToViewerType(file.category)`
   h. Build `SourceViewerContent` object:
      - type from category mapping
      - url from signed URL
      - fileName from file.original_filename
      - page from parsed locator (if type=page)
      - timestamp from parsed locator (if type=timestamp)
      - highlightText from citation.excerpt (only for PDF type, truncate to first 100 chars if longer)
   i. Check request counter -- only apply if still most recent
   j. Set sourceContent, isLoading=false

6. `openFromFinding(findingId)` implementation (two-hop resolution):
   a. Fetch finding detail via `api.get<FindingResponse>(/api/cases/${caseId}/findings/${findingId})`
   b. Import `api` from `@/lib/api-client` and define a local `FindingDetailResponse` type with `citations` array of `{ file_id: string; locator: string; excerpt: string }[]`
   c. If finding has citations and citations.length > 0, call `openSource(citations[0])` with the first citation
   d. If no citations, set error="No source citations available for this finding"

7. `closeSource()`: set sourceContent=null, error=null

8. Wrap `openSource` and `openFromFinding` in useCallback with proper dependencies.

Import from: `@/lib/citation-utils` (parseLocator, categoryToViewerType, Citation), `@/lib/api/files` (listFiles, getDownloadUrl, FileResponse), `@/hooks/useFileUrlCache`, `@/components/source-viewer/SourceViewerModal` (SourceViewerContent), `@/lib/api-client` (api, ApiError), `@tanstack/react-query` (useQuery).

Add ABOUTME comment.
  </action>
  <verify>
    Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run typecheck` -- zero type errors related to citation-utils.ts or useSourceNavigation.ts.
  </verify>
  <done>
    - parseLocator handles all 4 format types (page, timestamp, region, unknown)
    - categoryToViewerType maps all 4 file categories
    - useSourceNavigation hook compiles with all 6 return values
    - openFromFinding performs two-hop resolution (finding -> citations -> source)
    - Race condition protection via request counter ref
  </done>
</task>

<task type="auto">
  <name>Task 2: useEntityResolver hook and reusable UI components</name>
  <files>
    frontend/src/hooks/useEntityResolver.ts
    frontend/src/components/ui/citation-link.tsx
    frontend/src/components/ui/entity-badge.tsx
  </files>
  <action>
Create `frontend/src/hooks/useEntityResolver.ts`:

1. Export `ResolvedEntity` interface:
   ```
   id: string
   name: string
   entity_type: string
   color: string
   ```

2. Hook signature: `useEntityResolver(caseId: string)` returning:
   ```
   {
     resolveEntities: (ids: string[]) => ResolvedEntity[]
     getEntity: (id: string) => ResolvedEntity | null
     isLoading: boolean
     entityMap: Map<string, ResolvedEntity>
   }
   ```

3. Fetch all entities using React Query: `useQuery({ queryKey: ["case-graph", caseId], queryFn: () => fetchGraph(caseId), staleTime: 5 * 60 * 1000, enabled: !!caseId })`.

4. Build entity lookup Map in useMemo from graph data: `Map<string, ResolvedEntity>` keyed by entity.id, with name, entity_type, and color from `getEntityColor(entity.entity_type)`.

5. `getEntity(id)`: look up in Map, return null if not found.

6. `resolveEntities(ids)`: filter Map lookups, skip nulls, return array of ResolvedEntity. For IDs not found, include a fallback entry with name="Unknown Entity", entity_type="other", color from getEntityColor("other").

7. Return isLoading from the React Query state.

Import from: `@/lib/api/graph` (fetchGraph), `@/lib/knowledge-graph-config` (getEntityColor), `@/types/knowledge-graph` (GraphResponse), `@tanstack/react-query` (useQuery).

Add ABOUTME comment.

---

Create `frontend/src/components/ui/citation-link.tsx`:

1. Props interface:
   ```
   citation: { file_id: string; locator: string; excerpt?: string }
   fileName?: string        // Pre-resolved file name (from the file cache)
   isLoading?: boolean
   onClick: () => void
   ```

2. Render a button/clickable div:
   - FileText icon (from lucide-react, size 12)
   - File name text (or "Source Document" fallback if fileName not provided), truncated, text-xs
   - Locator badge (e.g., "Page 3" or "01:23:45"), text-[10px]
   - If excerpt, show truncated excerpt (line-clamp-1) in italics below
   - On hover: bg-charcoal/50 transition
   - Cursor pointer, rounded-lg, border border-stone/10, bg-charcoal/30
   - If isLoading, show a subtle pulse animation

3. Format locator for display:
   - "page:3" -> "Page 3"
   - "ts:01:23:45" -> "01:23:45"
   - Otherwise show raw locator text

Add ABOUTME comment.

---

Create `frontend/src/components/ui/entity-badge.tsx`:

1. Props interface:
   ```
   name: string
   entityType: string
   color?: string           // Override color (if caller already has it)
   onClick?: () => void
   ```

2. Render inline-flex badge (similar to GapDetailPanel entity rendering):
   - Colored dot (w-1.5 h-1.5 rounded-full) using color from `getEntityColor(entityType)` or the passed color prop
   - Entity name (text-xs text-smoke, truncate)
   - Entity type label (text-[10px] font-medium, uppercase tracking-wide, bg-stone/15 text-stone/80, rounded, px-1.5 py-0.5)
   - If onClick provided, render as button with hover:brightness-110 and cursor-pointer
   - Match the existing GapDetailPanel entity row styling (bg-charcoal/50 border border-stone/10 rounded-lg px-2.5 py-2)

3. Ensure the component uses `getEntityColor` from `@/lib/knowledge-graph-config` for the dot color when no color prop is passed.

Add ABOUTME comment.
  </action>
  <verify>
    Run `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run typecheck` -- zero type errors. Then run `bun run build` to verify no import resolution issues.
  </verify>
  <done>
    - useEntityResolver compiles and returns resolveEntities, getEntity, isLoading, entityMap
    - CitationLink renders clickable citation with file name, locator badge, and optional excerpt
    - EntityBadge renders color-coded entity name + type badge matching existing GapDetailPanel style
    - All three files pass type checking and build
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run typecheck` -- zero errors
2. `cd /Users/siddharth/Development/Hackathons/Gemini_3_2025/holmes/frontend && bun run build` -- builds successfully
3. All 5 new files exist with ABOUTME comments
4. No existing files modified (this plan only creates new files)
</verification>

<success_criteria>
- citation-utils.ts exports parseLocator, categoryToViewerType, Citation, ParsedLocator
- useSourceNavigation hook resolves citation -> SourceViewerContent with file metadata + signed URL + parsed locator
- useSourceNavigation.openFromFinding performs two-hop finding -> citation -> source resolution
- useEntityResolver hook resolves entity UUIDs to names + types using cached graph data
- CitationLink and EntityBadge are reusable UI components matching existing design system
- All files compile with zero type errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-source-panel/10-01-SUMMARY.md`
</output>
